-- ============================================================================
-- ENDGAME-001 Schema Baseline
-- Generated: 2026-02-18T04:23:24Z
-- K003c: Extract DB-Only Objects to Git
-- 
-- This file captures the COMPLETE public schema state as of this date.
-- 302 migrations were applied via MCP apply_migration tool but never committed
-- to git. This baseline ensures schema recovery from git alone.
-- 
-- Objects: ~95 tables, 456 functions, 30 views, 19 enums, ~20 triggers
-- ============================================================================

--
-- PostgreSQL database dump
--

-- \restrict 345qCG4fryG5UtnPOhAqTGFvQbxvasies3LxPOYMAKHqiyHKZCIZHz8alagbiez

-- Dumped from database version 17.6
-- Dumped by pg_dump version 18.2

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
-- SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: public; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA public;


--
-- Name: SCHEMA public; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON SCHEMA public IS 'standard public schema';


--
-- Name: agent_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.agent_type AS ENUM (
    'you',
    'engineering',
    'audit',
    'cto',
    'cpo',
    'research',
    'analysis',
    'external'
);


--
-- Name: audit_severity; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical'
);


--
-- Name: audit_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.audit_type AS ENUM (
    'scheduled',
    'post_deploy',
    'incident',
    'manual'
);


--
-- Name: conversation_source; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.conversation_source AS ENUM (
    'claude_web',
    'claude_api',
    'gpt',
    'slack',
    'email',
    'manual',
    'n8n',
    'claude_export',
    'portal'
);


--
-- Name: decision_status; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.decision_status AS ENUM (
    'active',
    'superseded',
    'reversed',
    'pending'
);


--
-- Name: decision_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.decision_type AS ENUM (
    'technical',
    'strategic',
    'operational',
    'financial',
    'legal'
);


--
-- Name: entity_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.entity_type AS ENUM (
    'person',
    'company',
    'project',
    'deal',
    'agent'
);


--
-- Name: error_category; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.error_category AS ENUM (
    'transition',
    'deployment',
    'qa',
    'gate',
    'validation',
    'intake',
    'rate_limit',
    'permission',
    'data_integrity',
    'external_service',
    'configuration'
);


--
-- Name: error_severity; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.error_severity AS ENUM (
    'fatal',
    'error',
    'warning',
    'info'
);


--
-- Name: execution_mode; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.execution_mode AS ENUM (
    'step',
    'batch',
    'auto'
);


--
-- Name: fact_category; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.fact_category AS ENUM (
    'stable',
    'temporal',
    'derived'
);


--
-- Name: implementation_status; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.implementation_status AS ENUM (
    'started',
    'testing',
    'failed',
    'succeeded',
    'deployed_staging',
    'deployed_prod',
    'rolled_back'
);


--
-- Name: message_role; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.message_role AS ENUM (
    'user',
    'assistant',
    'system',
    'tool'
);


--
-- Name: org_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.org_type AS ENUM (
    'aexodus',
    'basetwo',
    'personal',
    'master_layer'
);


--
-- Name: preference_scope; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.preference_scope AS ENUM (
    'user',
    'agent',
    'system',
    'org'
);


--
-- Name: query_intent; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.query_intent AS ENUM (
    'entity_lookup',
    'decision_recall',
    'preference_check',
    'conversation_search',
    'exploratory'
);


--
-- Name: work_order_complexity; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.work_order_complexity AS ENUM (
    'trivial',
    'small',
    'medium',
    'large',
    'unknown'
);


--
-- Name: work_order_priority; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.work_order_priority AS ENUM (
    'p0_critical',
    'p1_high',
    'p2_medium',
    'p3_low'
);


--
-- Name: work_order_status; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.work_order_status AS ENUM (
    'draft',
    'planning',
    'ready',
    'pending_approval',
    'in_progress',
    'blocked',
    'review',
    'done',
    'cancelled',
    'failed',
    'blocked_on_input'
);


--
-- Name: _internal_wo_transition_config_key(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public._internal_wo_transition_config_key() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$ SELECT chr(97)||chr(112)||chr(112)||chr(46)||chr(119)||chr(111)||chr(95)||chr(101)||chr(120)||chr(101)||chr(99)||chr(117)||chr(116)||chr(111)||chr(114)||chr(95)||chr(98)||chr(121)||chr(112)||chr(97)||chr(115)||chr(115) $$;


--
-- Name: acknowledge_lesson(uuid, uuid, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.acknowledge_lesson(p_work_order_id uuid, p_lesson_id uuid, p_decision text, p_rationale text DEFAULT NULL::text, p_acknowledged_by text DEFAULT 'engineering'::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_ack_id uuid;
  v_wo_slug text;
  v_lesson_pattern text;
BEGIN
  -- Validate decision
  IF p_decision NOT IN ('accepted', 'deferred', 'rejected') THEN
    RAISE EXCEPTION 'Invalid decision: %. Must be accepted, deferred, or rejected', p_decision;
  END IF;

  -- Validate WO exists and is in appropriate state
  SELECT slug INTO v_wo_slug FROM work_orders WHERE id = p_work_order_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Work order % not found', p_work_order_id;
  END IF;

  -- Get lesson pattern for logging
  SELECT pattern INTO v_lesson_pattern FROM lessons WHERE id = p_lesson_id;

  -- Insert or update acknowledgment
  INSERT INTO lesson_acknowledgments (
    work_order_id,
    lesson_id,
    decision,
    rationale,
    acknowledged_by,
    acknowledged_at
  ) VALUES (
    p_work_order_id,
    p_lesson_id,
    p_decision,
    p_rationale,
    p_acknowledged_by,
    now()
  )
  ON CONFLICT (work_order_id, lesson_id) 
  DO UPDATE SET
    decision = EXCLUDED.decision,
    rationale = EXCLUDED.rationale,
    acknowledged_by = EXCLUDED.acknowledged_by,
    acknowledged_at = now()
  RETURNING id INTO v_ack_id;

  -- Log to audit trail
  INSERT INTO audit_log (
    event_type,
    actor_type,
    actor_id,
    target_type,
    target_id,
    action,
    payload
  ) VALUES (
    'lesson_acknowledged',
    'agent',
    p_acknowledged_by,
    'lesson_acknowledgment',
    v_ack_id,
    'CREATE',
    jsonb_build_object(
      'work_order_id', p_work_order_id,
      'work_order_slug', v_wo_slug,
      'lesson_id', p_lesson_id,
      'lesson_pattern', v_lesson_pattern,
      'decision', p_decision,
      'rationale', p_rationale
    )
  );

  RETURN jsonb_build_object(
    'success', true,
    'acknowledgment_id', v_ack_id,
    'work_order_slug', v_wo_slug,
    'decision', p_decision
  );
END;
$$;


--
-- Name: FUNCTION acknowledge_lesson(p_work_order_id uuid, p_lesson_id uuid, p_decision text, p_rationale text, p_acknowledged_by text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.acknowledge_lesson(p_work_order_id uuid, p_lesson_id uuid, p_decision text, p_rationale text, p_acknowledged_by text) IS 'Records lesson acknowledgment decision during WO intake';


--
-- Name: acquire_file_lock(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.acquire_file_lock(p_wo_id uuid, p_file_path text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_conflict_exists boolean;
  v_existing_lock_id uuid;
BEGIN
  -- Check if we already hold a lock on this file
  SELECT id INTO v_existing_lock_id
  FROM wo_file_locks
  WHERE work_order_id = p_wo_id AND file_path = p_file_path AND released_at IS NULL;
  
  IF v_existing_lock_id IS NOT NULL THEN
    -- We already hold this lock, return true
    RETURN true;
  END IF;
  
  -- Check if another in_progress WO holds a lock on this file
  SELECT EXISTS (
    SELECT 1 FROM wo_file_locks l
    JOIN work_orders w ON w.id = l.work_order_id
    WHERE l.file_path = p_file_path
      AND l.released_at IS NULL
      AND l.work_order_id != p_wo_id
      AND w.status = 'in_progress'
  ) INTO v_conflict_exists;
  
  IF v_conflict_exists THEN
    RETURN false;
  END IF;
  
  -- No conflict, acquire the lock
  INSERT INTO wo_file_locks (work_order_id, file_path)
  VALUES (p_wo_id, p_file_path);
  
  RETURN true;
END;
$$;


--
-- Name: acquire_lock(text, text, text, text, integer, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.acquire_lock(p_agent_name text, p_resource_type text, p_resource_id text, p_lock_type text DEFAULT 'exclusive'::text, p_ttl_minutes integer DEFAULT 30, p_reason text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_agent_id UUID;
  v_existing_lock RECORD;
  v_lock_id UUID;
BEGIN
  -- Get agent ID
  SELECT id INTO v_agent_id FROM agents WHERE name = p_agent_name AND status = 'active';
  IF v_agent_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Agent not found or inactive');
  END IF;
  
  -- Check for existing exclusive lock by another agent
  SELECT * INTO v_existing_lock 
  FROM workspace_locks 
  WHERE resource_type = p_resource_type 
    AND resource_id = p_resource_id 
    AND lock_type = 'exclusive'
    AND agent_id != v_agent_id
    AND expires_at > now();
  
  IF FOUND THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Resource locked by another agent',
      'locked_by', (SELECT name FROM agents WHERE id = v_existing_lock.agent_id),
      'expires_at', v_existing_lock.expires_at
    );
  END IF;
  
  -- If requesting exclusive, check for any shared locks by others
  IF p_lock_type = 'exclusive' THEN
    SELECT * INTO v_existing_lock 
    FROM workspace_locks 
    WHERE resource_type = p_resource_type 
      AND resource_id = p_resource_id 
      AND agent_id != v_agent_id
      AND expires_at > now();
    
    IF FOUND THEN
      RETURN jsonb_build_object(
        'success', false, 
        'error', 'Resource has shared locks, cannot acquire exclusive',
        'locked_by', (SELECT name FROM agents WHERE id = v_existing_lock.agent_id)
      );
    END IF;
  END IF;
  
  -- Upsert the lock
  INSERT INTO workspace_locks (resource_type, resource_id, agent_id, lock_type, reason, expires_at)
  VALUES (p_resource_type, p_resource_id, v_agent_id, p_lock_type, p_reason, now() + (p_ttl_minutes || ' minutes')::interval)
  ON CONFLICT (resource_type, resource_id, agent_id) 
  DO UPDATE SET 
    lock_type = EXCLUDED.lock_type,
    reason = EXCLUDED.reason,
    expires_at = EXCLUDED.expires_at,
    acquired_at = now()
  RETURNING id INTO v_lock_id;
  
  RETURN jsonb_build_object('success', true, 'lock_id', v_lock_id);
END;
$$;


--
-- Name: acquire_pipeline_lock(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.acquire_pipeline_lock(p_pipeline_run_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Use advisory lock for this pipeline run
  PERFORM pg_advisory_xact_lock(
    ('x' || substr(md5(p_pipeline_run_id::text), 1, 15))::bit(64)::bigint
  );
  RETURN TRUE;
END;
$$;


--
-- Name: add_tool_to_builder(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.add_tool_to_builder(tool_name text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  UPDATE agents SET tools_allowed = tools_allowed || ARRAY[tool_name]::text[] WHERE name = 'builder';
END;
$$;


--
-- Name: advance_pipeline_phase(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.advance_pipeline_phase(p_pipeline_run_id uuid, p_triggering_wo_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_pipeline_run RECORD;
    v_phase_order TEXT[] := ARRAY['spec', 'plan', 'scaffold', 'build', 'verify', 'harden', 'integrate'];
    v_current_phase_idx INT;
    v_next_phase TEXT;
    v_skip_phases JSONB;
    v_spec_wo RECORD;
    v_child_wo JSONB;
    v_phase_history JSONB;
    v_new_phase_entry JSONB;
    v_spec_acceptance_criteria TEXT;
    v_resolved_agent TEXT;
    v_resolved_agent_id UUID;
    v_integration_objective TEXT;
    v_red_wo_id UUID;
    v_blue_wo_id UUID;
    v_red_wo JSONB;
    v_blue_wo JSONB;
    v_child_objective TEXT;
    v_child_acs TEXT;
    v_child_agent_name TEXT;
    v_child_agent_id UUID;
    v_child_tags TEXT[];
    v_compare_result JSONB;
    v_remediation_wo JSONB;
    v_verdict TEXT;
    v_build_children JSONB;
    v_build_entry JSONB;
    v_build_count INT := 0;
    v_build_wo_ids UUID[];
    v_dep_check JSONB;
BEGIN
    SELECT * INTO v_pipeline_run FROM pipeline_runs WHERE id = p_pipeline_run_id;
    IF NOT FOUND THEN
        RETURN jsonb_build_object('error', 'Pipeline run not found', 'pipeline_run_id', p_pipeline_run_id);
    END IF;
    
    -- PIPELINE DEPENDENCY CHECK: block if upstream pipelines not completed
    v_dep_check := check_pipeline_dependencies(p_pipeline_run_id);
    IF NOT (v_dep_check->>'satisfied')::boolean THEN
        RETURN jsonb_build_object('status', 'blocked',
            'reason', 'Upstream pipeline dependencies not satisfied',
            'blocking', v_dep_check->'blocking',
            'pipeline_run_id', p_pipeline_run_id);
    END IF;
    
    -- PHASE COMPLETION GUARD: wait for ALL children of current phase to complete
    IF EXISTS (
        SELECT 1 FROM work_orders 
        WHERE pipeline_run_id = p_pipeline_run_id 
          AND pipeline_phase = v_pipeline_run.current_phase
          AND status NOT IN ('done', 'cancelled', 'failed')
    ) THEN
        RETURN jsonb_build_object('status', 'waiting', 
            'reason', 'Phase children still in progress',
            'current_phase', v_pipeline_run.current_phase,
            'pipeline_run_id', p_pipeline_run_id);
    END IF;
    
    v_current_phase_idx := array_position(v_phase_order, v_pipeline_run.current_phase);
    IF v_current_phase_idx IS NULL THEN
        RETURN jsonb_build_object('error', 'Invalid current_phase', 'current_phase', v_pipeline_run.current_phase);
    END IF;
    
    v_next_phase := v_phase_order[v_current_phase_idx + 1];
    
    v_skip_phases := v_pipeline_run.config -> 'skip_phases';
    IF v_skip_phases IS NOT NULL AND jsonb_typeof(v_skip_phases) = 'array' AND jsonb_array_length(v_skip_phases) > 0 THEN
        WHILE v_next_phase IS NOT NULL LOOP
            IF v_next_phase = ANY(SELECT jsonb_array_elements_text(v_skip_phases)) THEN
                v_current_phase_idx := v_current_phase_idx + 1;
                IF v_current_phase_idx + 1 > array_length(v_phase_order, 1) THEN
                    v_next_phase := NULL;
                ELSE
                    v_next_phase := v_phase_order[v_current_phase_idx + 1];
                END IF;
            ELSE
                EXIT;
            END IF;
        END LOOP;
    END IF;
    
    -- Build phase_history entry for the CURRENT (completing) phase
    v_new_phase_entry := jsonb_build_object('phase', v_pipeline_run.current_phase, 'completed_at', NOW(), 'wo_id', p_triggering_wo_id);
    v_phase_history := COALESCE(v_pipeline_run.phase_history, '[]'::jsonb) || jsonb_build_array(v_new_phase_entry);
    
    -- PIPELINE COMPLETE: no next phase
    IF v_next_phase IS NULL THEN
        -- FIX: Write phase_history WITH the final phase BEFORE marking completed
        UPDATE pipeline_runs 
        SET status = 'completed', 
            phase_history = v_phase_history,
            updated_at = NOW() 
        WHERE id = p_pipeline_run_id;
        
        INSERT INTO wo_events (work_order_id, event_type, payload, actor)
        VALUES (v_pipeline_run.spec_wo_id, 'pipeline_phase_advanced', 
            jsonb_build_object('phase', 'completion', 'from_phase', v_pipeline_run.current_phase, 
                'pipeline_run_id', p_pipeline_run_id, 'triggering_wo_id', p_triggering_wo_id), 'system');
        
        RETURN jsonb_build_object('status', 'completed', 'pipeline_run_id', p_pipeline_run_id);
    END IF;
    
    SELECT id, slug, name, acceptance_criteria INTO v_spec_wo FROM work_orders WHERE id = v_pipeline_run.spec_wo_id;
    
    -- VERIFY PHASE
    IF v_next_phase = 'verify' THEN
        v_compare_result := compare_manifest_to_mutations(p_pipeline_run_id);
        
        IF v_compare_result ? 'error' THEN
            RETURN jsonb_build_object('status', 'verify_error', 'pipeline_run_id', p_pipeline_run_id, 'error', v_compare_result->>'error', 'phase', 'verify');
        END IF;
        
        UPDATE pipeline_runs SET current_phase = 'verify', phase_history = v_phase_history, updated_at = NOW() WHERE id = p_pipeline_run_id;
        
        INSERT INTO wo_events (work_order_id, event_type, payload, actor)
        VALUES (v_pipeline_run.spec_wo_id, 'pipeline_phase_advanced', 
            jsonb_build_object('phase', 'verify', 'from_phase', v_pipeline_run.current_phase, 
                'pipeline_run_id', p_pipeline_run_id, 'compare_result', v_compare_result), 'system');
        
        v_verdict := COALESCE(v_compare_result->>'verdict', 'unknown');
        
        IF v_verdict IN ('pass', 'no_manifest', 'no_mutations') THEN
            RETURN advance_pipeline_phase(p_pipeline_run_id, NULL);
        ELSIF v_verdict = 'fail' THEN
            PERFORM set_config('app.state_write_bypass', 'true', true);
            v_remediation_wo := create_draft_work_order(
                NULL,
                'Pipeline ' || COALESCE(v_spec_wo.slug, '?') || ': VERIFY remediation',
                'Fix unmatched planned actions from VERIFY. Unmatched: ' || COALESCE(v_compare_result->>'unmatched_planned', '[]') ||
                '. Unplanned: ' || COALESCE(v_compare_result->>'unplanned_executed', '[]'),
                'p1_high'::work_order_priority, 'manifold',
                ARRAY['manifold-v1', 'pipeline-phase', 'verify', 'remediation'],
                '1. Execute each unmatched planned action' || chr(10) ||
                '2. Record fixes as wo_mutations' || chr(10) ||
                '3. Re-run compare_manifest_to_mutations() and get verdict=pass',
                v_pipeline_run.spec_wo_id);
            
            v_resolved_agent := resolve_pipeline_agent(v_pipeline_run.config, 'verify');
            SELECT id INTO v_resolved_agent_id FROM agents WHERE name = v_resolved_agent AND status = 'active';
            IF v_resolved_agent_id IS NOT NULL THEN
                UPDATE work_orders SET assigned_to = v_resolved_agent_id, pipeline_phase = 'verify', pipeline_run_id = p_pipeline_run_id
                WHERE id = (v_remediation_wo->>'id')::uuid;
            END IF;
            
            PERFORM wo_transition(
                (v_remediation_wo->>'id')::uuid,
                'pipeline_dispatch',
                jsonb_build_object(
                    'pipeline_run_id', p_pipeline_run_id,
                    'pipeline_phase', 'verify',
                    'parent_spec_wo', v_spec_wo.slug
                ),
                'manifold'
            );
            
            RETURN jsonb_build_object('status', 'verify_failed', 'pipeline_run_id', p_pipeline_run_id,
                'remediation_wo_id', v_remediation_wo->>'id', 'compare_result', v_compare_result,
                'assigned_agent', v_resolved_agent);
        ELSE
            RETURN jsonb_build_object('status', 'verify_error', 'pipeline_run_id', p_pipeline_run_id,
                'error', 'Unknown verdict: ' || v_verdict, 'phase', 'verify');
        END IF;
    END IF;
    
    -- HARDEN PHASE
    IF v_next_phase = 'harden' THEN
        UPDATE pipeline_runs SET current_phase = 'harden', phase_history = v_phase_history, updated_at = NOW() WHERE id = p_pipeline_run_id;
        PERFORM set_config('app.state_write_bypass', 'true', true);
        
        v_red_wo := create_draft_work_order(NULL,
            'Pipeline ' || COALESCE(v_spec_wo.slug, '?') || ': HARDEN red-team',
            'Red-team adversarial review: find failure modes, execute adversarial test queries, check edge cases, verify error handling. Record every finding.',
            'p2_medium'::work_order_priority, 'manifold',
            ARRAY['manifold-v1', 'pipeline-phase', 'harden', 'red-team'],
            '1. Execute at least 3 adversarial test scenarios' || chr(10) ||
            '2. Record each finding as a wo_mutation with error details' || chr(10) ||
            '3. Submit findings summary for blue-team remediation',
            v_pipeline_run.spec_wo_id);
        v_red_wo_id := (v_red_wo->>'id')::uuid;
        
        v_resolved_agent := resolve_pipeline_agent(v_pipeline_run.config, 'harden_red', 'security');
        SELECT id INTO v_resolved_agent_id FROM agents WHERE name = v_resolved_agent AND status = 'active';
        IF v_resolved_agent_id IS NOT NULL THEN
            UPDATE work_orders SET assigned_to = v_resolved_agent_id, pipeline_phase = 'harden', pipeline_run_id = p_pipeline_run_id WHERE id = v_red_wo_id;
        END IF;
        
        PERFORM wo_transition(
            v_red_wo_id,
            'pipeline_dispatch',
            jsonb_build_object(
                'pipeline_run_id', p_pipeline_run_id,
                'pipeline_phase', 'harden',
                'parent_spec_wo', v_spec_wo.slug,
                'team', 'red'
            ),
            'manifold'
        );
        
        v_blue_wo := create_draft_work_order(NULL,
            'Pipeline ' || COALESCE(v_spec_wo.slug, '?') || ': HARDEN blue-team',
            'Blue-team defensive fixes: address all red-team findings. Each finding must have a corresponding fix mutation.',
            'p2_medium'::work_order_priority, 'manifold',
            ARRAY['manifold-v1', 'pipeline-phase', 'harden', 'blue-team'],
            '1. Review red-team findings from sibling WO' || chr(10) ||
            '2. Create a fix mutation for each finding' || chr(10) ||
            '3. Record all fixes and submit for evaluation',
            v_pipeline_run.spec_wo_id);
        v_blue_wo_id := (v_blue_wo->>'id')::uuid;
        
        v_resolved_agent := resolve_pipeline_agent(v_pipeline_run.config, 'harden_blue');
        SELECT id INTO v_resolved_agent_id FROM agents WHERE name = v_resolved_agent AND status = 'active';
        IF v_resolved_agent_id IS NOT NULL THEN
            UPDATE work_orders SET assigned_to = v_resolved_agent_id, pipeline_phase = 'harden', pipeline_run_id = p_pipeline_run_id WHERE id = v_blue_wo_id;
        END IF;
        
        PERFORM wo_transition(
            v_blue_wo_id,
            'pipeline_dispatch',
            jsonb_build_object(
                'pipeline_run_id', p_pipeline_run_id,
                'pipeline_phase', 'harden',
                'parent_spec_wo', v_spec_wo.slug,
                'team', 'blue'
            ),
            'manifold'
        );
        
        INSERT INTO wo_events (work_order_id, event_type, payload, actor)
        VALUES (v_pipeline_run.spec_wo_id, 'pipeline_phase_advanced',
            jsonb_build_object('phase', 'harden', 'from_phase', v_pipeline_run.current_phase,
                'pipeline_run_id', p_pipeline_run_id, 'red_wo_id', v_red_wo_id, 'blue_wo_id', v_blue_wo_id), 'system');
        
        RETURN jsonb_build_object('status', 'phase_advanced', 'phase', 'harden',
            'pipeline_run_id', p_pipeline_run_id,
            'red_wo_id', v_red_wo_id, 'red_wo_slug', v_red_wo->>'slug',
            'blue_wo_id', v_blue_wo_id, 'blue_wo_slug', v_blue_wo->>'slug');
    END IF;
    
    -- INTEGRATE PHASE
    IF v_next_phase = 'integrate' THEN
        UPDATE pipeline_runs SET current_phase = 'integrate', phase_history = v_phase_history, updated_at = NOW() WHERE id = p_pipeline_run_id;
        PERFORM set_config('app.state_write_bypass', 'true', true);
        
        v_spec_acceptance_criteria := COALESCE(v_spec_wo.acceptance_criteria, '');
        v_integration_objective := 'INTEGRATE phase: Compare final implementation against original spec ' || COALESCE(v_spec_wo.slug, '?') ||
            '. Original ACs: ' || v_spec_acceptance_criteria || '. Review all mutations and verify each AC is satisfied.';
        
        v_child_wo := create_draft_work_order(NULL,
            'Pipeline ' || COALESCE(v_spec_wo.slug, '?') || ': INTEGRATE spec oracle',
            v_integration_objective,
            'p2_medium'::work_order_priority, 'manifold',
            ARRAY['manifold-v1', 'pipeline-phase', 'integrate'],
            '1. Compare each original AC from spec WO against recorded mutations' || chr(10) ||
            '2. Identify any ACs not satisfied by implementation' || chr(10) ||
            '3. Return pass if all ACs satisfied, fail with gap list otherwise',
            v_pipeline_run.spec_wo_id);
        
        v_resolved_agent := resolve_pipeline_agent(v_pipeline_run.config, 'integrate');
        SELECT id INTO v_resolved_agent_id FROM agents WHERE name = v_resolved_agent AND status = 'active';
        IF v_resolved_agent_id IS NOT NULL THEN
            UPDATE work_orders SET assigned_to = v_resolved_agent_id, pipeline_phase = 'integrate', pipeline_run_id = p_pipeline_run_id
            WHERE id = (v_child_wo->>'id')::uuid;
        END IF;
        
        PERFORM wo_transition(
            (v_child_wo->>'id')::uuid,
            'pipeline_dispatch',
            jsonb_build_object(
                'pipeline_run_id', p_pipeline_run_id,
                'pipeline_phase', 'integrate',
                'parent_spec_wo', v_spec_wo.slug
            ),
            'manifold'
        );
        
        INSERT INTO wo_events (work_order_id, event_type, payload, actor)
        VALUES (v_pipeline_run.spec_wo_id, 'pipeline_phase_advanced',
            jsonb_build_object('phase', 'integrate', 'from_phase', v_pipeline_run.current_phase,
                'pipeline_run_id', p_pipeline_run_id, 'child_wo_id', (v_child_wo->>'id')::uuid), 'system');
        
        RETURN jsonb_build_object('status', 'phase_advanced', 'phase', 'integrate',
            'pipeline_run_id', p_pipeline_run_id, 'child_wo_id', v_child_wo->>'id',
            'child_wo_slug', v_child_wo->>'slug', 'child_agent', v_resolved_agent);
    END IF;
    
    -- DEFAULT: plan, scaffold, build phases
    UPDATE pipeline_runs SET current_phase = v_next_phase, phase_history = v_phase_history, updated_at = NOW() WHERE id = p_pipeline_run_id;
    PERFORM set_config('app.state_write_bypass', 'true', true);
    
    -- MULTI-CHILD BUILD
    IF v_next_phase = 'build' THEN
        v_build_children := get_build_children(p_pipeline_run_id);
        IF jsonb_array_length(v_build_children) > 0 THEN
            v_build_wo_ids := '{}';
            FOR v_build_entry IN SELECT value FROM jsonb_array_elements(v_build_children) LOOP
                v_child_objective := COALESCE(v_build_entry->'build_plan'->>'objective', 
                    'BUILD phase step ' || (v_build_entry->>'step_order') || ' for spec: ' || COALESCE(v_spec_wo.slug, '?'));
                v_child_acs := COALESCE(v_build_entry->'build_plan'->>'acceptance_criteria',
                    '1. Execute planned action' || chr(10) || '2. Record mutations' || chr(10) || '3. Submit for review');
                v_child_agent_name := resolve_pipeline_agent(
                    v_pipeline_run.config, 'build',
                    COALESCE(v_build_entry->'build_plan'->>'agent', NULL)
                );
                v_child_tags := ARRAY['manifold-v1', 'pipeline-phase', 'build'];
                IF v_build_entry->'build_plan' ? 'tags' THEN
                    SELECT array_cat(v_child_tags, array_agg(t))
                    INTO v_child_tags
                    FROM jsonb_array_elements_text(v_build_entry->'build_plan'->'tags') t;
                END IF;
                
                v_child_wo := create_draft_work_order(NULL,
                    'Pipeline ' || COALESCE(v_spec_wo.slug, '?') || ': BUILD step ' || (v_build_entry->>'step_order'),
                    v_child_objective,
                    'p2_medium'::work_order_priority, 'manifold', v_child_tags,
                    v_child_acs, v_pipeline_run.spec_wo_id);
                
                SELECT id INTO v_child_agent_id FROM agents WHERE name = v_child_agent_name AND status = 'active';
                IF v_child_agent_id IS NOT NULL THEN
                    UPDATE work_orders SET assigned_to = v_child_agent_id, pipeline_phase = 'build', pipeline_run_id = p_pipeline_run_id
                    WHERE id = (v_child_wo->>'id')::uuid;
                END IF;
                
                PERFORM wo_transition(
                    (v_child_wo->>'id')::uuid,
                    'pipeline_dispatch',
                    jsonb_build_object(
                        'pipeline_run_id', p_pipeline_run_id,
                        'pipeline_phase', 'build',
                        'parent_spec_wo', v_spec_wo.slug,
                        'build_step', v_build_entry->>'step_order'
                    ),
                    'manifold'
                );
                
                v_build_wo_ids := array_append(v_build_wo_ids, (v_child_wo->>'id')::uuid);
                v_build_count := v_build_count + 1;
            END LOOP;
            
            INSERT INTO wo_events (work_order_id, event_type, payload, actor)
            VALUES (v_pipeline_run.spec_wo_id, 'pipeline_phase_advanced',
                jsonb_build_object('phase', 'build', 'from_phase', v_pipeline_run.current_phase,
                    'pipeline_run_id', p_pipeline_run_id, 'child_count', v_build_count,
                    'child_wo_ids', to_jsonb(v_build_wo_ids)), 'system');
            
            RETURN jsonb_build_object('status', 'phase_advanced', 'phase', 'build',
                'pipeline_run_id', p_pipeline_run_id, 'child_count', v_build_count,
                'child_wo_ids', to_jsonb(v_build_wo_ids));
        END IF;
    END IF;
    
    -- Single-child creation for plan, scaffold, build (fallback)
    v_child_agent_name := resolve_pipeline_agent(v_pipeline_run.config, v_next_phase);
    v_child_tags := ARRAY['manifold-v1', 'pipeline-phase', v_next_phase];
    
    CASE v_next_phase
        WHEN 'plan' THEN
            v_child_objective := 'PLAN phase: Generate action plan using mcts_plan_actions() for spec: ' || COALESCE(v_spec_wo.slug, '?');
            v_child_acs := '1. Identify target objects from spec objective using object_registry' || chr(10) ||
                '2. Call mcts_plan_actions() with target object UUIDs' || chr(10) ||
                '3. Store ranked action plan as execution manifest via append_manifest_step()';
        WHEN 'scaffold' THEN
            v_child_objective := 'SCAFFOLD phase: Generate type contracts for spec: ' || COALESCE(v_spec_wo.slug, '?');
            v_child_acs := '1. Read execution manifest for planned actions' || chr(10) ||
                '2. Generate scaffold_contracts with input/output schemas' || chr(10) ||
                '3. Call validate_scaffold_contracts() to check type consistency';
        WHEN 'build' THEN
            v_child_objective := 'BUILD phase: Execute the planned actions for spec: ' || COALESCE(v_spec_wo.slug, '?');
            v_child_acs := '1. Read execution manifest for this pipeline run' || chr(10) ||
                '2. Execute each planned action and record mutations' || chr(10) ||
                '3. Submit for review when all planned actions complete';
        ELSE
            v_child_objective := v_next_phase || ' phase for spec: ' || COALESCE(v_spec_wo.slug, '?');
            v_child_acs := '1. Complete ' || v_next_phase || ' phase objectives' || chr(10) ||
                '2. Record all mutations' || chr(10) || '3. Submit for review';
    END CASE;
    
    v_child_wo := create_draft_work_order(NULL,
        'Pipeline ' || COALESCE(v_spec_wo.slug, '?') || ': ' || upper(v_next_phase) || ' phase',
        v_child_objective, 'p2_medium'::work_order_priority, 'manifold', v_child_tags,
        v_child_acs, v_pipeline_run.spec_wo_id);
    
    SELECT id INTO v_child_agent_id FROM agents WHERE name = v_child_agent_name AND status = 'active';
    IF v_child_agent_id IS NOT NULL THEN
        UPDATE work_orders SET assigned_to = v_child_agent_id, pipeline_phase = v_next_phase, pipeline_run_id = p_pipeline_run_id
        WHERE id = (v_child_wo->>'id')::uuid;
    END IF;
    
    PERFORM wo_transition(
        (v_child_wo->>'id')::uuid,
        'pipeline_dispatch',
        jsonb_build_object(
            'pipeline_run_id', p_pipeline_run_id,
            'pipeline_phase', v_next_phase,
            'parent_spec_wo', v_spec_wo.slug
        ),
        'manifold'
    );
    
    INSERT INTO wo_events (work_order_id, event_type, payload, actor)
    VALUES (v_pipeline_run.spec_wo_id, 'pipeline_phase_advanced',
        jsonb_build_object('phase', v_next_phase, 'from_phase', v_pipeline_run.current_phase,
            'pipeline_run_id', p_pipeline_run_id, 'child_wo_id', (v_child_wo->>'id')::uuid), 'system');
    
    RETURN jsonb_build_object('status', 'phase_advanced', 'phase', v_next_phase,
        'pipeline_run_id', p_pipeline_run_id, 'child_wo_id', v_child_wo->>'id',
        'child_wo_slug', v_child_wo->>'slug', 'child_agent', v_child_agent_name);
END;
$$;


--
-- Name: analyze_wo_scope(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.analyze_wo_scope(p_objective text, p_acceptance_criteria text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_combined_text text;
  v_affected_tables text[] := ARRAY[]::text[];
  v_affected_functions text[] := ARRAY[]::text[];
  v_affected_files text[] := ARRAY[]::text[];
  v_required_tools text[] := ARRAY[]::text[];
  v_estimated_ac_count int := 0;
  v_has_verification boolean := false;
  v_specificity_score int := 0;
  v_deterministic_score int := 0;
  v_verification_count int := 0;
  v_issues text[] := ARRAY[]::text[];
  v_table_match text;
  v_func_match text;
  v_file_match text;
BEGIN
  v_combined_text := COALESCE(p_objective, '') || ' ' || COALESCE(p_acceptance_criteria, '');
  
  -- Extract affected tables
  FOR v_table_match IN 
    SELECT (regexp_matches(v_combined_text, '(?:CREATE|ALTER|DROP)\s+TABLE\s+(\w+)', 'gi'))[1]
  LOOP
    IF length(v_table_match) > 2 THEN
      v_affected_tables := array_append(v_affected_tables, v_table_match);
    END IF;
  END LOOP;
  
  -- Extract affected functions
  FOR v_func_match IN 
    SELECT (regexp_matches(v_combined_text, '(?:CREATE|ALTER|DROP)\s+(?:OR\s+REPLACE\s+)?FUNCTION\s+(\w+)', 'gi'))[1]
  LOOP
    IF length(v_func_match) > 2 THEN
      v_affected_functions := array_append(v_affected_functions, v_func_match);
    END IF;
  END LOOP;
  
  -- Extract affected files
  FOR v_file_match IN 
    SELECT (regexp_matches(v_combined_text, '(?:supabase/functions|src|scripts|migrations|tests|docs)/[\w/.-]+\.(?:ts|js|sql|json|md|yml|yaml|html|css)', 'gi'))[1]
  LOOP
    v_affected_files := array_append(v_affected_files, v_file_match);
  END LOOP;
  
  -- Deduplicate
  v_affected_tables := array(SELECT DISTINCT unnest(v_affected_tables));
  v_affected_functions := array(SELECT DISTINCT unnest(v_affected_functions));
  v_affected_files := array(SELECT DISTINCT unnest(v_affected_files));
  
  -- Map required tools
  IF array_length(v_affected_tables, 1) > 0 
     OR v_combined_text ILIKE '%ALTER TABLE%' 
     OR v_combined_text ILIKE '%CREATE TABLE%' 
     OR v_combined_text ILIKE '%DROP TABLE%' THEN
    v_required_tools := array_append(v_required_tools, 'apply_migration');
  END IF;
  
  IF array_length(v_affected_files, 1) > 0 THEN
    v_required_tools := array_append(v_required_tools, 'github_push_files');
  END IF;
  
  IF v_combined_text ILIKE '%SELECT%' OR v_combined_text ILIKE '%INSERT%' 
     OR v_combined_text ILIKE '%UPDATE%' OR v_combined_text ILIKE '%DELETE%' THEN
    v_required_tools := array_append(v_required_tools, 'execute_sql');
  END IF;
  
  IF v_combined_text ILIKE '%deploy%' OR v_combined_text ILIKE '%edge function%' 
     OR v_combined_text ILIKE '%supabase function%' THEN
    v_required_tools := array_append(v_required_tools, 'deploy_edge_function');
  END IF;
  
  IF v_combined_text ILIKE '%test%' OR v_combined_text ILIKE '%verify%' 
     OR v_combined_text ILIKE '%check%' THEN
    v_required_tools := array_append(v_required_tools, 'sandbox_exec');
  END IF;
  
  v_required_tools := array(SELECT DISTINCT unnest(v_required_tools));
  
  -- Count acceptance criteria
  v_estimated_ac_count := (SELECT count(*) FROM regexp_matches(COALESCE(p_acceptance_criteria, ''), '\d+[.:)]', 'g'));
  
  -- Check verification patterns
  v_verification_count := (SELECT count(*) FROM regexp_matches(COALESCE(p_acceptance_criteria, ''), '(?:SELECT|VERIFY|CHECK|COUNT|RETURNS|EXPECT|SHOULD\s+EQUAL|VERIFICATION)', 'gi'));
  v_has_verification := v_verification_count > 0;
  
  -- Specificity score (0-10) — unchanged
  IF length(COALESCE(p_objective, '')) > 20 THEN
    v_specificity_score := v_specificity_score + 2;
  END IF;
  IF v_estimated_ac_count >= 1 THEN
    v_specificity_score := v_specificity_score + 2;
  END IF;
  IF COALESCE(p_acceptance_criteria, '') ILIKE '%CREATE%' 
     OR COALESCE(p_acceptance_criteria, '') ILIKE '%ADD%' 
     OR COALESCE(p_acceptance_criteria, '') ILIKE '%INSERT%' THEN
    v_specificity_score := v_specificity_score + 2;
  END IF;
  IF array_length(v_affected_tables, 1) > 0 THEN
    v_specificity_score := v_specificity_score + 1;
  END IF;
  IF array_length(v_affected_functions, 1) > 0 THEN
    v_specificity_score := v_specificity_score + 1;
  END IF;
  IF array_length(v_affected_files, 1) > 0 THEN
    v_specificity_score := v_specificity_score + 1;
  END IF;
  IF v_has_verification THEN
    v_specificity_score := v_specificity_score + 1;
  END IF;
  v_specificity_score := LEAST(v_specificity_score, 10);
  
  -- WS4A: NEW deterministic score (0-10) — multi-signal, not just verification keywords
  v_deterministic_score := 0;
  
  -- +2 if ACs exist and are numbered
  IF v_estimated_ac_count >= 1 THEN
    v_deterministic_score := v_deterministic_score + 2;
  END IF;
  
  -- +2 if ACs contain object names (tables, functions, files, columns)
  IF v_combined_text ~ '(?i)(wo_|work_orders|audit_log|execution_log|qa_findings|wo_effects|wo_state_machine|agents|system_settings|pipeline_runs|wo_mutations)' 
     OR array_length(v_affected_tables, 1) > 0
     OR array_length(v_affected_functions, 1) > 0
     OR array_length(v_affected_files, 1) > 0 THEN
    v_deterministic_score := v_deterministic_score + 2;
  END IF;
  
  -- +2 if ACs contain measurable criteria
  IF v_combined_text ~* '(?:exists|returns|contains|equals|must be|should be|is set|is not null|greater than|less than|matches|includes)' THEN
    v_deterministic_score := v_deterministic_score + 2;
  END IF;
  
  -- +2 if ACs contain action verbs (CREATE, INSERT, UPDATE, ALTER, DROP, DEPLOY, IMPLEMENT)
  IF v_combined_text ~* '(?:CREATE|INSERT|UPDATE|ALTER|DROP|DEPLOY|IMPLEMENT|ADD|REMOVE|MODIFY|CONFIGURE|ENABLE|DISABLE)' THEN
    v_deterministic_score := v_deterministic_score + 2;
  END IF;
  
  -- +2 if verification queries or testable state references
  IF v_has_verification THEN
    v_deterministic_score := v_deterministic_score + 2;
  END IF;
  
  v_deterministic_score := LEAST(v_deterministic_score, 10);
  
  -- Build issues
  IF v_specificity_score < 4 THEN
    v_issues := array_append(v_issues, 'Specificity score is ' || v_specificity_score || '/10');
  END IF;
  IF v_deterministic_score < 5 THEN
    v_issues := array_append(v_issues, 'Deterministic score is ' || v_deterministic_score || '/10');
  END IF;
  IF v_estimated_ac_count = 0 THEN
    v_issues := array_append(v_issues, 'No numbered ACs found');
  END IF;
  
  RETURN jsonb_build_object(
    'affected_tables', v_affected_tables,
    'affected_functions', v_affected_functions,
    'affected_files', v_affected_files,
    'required_tools', v_required_tools,
    'estimated_ac_count', v_estimated_ac_count,
    'has_verification', v_has_verification,
    'specificity_score', v_specificity_score,
    'deterministic_score', v_deterministic_score,
    'verification_count', v_verification_count,
    'issues', CASE WHEN array_length(v_issues, 1) > 0 THEN v_issues ELSE NULL END
  );
END;
$$;


--
-- Name: append_manifest_step(uuid, integer, integer, text, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.append_manifest_step(p_work_order_id uuid, p_ac_number integer, p_step_order integer, p_tool text, p_action text, p_object_type text, p_object_id text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_inserted_row wo_execution_manifest%ROWTYPE;
BEGIN
  -- Verify work_order_id exists
  IF NOT EXISTS (SELECT 1 FROM work_orders WHERE id = p_work_order_id) THEN
    RAISE EXCEPTION 'Work order with id % does not exist', p_work_order_id;
  END IF;

  INSERT INTO wo_execution_manifest (
    work_order_id,
    ac_number,
    step_order,
    expected_tool,
    expected_action,
    expected_object_type,
    expected_object_id,
    required,
    discovered
  ) VALUES (
    p_work_order_id,
    p_ac_number,
    p_step_order,
    p_tool,
    p_action,
    p_object_type,
    p_object_id,
    false,  -- required defaults to false
    true    -- discovered is always true
  )
  RETURNING * INTO v_inserted_row;

  RETURN row_to_json(v_inserted_row);
END;
$$;


--
-- Name: apply_down_migration(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.apply_down_migration(p_version text, p_down_sql text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_down_sql TEXT;
  v_result JSONB;
  v_error_message TEXT;
BEGIN
  -- If SQL not provided, look it up in system_manifest
  IF p_down_sql IS NULL THEN
    SELECT config->>'down_sql' INTO v_down_sql
    FROM system_manifest
    WHERE component_type = 'migration'
    AND name = p_version;

    IF v_down_sql IS NULL THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Down migration SQL not found for version ' || p_version,
        'message', 'No down migration registered in system_manifest'
      );
    END IF;
  ELSE
    v_down_sql := p_down_sql;
  END IF;

  -- Execute the down migration SQL
  BEGIN
    EXECUTE v_down_sql;

    -- Log the rollback in audit_log
    INSERT INTO audit_log (
      event_type,
      actor_type,
      action,
      payload,
      created_at
    ) VALUES (
      'migration_rollback',
      'system',
      'apply_down_migration',
      jsonb_build_object(
        'version', p_version,
        'sql_length', length(v_down_sql)
      ),
      now()
    );

    RETURN jsonb_build_object(
      'success', true,
      'version', p_version,
      'message', 'Down migration applied successfully'
    );

  EXCEPTION WHEN OTHERS THEN
    GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;

    -- Log the failure
    INSERT INTO audit_log (
      event_type,
      actor_type,
      action,
      payload,
      created_at
    ) VALUES (
      'migration_rollback_failed',
      'system',
      'apply_down_migration',
      jsonb_build_object(
        'version', p_version,
        'error', v_error_message
      ),
      now()
    );

    RETURN jsonb_build_object(
      'success', false,
      'version', p_version,
      'error', v_error_message
    );
  END;
END;
$$;


--
-- Name: FUNCTION apply_down_migration(p_version text, p_down_sql text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.apply_down_migration(p_version text, p_down_sql text) IS 'Apply a down migration to rollback database changes. Requires version number and optionally SQL content (otherwise looks up in system_manifest).';


--
-- Name: approve_batch(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.approve_batch(p_batch_id uuid, p_approved_by text DEFAULT 'engineering'::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_batch RECORD;
  v_wo_count INT := 0;
  v_approved_count INT := 0;
  v_skipped_count INT := 0;
  v_wo RECORD;
  v_error_messages TEXT[] := '{}';
BEGIN
  -- Verify batch exists
  SELECT * INTO v_batch
  FROM wo_batches
  WHERE id = p_batch_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Batch not found',
      'batch_id', p_batch_id
    );
  END IF;

  -- Check if batch is already approved
  IF v_batch.status != 'draft' THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Batch is not in draft status',
      'batch_id', p_batch_id,
      'current_status', v_batch.status
    );
  END IF;

  -- Count total WOs in batch
  SELECT COUNT(*) INTO v_wo_count
  FROM work_orders
  WHERE batch_id = p_batch_id;

  -- Approve all draft WOs in the batch that require approval
  FOR v_wo IN 
    SELECT id, slug, status, requires_approval
    FROM work_orders
    WHERE batch_id = p_batch_id
      AND status IN ('draft', 'pending_approval')
  LOOP
    BEGIN
      -- Update WO to approved state if it requires approval
      IF v_wo.requires_approval THEN
        UPDATE work_orders
        SET 
          approved_by = p_approved_by,
          approved_at = now(),
          status = CASE 
            WHEN status = 'draft' THEN 'ready'
            WHEN status = 'pending_approval' THEN 'ready'
            ELSE status
          END,
          updated_at = now()
        WHERE id = v_wo.id;
        
        v_approved_count := v_approved_count + 1;
      ELSE
        -- Just mark as ready if it doesn't require approval
        UPDATE work_orders
        SET 
          status = 'ready',
          updated_at = now()
        WHERE id = v_wo.id
          AND status = 'draft';
        
        IF FOUND THEN
          v_approved_count := v_approved_count + 1;
        ELSE
          v_skipped_count := v_skipped_count + 1;
        END IF;
      END IF;

    EXCEPTION WHEN OTHERS THEN
      v_error_messages := array_append(v_error_messages, 
        format('WO %s: %s', v_wo.slug, SQLERRM));
      v_skipped_count := v_skipped_count + 1;
    END;
  END LOOP;

  -- Update batch status
  UPDATE wo_batches
  SET 
    status = 'approved',
    approved_by = p_approved_by,
    approved_at = now(),
    updated_at = now()
  WHERE id = p_batch_id;

  -- Log to audit_log
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
  VALUES (
    'batch_approved',
    'agent',
    p_approved_by,
    'wo_batch',
    p_batch_id,
    'APPROVE',
    jsonb_build_object(
      'batch_name', v_batch.name,
      'total_wos', v_wo_count,
      'approved_count', v_approved_count,
      'skipped_count', v_skipped_count,
      'errors', v_error_messages
    )
  );

  RETURN jsonb_build_object(
    'success', true,
    'batch_id', p_batch_id,
    'batch_name', v_batch.name,
    'total_wos', v_wo_count,
    'approved_count', v_approved_count,
    'skipped_count', v_skipped_count,
    'errors', v_error_messages
  );
END;
$$;


--
-- Name: FUNCTION approve_batch(p_batch_id uuid, p_approved_by text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.approve_batch(p_batch_id uuid, p_approved_by text) IS 'Atomically approve all draft/pending_approval WOs in a batch and mark batch as approved';


--
-- Name: archive_execution_logs(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.archive_execution_logs() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_archived_count integer;
BEGIN
  -- Copy old rows to archive, then delete from source
  WITH archived_rows AS (
    INSERT INTO execution_log_archive (
      id,
      work_order_id,
      phase,
      agent_name,
      detail,
      iteration,
      created_at,
      prev_hash,
      entry_hash,
      archived_at
    )
    SELECT 
      id,
      work_order_id,
      phase,
      agent_name,
      detail,
      iteration,
      created_at,
      prev_hash,
      entry_hash,
      now()
    FROM work_order_execution_log
    WHERE 
      -- Stream phase entries older than 3 days
      (phase = 'stream' AND created_at < now() - interval '3 days')
      OR
      -- All other entries older than 30 days
      (phase != 'stream' AND created_at < now() - interval '30 days')
    RETURNING id
  ),
  deleted_rows AS (
    DELETE FROM work_order_execution_log
    WHERE id IN (SELECT id FROM archived_rows)
    RETURNING id
  )
  SELECT count(*) INTO v_archived_count FROM deleted_rows;
  
  RETURN v_archived_count;
END;
$$;


--
-- Name: FUNCTION archive_execution_logs(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.archive_execution_logs() IS 'Archives execution log entries: stream phase >3 days old, others >30 days old. Returns count of archived rows.';


--
-- Name: archive_project_document(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.archive_project_document(p_doc_id uuid, p_archival_reason text DEFAULT 'Stale document (>7 days without updates)'::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_result JSONB;
BEGIN
  -- Update the document to archived status with metadata
  UPDATE project_documents
  SET 
    status = 'archived',
    metadata = jsonb_set(
      jsonb_set(
        jsonb_set(
          COALESCE(metadata, '{}'::jsonb),
          '{doc_category}',
          '"archived"'::jsonb
        ),
        '{archival_reason}',
        to_jsonb(p_archival_reason)
      ),
      '{archived_at}',
      to_jsonb(NOW()::text)
    ),
    updated_at = NOW()
  WHERE id = p_doc_id
  RETURNING jsonb_build_object(
    'id', id,
    'title', title,
    'status', status,
    'metadata', metadata
  ) INTO v_result;

  IF v_result IS NULL THEN
    RAISE EXCEPTION 'Document not found: %', p_doc_id;
  END IF;

  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION archive_project_document(p_doc_id uuid, p_archival_reason text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.archive_project_document(p_doc_id uuid, p_archival_reason text) IS 'Archives a project document by setting status to archived and updating metadata with archival reason and timestamp';


--
-- Name: archive_stale_documents(integer, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.archive_stale_documents(p_days_threshold integer DEFAULT 7, p_exclude_doc_types text[] DEFAULT ARRAY['system_directive'::text, 'agent_knowledge'::text]) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_archived_count INTEGER := 0;
  v_archived_ids UUID[];
  v_doc RECORD;
BEGIN
  -- Find and archive stale documents
  FOR v_doc IN 
    SELECT id, title, doc_type
    FROM project_documents
    WHERE COALESCE(updated_at, created_at) < NOW() - (p_days_threshold || ' days')::INTERVAL
      AND status != 'archived'
      AND (metadata->>'doc_category')::text != 'archived'
      AND NOT (doc_type = ANY(p_exclude_doc_types))
      -- Preserve auto-generated docs that are still relevant
      AND NOT (created_by = 'system' AND doc_type IN ('backend_structure', 'architecture'))
  LOOP
    PERFORM archive_project_document(
      v_doc.id, 
      'Auto-archived: No updates for ' || p_days_threshold || ' days'
    );
    v_archived_ids := array_append(v_archived_ids, v_doc.id);
    v_archived_count := v_archived_count + 1;
  END LOOP;

  RETURN jsonb_build_object(
    'archived_count', v_archived_count,
    'archived_ids', v_archived_ids,
    'threshold_days', p_days_threshold
  );
END;
$$;


--
-- Name: FUNCTION archive_stale_documents(p_days_threshold integer, p_exclude_doc_types text[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.archive_stale_documents(p_days_threshold integer, p_exclude_doc_types text[]) IS 'Bulk archives documents older than threshold (default 7 days), excluding system docs and auto-generated architecture docs';


--
-- Name: archive_wo_events(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.archive_wo_events(p_days_old integer DEFAULT 30) RETURNS TABLE(archived_count bigint, remaining_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_cutoff TIMESTAMPTZ;
  v_archived BIGINT;
  v_remaining BIGINT;
BEGIN
  -- Fix 1 & 4: Input validation - reject negative and extreme values
  IF p_days_old IS NULL OR p_days_old < 0 THEN
    RAISE EXCEPTION 'days_old must be a positive integer' USING ERRCODE = 'P0002';
  END IF;
  
  IF p_days_old > 36500 THEN
    RAISE EXCEPTION 'days_old must be <= 100 years (36500 days)' USING ERRCODE = 'P0002';
  END IF;
  
  -- Fix 5: Add explicit locking to prevent race conditions
  LOCK TABLE wo_events IN SHARE ROW EXCLUSIVE MODE;
  
  -- Fix 3: Use make_interval instead of string concatenation
  v_cutoff := now() - make_interval(days => p_days_old);
  
  WITH moved AS (
    DELETE FROM wo_events
    WHERE created_at < v_cutoff
    AND work_order_id IN (
      SELECT id FROM work_orders WHERE status IN ('done', 'cancelled', 'failed')
    )
    RETURNING *
  )
  INSERT INTO wo_events_archive
  SELECT m.*, now() AS archived_at
  FROM moved m;
  
  GET DIAGNOSTICS v_archived = ROW_COUNT;
  
  SELECT COUNT(*) INTO v_remaining FROM wo_events;
  
  RETURN QUERY SELECT v_archived, v_remaining;
END;
$$;


--
-- Name: assemble_evidence_bundle(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.assemble_evidence_bundle(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_bundle JSONB;
    v_wo RECORD;
    v_execution JSONB;
    v_qa JSONB;
    v_verification JSONB;
    v_enforcer JSONB;
    v_changes JSONB;
    v_cost JSONB;
    v_lessons JSONB;
BEGIN
    -- Get work order base info
    SELECT 
        id, slug, name, objective, priority, complexity, status,
        created_at, started_at, completed_at,
        EXTRACT(EPOCH FROM (completed_at - started_at)) as duration_seconds,
        assigned_to, tags, qa_checklist, verification_status,
        enforcer_verified, enforcer_verified_at, enforcer_run_id
    INTO v_wo
    FROM work_orders
    WHERE id = p_work_order_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Work order % not found', p_work_order_id;
    END IF;
    
    -- Build execution summary
    SELECT jsonb_build_object(
        'total_iterations', COALESCE(MAX(iteration), 0),
        'execution_log_entries', COUNT(*),
        'execution_summary', COALESCE(jsonb_agg(
            jsonb_build_object(
                'phase', phase,
                'agent_name', agent_name,
                'timestamp', created_at,
                'detail', detail
            ) ORDER BY created_at
        ), '[]'::jsonb),
        'tool_calls', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'tool', detail->>'tool',
                    'timestamp', created_at,
                    'success', COALESCE((detail->>'success')::boolean, true)
                )
            )
            FROM work_order_execution_log
            WHERE work_order_id = p_work_order_id
              AND detail ? 'tool'
            ), '[]'::jsonb
        )
    )
    INTO v_execution
    FROM work_order_execution_log
    WHERE work_order_id = p_work_order_id;
    
    -- Build QA summary
    SELECT jsonb_build_object(
        'checklist', COALESCE(v_wo.qa_checklist, '[]'::jsonb),
        'findings', COALESCE(jsonb_agg(
            jsonb_build_object(
                'id', qf.id,
                'finding_type', qf.finding_type,
                'category', qf.category,
                'description', qf.description,
                'evidence', qf.evidence,
                'resolved_at', qf.resolved_at
            )
        ), '[]'::jsonb),
        'passed', COALESCE(
            (SELECT COUNT(*) = 0 
             FROM qa_findings 
             WHERE work_order_id = p_work_order_id 
               AND resolved_at IS NULL
               AND finding_type = 'failure'
            ), true
        ),
        'last_run_at', (SELECT MAX(created_at) FROM qa_findings WHERE work_order_id = p_work_order_id)
    )
    INTO v_qa
    FROM qa_findings qf
    WHERE qf.work_order_id = p_work_order_id;
    
    -- Build verification summary (from audit_log)
    SELECT jsonb_build_object(
        'status', v_wo.verification_status,
        'entries', COALESCE(jsonb_agg(
            jsonb_build_object(
                'verification_type', payload->>'verification_type',
                'passed', (payload->>'passed')::boolean,
                'evidence', payload->'evidence',
                'verified_by', actor_id,
                'verified_at', created_at
            )
        ), '[]'::jsonb)
    )
    INTO v_verification
    FROM audit_log
    WHERE work_order_id = p_work_order_id
      AND action = 'record_verification'
      AND event_type = 'verification';
    
    -- Build enforcer summary
    SELECT jsonb_build_object(
        'verified', v_wo.enforcer_verified,
        'verified_at', v_wo.enforcer_verified_at,
        'run_id', v_wo.enforcer_run_id,
        'findings', COALESCE(jsonb_agg(
            jsonb_build_object(
                'id', ef.id,
                'finding_type', ef.finding_type,
                'severity', ef.severity,
                'status', ef.status,
                'description', ef.description,
                'evidence', ef.evidence
            )
        ), '[]'::jsonb)
    )
    INTO v_enforcer
    FROM enforcer_findings ef
    WHERE ef.work_order_id = v_wo.slug;
    
    -- Build changes summary
    SELECT jsonb_build_object(
        'schema_changes', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'id', sc.id,
                    'change_type', sc.change_type,
                    'object_name', sc.object_name,
                    'object_type', sc.object_type,
                    'created_at', sc.created_at
                )
            )
            FROM schema_changes sc
            WHERE sc.work_order_id = p_work_order_id
            ), '[]'::jsonb
        ),
        'state_mutations', COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'id', sm.id,
                    'mutation_type', sm.mutation_type,
                    'target_table', sm.target_table,
                    'created_at', sm.created_at
                )
            )
            FROM state_mutations sm
            WHERE sm.work_order_id = p_work_order_id
            ), '[]'::jsonb
        )
    )
    INTO v_changes;
    
    -- Build cost summary (from conversation_threads if linked)
    SELECT jsonb_build_object(
        'total_tokens', COALESCE(ct.total_tokens, 0),
        'total_cost_usd', COALESCE(ct.total_cost_usd, 0),
        'thread_id', ct.id
    )
    INTO v_cost
    FROM conversation_threads ct
    WHERE ct.metadata->>'work_order_id' = p_work_order_id::text
    LIMIT 1;
    
    -- If no conversation thread, set defaults
    IF v_cost IS NULL THEN
        v_cost := jsonb_build_object(
            'total_tokens', 0,
            'total_cost_usd', 0,
            'thread_id', null
        );
    END IF;
    
    -- Build lessons summary
    SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
            'id', l.id,
            'pattern', l.pattern,
            'rule', l.rule,
            'severity', l.severity,
            'category', l.category,
            'occurred_at', l.occurred_at
        )
    ), '[]'::jsonb)
    INTO v_lessons
    FROM lessons l
    WHERE l.work_order_id = p_work_order_id;
    
    -- Assemble complete bundle
    v_bundle := jsonb_build_object(
        'work_order', jsonb_build_object(
            'id', v_wo.id,
            'slug', v_wo.slug,
            'name', v_wo.name,
            'objective', v_wo.objective,
            'priority', v_wo.priority,
            'complexity', v_wo.complexity,
            'status', v_wo.status,
            'created_at', v_wo.created_at,
            'started_at', v_wo.started_at,
            'completed_at', v_wo.completed_at,
            'duration_seconds', v_wo.duration_seconds,
            'assigned_to', v_wo.assigned_to,
            'tags', v_wo.tags
        ),
        'execution', v_execution,
        'qa', v_qa,
        'verification', v_verification,
        'enforcer', v_enforcer,
        'changes', v_changes,
        'cost', v_cost,
        'lessons', v_lessons
    );
    
    RETURN v_bundle;
END;
$$;


--
-- Name: audit_config_changes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.audit_config_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  if TG_OP = 'INSERT' then
    insert into public.orchestrator_config_audit (config_id, user_id, new_value, change_type, changed_by)
    values (new.id, new.user_id, new.routing_overrides, 'create', new.updated_by);
  elsif TG_OP = 'UPDATE' then
    insert into public.orchestrator_config_audit (config_id, user_id, previous_value, new_value, change_type, changed_by)
    values (new.id, new.user_id, old.routing_overrides, new.routing_overrides, 'update', new.updated_by);
    new.version = old.version + 1;
  elsif TG_OP = 'DELETE' then
    insert into public.orchestrator_config_audit (config_id, user_id, previous_value, change_type, changed_by)
    values (old.id, old.user_id, old.routing_overrides, 'delete', current_user);
  end if;
  return coalesce(new, old);
end;
$$;


--
-- Name: audit_log_immutable(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.audit_log_immutable() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  RAISE EXCEPTION 'audit_log is immutable - UPDATE and DELETE are not allowed';
END;
$$;


--
-- Name: audit_logger(text, text, text, text, text, uuid, jsonb, jsonb, jsonb, uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.audit_logger(p_event_type text, p_actor_type text, p_actor_id text, p_action text, p_target_type text DEFAULT NULL::text, p_target_id uuid DEFAULT NULL::uuid, p_payload jsonb DEFAULT '{}'::jsonb, p_previous_state jsonb DEFAULT NULL::jsonb, p_new_state jsonb DEFAULT NULL::jsonb, p_work_order_id uuid DEFAULT NULL::uuid, p_session_id text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_id UUID;
BEGIN
  INSERT INTO audit_log (
    event_type, actor_type, actor_id, action,
    target_type, target_id, payload,
    previous_state, new_state,
    work_order_id, session_id
  ) VALUES (
    p_event_type, p_actor_type, p_actor_id, p_action,
    p_target_type, p_target_id, p_payload,
    p_previous_state, p_new_state,
    p_work_order_id, p_session_id
  ) RETURNING id INTO v_id;
  
  RETURN v_id;
END;
$$;


--
-- Name: audit_review(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.audit_review(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo RECORD;
  v_checks JSONB := '[]'::JSONB;
  v_check JSONB;
  v_verdict TEXT := 'PASS';
  v_risk_level TEXT := 'low';
  v_execution_log_count INTEGER;
  v_mcp_tool_count INTEGER;
  v_summary_length INTEGER;
  v_output_length INTEGER;
  v_result JSONB;
BEGIN
  -- Fetch work order
  SELECT * INTO v_wo
  FROM work_orders
  WHERE id = p_work_order_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'verdict', 'FAIL',
      'risk_level', 'high',
      'checks', '[]'::JSONB,
      'error', 'Work order not found'
    );
  END IF;

  -- Check 1: execution_log_exists
  SELECT COUNT(*) INTO v_execution_log_count
  FROM work_order_execution_log
  WHERE work_order_id = p_work_order_id;

  v_check := jsonb_build_object(
    'name', 'execution_log_exists',
    'passed', v_execution_log_count > 0,
    'evidence', jsonb_build_object(
      'log_entry_count', v_execution_log_count
    )
  );
  v_checks := v_checks || v_check;

  IF v_execution_log_count = 0 THEN
    v_verdict := 'FAIL';
    v_risk_level := 'high';
  END IF;

  -- Check 2: tool_usage_matches_type (for supabase-type WOs)
  IF v_wo.tags IS NOT NULL AND 'supabase' = ANY(v_wo.tags) THEN
    SELECT COUNT(*) INTO v_mcp_tool_count
    FROM work_order_execution_log
    WHERE work_order_id = p_work_order_id
      AND detail::text LIKE '%mcp__supabase__%';

    v_check := jsonb_build_object(
      'name', 'tool_usage_matches_type',
      'passed', v_mcp_tool_count > 0,
      'evidence', jsonb_build_object(
        'mcp_tool_count', v_mcp_tool_count,
        'wo_type', 'supabase'
      )
    );
    v_checks := v_checks || v_check;

    IF v_mcp_tool_count = 0 THEN
      v_verdict := 'FAIL';
      v_risk_level := 'medium';
    END IF;
  ELSE
    -- For portal-type WOs, check for file edits in detail
    v_check := jsonb_build_object(
      'name', 'tool_usage_matches_type',
      'passed', true,
      'evidence', jsonb_build_object(
        'wo_type', 'non-supabase',
        'note', 'File edit verification requires detailed analysis'
      )
    );
    v_checks := v_checks || v_check;
  END IF;

  -- Check 3: summary_populated
  v_summary_length := COALESCE(LENGTH(v_wo.summary), 0);

  v_check := jsonb_build_object(
    'name', 'summary_populated',
    'passed', v_summary_length > 0,
    'evidence', jsonb_build_object(
      'summary_length', v_summary_length
    )
  );
  v_checks := v_checks || v_check;

  IF v_summary_length = 0 THEN
    v_verdict := 'ESCALATE';
    v_risk_level := 'medium';
  END IF;

  -- Check 4: client_info_has_metadata
  v_check := jsonb_build_object(
    'name', 'client_info_has_metadata',
    'passed', v_wo.client_info IS NOT NULL AND 
              (v_wo.client_info ? 'tool_metadata' OR v_wo.client_info ? 'summary' OR v_wo.client_info ? 'output'),
    'evidence', jsonb_build_object(
      'has_client_info', v_wo.client_info IS NOT NULL,
      'has_tool_metadata', v_wo.client_info ? 'tool_metadata',
      'has_summary', v_wo.client_info ? 'summary',
      'has_output', v_wo.client_info ? 'output'
    )
  );
  v_checks := v_checks || v_check;

  IF NOT (v_check->'passed')::BOOLEAN THEN
    v_verdict := 'ESCALATE';
    v_risk_level := 'medium';
  END IF;

  -- Check 5: output_length_reasonable
  v_output_length := 0;
  IF v_wo.client_info IS NOT NULL AND v_wo.client_info ? 'output' THEN
    v_output_length := LENGTH(v_wo.client_info->>'output');
  END IF;

  v_check := jsonb_build_object(
    'name', 'output_length_reasonable',
    'passed', v_output_length > 100,
    'evidence', jsonb_build_object(
      'output_length', v_output_length,
      'threshold', 100
    )
  );
  v_checks := v_checks || v_check;

  IF v_output_length <= 100 THEN
    IF v_verdict = 'PASS' THEN
      v_verdict := 'ESCALATE';
    END IF;
    IF v_risk_level = 'low' THEN
      v_risk_level := 'medium';
    END IF;
  END IF;

  -- Build final result
  v_result := jsonb_build_object(
    'verdict', v_verdict,
    'risk_level', v_risk_level,
    'checks', v_checks,
    'work_order_id', p_work_order_id,
    'work_order_slug', v_wo.slug,
    'reviewed_at', NOW()
  );

  -- Persist review report in audit_log
  INSERT INTO audit_log (
    event_type,
    actor_type,
    actor_id,
    target_type,
    target_id,
    action,
    payload,
    work_order_id
  ) VALUES (
    'audit_review',
    'agent',
    'audit',
    'work_order',
    p_work_order_id,
    'automated_review',
    v_result,
    p_work_order_id
  );

  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION audit_review(p_work_order_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.audit_review(p_work_order_id uuid) IS 'Automated audit review for work orders in review status. Verifies execution logs, tool usage, summary population, client_info metadata, and output length.';


--
-- Name: auto_cancel_deadlocked_chains(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_cancel_deadlocked_chains() RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_cancelled uuid[];
  v_cycle record;
  v_wo_id uuid;
  v_reason text;
BEGIN
  v_cancelled := ARRAY[]::uuid[];
  
  -- Cancel WOs in circular dependencies
  FOR v_cycle IN
    SELECT cycle_wos, cycle_slugs
    FROM detect_circular_dependencies()
  LOOP
    v_reason := format('Circular dependency detected: %s', array_to_string(v_cycle.cycle_slugs, ' -> '));
    
    FOREACH v_wo_id IN ARRAY v_cycle.cycle_wos
    LOOP
      UPDATE work_orders
      SET status = 'cancelled',
          cancellation_reason = v_reason,
          completed_at = now(),
          updated_at = now()
      WHERE id = v_wo_id
        AND status NOT IN ('done', 'cancelled', 'failed');
      
      IF FOUND THEN
        v_cancelled := v_cancelled || v_wo_id;
        
        INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
        VALUES ('deadlock_auto_cancel', 'system', 'auto_cancel_deadlocked',
                'work_order', v_wo_id,
                'Cancelled due to circular dependency',
                jsonb_build_object('reason', v_reason, 'cycle', v_cycle.cycle_slugs));
      END IF;
    END LOOP;
  END LOOP;
  
  -- Cancel WOs blocked by cancelled dependencies (permanent blocks)
  FOR v_wo_id IN
    SELECT id
    FROM work_orders
    WHERE status IN ('ready', 'blocked')
      AND depends_on IS NOT NULL
      AND EXISTS (
        SELECT 1
        FROM unnest(depends_on) dep_id
        WHERE (SELECT status FROM work_orders WHERE id = dep_id) = 'cancelled'
      )
  LOOP
    v_reason := 'Blocked by cancelled dependency';
    
    UPDATE work_orders
    SET status = 'cancelled',
        cancellation_reason = v_reason,
        completed_at = now(),
        updated_at = now()
    WHERE id = v_wo_id;
    
    IF FOUND THEN
      v_cancelled := v_cancelled || v_wo_id;
      
      INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
      VALUES ('permanent_block_cancel', 'system', 'auto_cancel_deadlocked',
              'work_order', v_wo_id,
              'Cancelled due to cancelled dependency',
              jsonb_build_object('reason', v_reason));
    END IF;
  END LOOP;
  
  RETURN jsonb_build_object(
    'action', 'auto_cancel_deadlocked_chains',
    'cancelled_wos', v_cancelled,
    'cancelled_count', array_length(v_cancelled, 1),
    'executed_at', now()
  );
END;
$$;


--
-- Name: FUNCTION auto_cancel_deadlocked_chains(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.auto_cancel_deadlocked_chains() IS 'Auto-cancel circular dependencies and permanent blocks';


--
-- Name: auto_close_review_on_qa_pass(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_close_review_on_qa_pass() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF current_setting('app.wo_transition_active', true) = 'true' THEN
    RETURN NEW;
  END IF;
  
  DECLARE
    v_item jsonb;
    v_all_pass boolean := true;
    v_has_items boolean := false;
    v_blocking_findings_count int := 0;
  BEGIN
    IF NEW.status != 'review' THEN
      RETURN NEW;
    END IF;
    
    IF OLD.qa_checklist IS NOT DISTINCT FROM NEW.qa_checklist
       AND OLD.qa_review_verified_at IS NOT DISTINCT FROM NEW.qa_review_verified_at THEN
      RETURN NEW;
    END IF;
    
    IF NEW.qa_checklist IS NULL OR jsonb_array_length(NEW.qa_checklist) = 0 THEN
      RETURN NEW;
    END IF;
    
    IF NEW.qa_review_verified_at IS NULL THEN
      INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
      VALUES (NEW.id, 'qa_validation', 'qa-gate',
        jsonb_build_object(
          'event_type', 'auto_close_deferred',
          'content', format('Auto-close deferred for %s: awaiting qa-review verification', NEW.slug)
        )
      );
      RETURN NEW;
    END IF;
    
    FOR v_item IN SELECT * FROM jsonb_array_elements(NEW.qa_checklist)
    LOOP
      v_has_items := true;
      IF v_item->>'status' NOT IN ('pass', 'na') THEN
        v_all_pass := false;
        EXIT;
      END IF;
    END LOOP;
    
    IF v_has_items AND v_all_pass THEN
      SELECT count(*) INTO v_blocking_findings_count
      FROM qa_findings
      WHERE work_order_id = NEW.id
        AND finding_type = 'fail'
        AND resolved_at IS NULL;
      
      IF v_blocking_findings_count > 0 THEN
        INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
        VALUES (NEW.id, 'qa_validation', 'qa-gate',
          jsonb_build_object(
            'event_type', 'auto_close_blocked',
            'content', format('Auto-close blocked for %s: %s unresolved fail finding(s)', NEW.slug, v_blocking_findings_count),
            'blocking_findings_count', v_blocking_findings_count
          )
        );
        RETURN NEW;
      END IF;
      
      -- Internal bypass for auto-close (runs as DB system, not agent)
      NEW.status := 'done';
      NEW.completed_at := NOW();
      IF NEW.summary IS NULL OR NEW.summary = '' THEN
        NEW.summary := 'Auto-closed: all QA checklist items passed';
      END IF;
      
      INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
      VALUES (NEW.id, 'execution_complete', 'qa-gate',
        jsonb_build_object(
          'event_type', 'auto_close_qa_pass',
          'content', format('Auto-closed %s: all %s checklist items passed, no fail findings', NEW.slug, jsonb_array_length(NEW.qa_checklist)),
          'checklist_items', jsonb_array_length(NEW.qa_checklist)
        )
      );
    END IF;
    
    RETURN NEW;
  END;
END;
$$;


--
-- Name: auto_create_gap_wo(text, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_create_gap_wo(p_category text, p_pattern text, p_rule text, p_severity text DEFAULT 'warning'::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo_id UUID;
  v_slug TEXT;
  v_priority work_order_priority;
BEGIN
  -- Map severity to priority enum
  v_priority := CASE p_severity
    WHEN 'critical' THEN 'p1_high'::work_order_priority
    WHEN 'error'    THEN 'p1_high'::work_order_priority
    WHEN 'warning'  THEN 'p2_medium'::work_order_priority
    ELSE 'p3_low'::work_order_priority
  END;

  -- Generate slug
  v_slug := 'WO-GAP-' || upper(substring(p_category from 1 for 4)) || '-' || to_char(now(), 'MMDD');

  -- Bypass enforcement for auto-creation
  PERFORM set_config('app.wo_trigger_context', 'true', true);
  PERFORM set_config('app.wo_executor_bypass', 'true', true);

  -- Insert draft work order with tags for idempotency detection
  INSERT INTO work_orders (
    name, objective, priority, status, source,
    created_by, project_brief_id, slug, tags
  ) VALUES (
    'Auto-detected gap: ' || p_category,
    'Recurring pattern detected by lesson-promoter: ' || coalesce(p_pattern, 'unknown') ||
    '. Suggested rule: ' || coalesce(p_rule, 'none'),
    v_priority,
    'draft',
    'intake_api',
    'engineering'::agent_type,
    '7558abf4-78d4-4ca2-a4dd-457f5b061e25'::uuid,
    v_slug,
    ARRAY['self-update', 'cat:' || p_category]
  )
  RETURNING id INTO v_wo_id;

  -- Reset bypass
  PERFORM set_config('app.wo_executor_bypass', 'false', true);
  PERFORM set_config('app.wo_trigger_context', '', true);

  -- Audit log
  INSERT INTO audit_log (action, event_type, actor_type, actor_id, target_type, target_id, payload)
  VALUES (
    'auto_create_gap_wo',
    'self_update',
    'system',
    'lesson-promoter-v3',
    'work_order',
    v_wo_id,
    jsonb_build_object(
      'category', p_category,
      'severity', p_severity,
      'priority', v_priority::text,
      'pattern', p_pattern,
      'rule', p_rule
    )
  );

  RETURN v_wo_id;
END;
$$;


--
-- Name: auto_create_lesson(text, text, jsonb, uuid, text, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_create_lesson(p_failure_source text, p_error_message text, p_context jsonb DEFAULT '{}'::jsonb, p_work_order_id uuid DEFAULT NULL::uuid, p_trace_id text DEFAULT NULL::text, p_agent_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_lesson_id UUID;
  v_pattern TEXT;
  v_rule TEXT;
  v_severity TEXT;
  v_category TEXT;
  v_existing_id UUID;
BEGIN
  -- Build pattern from source + message
  v_pattern := p_failure_source || ': ' || LEFT(p_error_message, 300);
  
  -- Derive category from source
  v_category := CASE
    WHEN p_failure_source = 'transition' THEN 'state_machine'
    WHEN p_failure_source = 'action_check' THEN 'authorization'
    WHEN p_failure_source = 'gate' THEN 'approval_flow'
    WHEN p_failure_source = 'executor' THEN 'execution'
    ELSE 'general'
  END;

  -- DEDUPE GUARD: Check if this exact pattern already exists for this category
  SELECT id INTO v_existing_id
  FROM lessons
  WHERE category = v_category
    AND pattern = v_pattern
  ORDER BY created_at DESC
  LIMIT 1;

  -- If duplicate exists, return existing ID instead of creating new lesson
  IF v_existing_id IS NOT NULL THEN
    RAISE NOTICE 'Duplicate lesson prevented: category=%, pattern=%', v_category, LEFT(v_pattern, 100);
    RETURN v_existing_id;
  END IF;

  -- Derive severity
  v_severity := CASE
    WHEN p_failure_source = 'transition' AND p_error_message ILIKE '%terminal%' THEN 'error'
    WHEN p_failure_source = 'action_check' THEN 'error'
    WHEN p_failure_source = 'gate' THEN 'warning'
    WHEN p_failure_source = 'executor' AND p_error_message ILIKE '%exception%' THEN 'critical'
    WHEN p_failure_source = 'executor' THEN 'error'
    ELSE 'warning'
  END;

  -- Derive rule from failure context
  v_rule := CASE
    WHEN p_failure_source = 'transition' THEN
      'Invalid state transition attempted. Check the transition map in validate_wo_transition before changing WO status. '
      || 'Context: ' || LEFT(p_error_message, 200)
    WHEN p_failure_source = 'action_check' THEN
      'Unauthorized action attempted. Verify agent permissions in allowed_actions table. '
      || 'Context: ' || LEFT(p_error_message, 200)
    WHEN p_failure_source = 'gate' THEN
      'Decision gate blocked execution. Obtain required approval before proceeding. '
      || 'Context: ' || LEFT(p_error_message, 200)
    WHEN p_failure_source = 'executor' THEN
      'Work order execution failed. Review error, fix root cause, and retry. '
      || 'Context: ' || LEFT(p_error_message, 200)
    ELSE
      'Failure occurred: ' || LEFT(p_error_message, 200)
  END;

  INSERT INTO lessons (
    pattern, context, rule, severity, category,
    work_order_id, trace_id, reported_by
  ) VALUES (
    v_pattern,
    jsonb_build_object(
      'source', p_failure_source,
      'agent_id', p_agent_id,
      'details', p_context
    )::text,
    v_rule,
    v_severity,
    v_category,
    p_work_order_id,
    p_trace_id,
    COALESCE(p_failure_source, 'system')
  ) RETURNING id INTO v_lesson_id;

  -- Log to audit trail
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
  VALUES (
    'lesson_auto_created',
    'system',
    p_failure_source,
    'lesson',
    v_lesson_id,
    'auto_create',
    jsonb_build_object(
      'severity', v_severity,
      'category', v_category,
      'work_order_id', p_work_order_id,
      'error_message', LEFT(p_error_message, 500)
    )
  );
  
  RETURN v_lesson_id;
EXCEPTION WHEN OTHERS THEN
  RAISE WARNING 'auto_create_lesson failed: %', SQLERRM;
  RETURN NULL;
END;
$$;


--
-- Name: auto_fail_zombie_work_orders(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_fail_zombie_work_orders(p_timeout_minutes integer DEFAULT 30) RETURNS TABLE(work_order_id uuid, slug text, old_status text, new_status text, failed_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_zombie RECORD;
    v_wo_id uuid;
    v_old_status text;
    v_slug text;
    v_result jsonb;
    v_effective_timeout integer;
BEGIN
    -- Enforce minimum timeout of 1 minute to prevent mass-failure attacks
    v_effective_timeout := GREATEST(p_timeout_minutes, 1);
    
    FOR v_zombie IN SELECT * FROM detect_zombie_work_orders(v_effective_timeout) LOOP
        v_wo_id := v_zombie.work_order_id;
        v_old_status := v_zombie.status;
        v_slug := v_zombie.slug;
        
        -- Use wo_transition to safely transition to failed
        -- wo_transition enforces state machine rules and returns result
        v_result := wo_transition(v_wo_id, 'fail', jsonb_build_object('reason', 'zombie_timeout', 'timeout_minutes', v_effective_timeout), 'system', 0);
        
        -- Check if transition actually succeeded
        IF v_result->>'success' = 'true' THEN
            work_order_id := v_wo_id;
            slug := v_slug;
            old_status := v_old_status;
            new_status := 'failed';
            failed_at := now();
            RETURN NEXT;
        ELSE
            -- Log failure but don't return - transition was blocked
            RAISE NOTICE 'Failed to transition WO % to failed: %', v_slug, v_result;
        END IF;
    END LOOP;
    
    RETURN;
END;
$$;


--
-- Name: auto_generate_backend_docs(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_generate_backend_docs() RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_doc_id uuid;
  v_content text;
  v_table_info text;
  v_fk_info text;
  v_rls_info text;
  v_trigger_info text;
  v_function_info text;
  v_edge_function_info text;
  v_project_id uuid;
BEGIN
  -- Get project ID for ENDGAME-001
  SELECT id INTO v_project_id 
  FROM project_briefs 
  WHERE code = 'ENDGAME-001' 
  LIMIT 1;

  -- Build table inventory with columns, types, and constraints
  WITH table_details AS (
    SELECT 
      t.table_name,
      (SELECT string_agg(
         format('- `%s`: %s%s', 
           c.column_name, 
           c.udt_name, 
           CASE WHEN c.is_nullable = 'NO' THEN ' (NOT NULL)' ELSE '' END
         ), E'\n' ORDER BY c.ordinal_position)
       FROM information_schema.columns c 
       WHERE c.table_schema = 'public' AND c.table_name = t.table_name
      ) as columns,
      (SELECT COALESCE(string_agg(format('- %s', tc.constraint_name), E'\n'), 'None')
       FROM information_schema.table_constraints tc
       WHERE tc.table_schema = 'public' AND tc.table_name = t.table_name
      ) as constraints
    FROM information_schema.tables t
    WHERE t.table_schema = 'public' AND t.table_type = 'BASE TABLE'
  )
  SELECT string_agg(
    format(E'### %s\n**Columns:**\n%s\n**Constraints:**\n%s\n',
      table_name, columns, constraints
    ), E'\n\n' ORDER BY table_name)
  INTO v_table_info
  FROM table_details;

  -- Build foreign key relationships
  SELECT string_agg(
    format('- `%s.%s` → `%s.%s` (constraint: `%s`)',
      tc.table_name,
      kcu.column_name,
      ccu.table_name,
      ccu.column_name,
      tc.constraint_name
    ), E'\n' ORDER BY tc.table_name, kcu.column_name)
  INTO v_fk_info
  FROM information_schema.table_constraints tc
  JOIN information_schema.key_column_usage kcu 
    ON tc.constraint_name = kcu.constraint_name
    AND tc.table_schema = kcu.table_schema
  JOIN information_schema.constraint_column_usage ccu
    ON ccu.constraint_name = tc.constraint_name
    AND ccu.table_schema = tc.table_schema
  WHERE tc.constraint_type = 'FOREIGN KEY'
    AND tc.table_schema = 'public';

  -- Build RLS policy summary
  SELECT string_agg(
    format('- Table: `%s`, Policy: `%s` (%s)', 
      tablename, policyname, cmd), E'\n' ORDER BY tablename, policyname)
  INTO v_rls_info
  FROM pg_policies
  WHERE schemaname = 'public';

  -- Build trigger inventory
  WITH trigger_events AS (
    SELECT 
      trigger_name,
      event_object_table,
      action_timing,
      string_agg(event_manipulation, ', ' ORDER BY event_manipulation) as events
    FROM information_schema.triggers
    WHERE trigger_schema = 'public'
    GROUP BY trigger_name, event_object_table, action_timing
  )
  SELECT string_agg(
    format('- `%s` on `%s` (%s %s)', 
      trigger_name, event_object_table, action_timing, events), 
    E'\n' ORDER BY event_object_table, trigger_name)
  INTO v_trigger_info
  FROM trigger_events;

  -- Build RPC function inventory
  SELECT string_agg(
    format('- `%s(%s)` → %s', 
      p.proname,
      pg_get_function_arguments(p.oid),
      pg_get_function_result(p.oid)), E'\n' ORDER BY p.proname)
  INTO v_function_info
  FROM pg_proc p
  JOIN pg_namespace n ON p.pronamespace = n.oid
  WHERE n.nspname = 'public' 
    AND p.prokind = 'f';

  -- Build edge function registry from system_manifest
  SELECT string_agg(
    format('- `%s`: %s', name, description), E'\n' ORDER BY name)
  INTO v_edge_function_info
  FROM system_manifest
  WHERE component_type = 'edge_function';

  -- Construct full markdown document
  v_content := format(E'# Backend Structure Documentation\n\n**Auto-generated:** %s\n\n## Database Schema\n\n%s\n\n## Foreign Key Relationships\n\n%s\n\n## RLS Policies\n\n%s\n\n## Triggers\n\n%s\n\n## RPC Functions\n\n%s\n\n## Edge Functions\n\n%s',
    now()::text,
    COALESCE(v_table_info, 'No tables found'),
    COALESCE(v_fk_info, 'No foreign key relationships found'),
    COALESCE(v_rls_info, 'No RLS policies found'),
    COALESCE(v_trigger_info, 'No triggers found'),
    COALESCE(v_function_info, 'No RPC functions found'),
    COALESCE(v_edge_function_info, 'No edge functions registered')
  );

  -- Insert or update the backend structure document
  INSERT INTO project_documents (
    project_id,
    doc_type,
    title,
    content,
    version,
    status,
    created_by,
    updated_by
  )
  VALUES (
    v_project_id,
    'backend_structure',
    'Backend Structure',
    v_content,
    1,
    'draft',
    'system',
    'system'
  )
  ON CONFLICT (project_id, doc_type) 
  DO UPDATE SET
    content = EXCLUDED.content,
    version = project_documents.version + 1,
    updated_by = 'system',
    updated_at = now()
  RETURNING id INTO v_doc_id;

  RETURN v_doc_id;
END;
$$;


--
-- Name: FUNCTION auto_generate_backend_docs(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.auto_generate_backend_docs() IS 'Auto-generates backend structure documentation from live database schema. Includes tables, columns, constraints, FK relationships, RLS policies, triggers, RPC functions, and edge functions.';


--
-- Name: auto_handle_wo_failure_cascade(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_handle_wo_failure_cascade() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Suppression guard: skip if wo_transition is actively processing
  IF current_setting('app.wo_transition_active', true) = 'true' THEN
    RETURN NEW;
  END IF;
  
  DECLARE
    v_chain_result jsonb;
    v_circular_deps record;
    v_lifecycle_verdict JSONB;
  BEGIN
    IF NEW.status = 'failed' AND OLD.status != 'failed' THEN
      v_lifecycle_verdict := evaluate_wo_lifecycle(NEW.id, 'status_change', jsonb_build_object('transition', 'to_failed'));
      
      INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
      VALUES (NEW.id, 'stream', 'system', 
        jsonb_build_object(
          'event_type', 'lifecycle_gate_check',
          'action', 'status_change',
          'transition', 'to_failed',
          'verdict', v_lifecycle_verdict
        )
      );

      IF v_lifecycle_verdict->>'actor_type' = 'human' THEN
        INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
        VALUES (NEW.id, 'stream', 'system',
          jsonb_build_object(
            'event_type', 'cascade_skipped',
            'reason', 'Human-initiated failure - no automated remediation',
            'actor_type', 'human'
          )
        );
        RETURN NEW; 
      END IF;

      IF v_lifecycle_verdict->>'verdict' = 'escalate_master' THEN
        INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
        VALUES (NEW.id, 'stream', 'system',
          jsonb_build_object(
            'event_type', 'escalation_tagged',
            'reason', 'Remediation should route to master agent',
            'verdict', v_lifecycle_verdict
          )
        );
        UPDATE work_orders
        SET tags = array_append(tags, 'escalate-master')
        WHERE id = NEW.id AND NOT 'escalate-master' = ANY(tags);
      END IF;
      
      FOR v_circular_deps IN 
        SELECT * FROM detect_circular_dependencies(NEW.id)
      LOOP
        INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
        VALUES (
          'circular_dependency_detected',
          'system',
          'auto_handle_wo_failure_cascade',
          'work_order',
          NEW.id,
          'Circular dependency detected',
          jsonb_build_object(
            'cycle_wos', v_circular_deps.cycle_wos,
            'cycle_slugs', v_circular_deps.cycle_slugs,
            'severity', v_circular_deps.severity
          )
        );
        
        IF v_circular_deps.severity = 'critical' THEN
          UPDATE work_orders
          SET status = 'cancelled',
              cancellation_reason = 'Circular dependency deadlock detected',
              updated_at = now()
          WHERE id = ANY(v_circular_deps.cycle_wos)
            AND status NOT IN ('done', 'cancelled', 'failed');
        END IF;
      END LOOP;
      
      IF NOT EXISTS (SELECT 1 FROM detect_circular_dependencies(NEW.id)) 
         AND v_lifecycle_verdict->>'actor_type' != 'human' THEN
        v_chain_result := smart_restart_chain(NEW.id, true);
        
        INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
        VALUES (
          NEW.id,
          'execution_complete',
          'system',
          jsonb_build_object(
            'action', 'auto_failure_cascade',
            'result', v_chain_result
          )
        );
      END IF;
    END IF;
    
    RETURN NEW;
  END;
END;
$$;


--
-- Name: auto_populate_evidence_bundle(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_populate_evidence_bundle() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_execution_summary jsonb;
  v_qa_results jsonb;
  v_verification_log jsonb;
  v_enforcer_result jsonb;
  v_cost_metrics jsonb;
  v_tool_calls jsonb;
  v_code_changes jsonb;
  v_duration_seconds numeric;
BEGIN
  -- Only trigger on review→done transition
  IF OLD.status = 'review' AND NEW.status = 'done' THEN
    
    -- Build execution summary
    SELECT 
      jsonb_build_object(
        'duration_seconds', EXTRACT(EPOCH FROM (NEW.completed_at - NEW.started_at)),
        'started_at', NEW.started_at,
        'completed_at', NEW.completed_at,
        'agent_name', COALESCE(
          (SELECT agent_name FROM work_order_execution_log 
           WHERE work_order_id = NEW.id 
           ORDER BY created_at DESC LIMIT 1), 
          'unknown'
        ),
        'phases', (
          SELECT jsonb_agg(jsonb_build_object('phase', phase, 'count', count))
          FROM (
            SELECT phase, COUNT(*) as count
            FROM work_order_execution_log
            WHERE work_order_id = NEW.id
            GROUP BY phase
          ) phases
        ),
        'total_log_entries', (
          SELECT COUNT(*) FROM work_order_execution_log WHERE work_order_id = NEW.id
        )
      )
    INTO v_execution_summary;
    
    -- Build QA results (FIX: ORDER BY inside jsonb_agg, not outside)
    SELECT 
      jsonb_build_object(
        'checklist_complete', COALESCE(
          (SELECT is_qa_checklist_complete(NEW.id)), false
        ),
        'total_items', jsonb_array_length(COALESCE(NEW.qa_checklist, '[]'::jsonb)),
        'passed', (
          SELECT COUNT(*) FROM jsonb_array_elements(COALESCE(NEW.qa_checklist, '[]'::jsonb)) 
          WHERE value->>'status' = 'pass'
        ),
        'failed', (
          SELECT COUNT(*) FROM jsonb_array_elements(COALESCE(NEW.qa_checklist, '[]'::jsonb)) 
          WHERE value->>'status' = 'fail'
        ),
        'na', (
          SELECT COUNT(*) FROM jsonb_array_elements(COALESCE(NEW.qa_checklist, '[]'::jsonb)) 
          WHERE value->>'status' = 'na'
        ),
        'findings', COALESCE(
          (SELECT jsonb_agg(jsonb_build_object(
            'type', finding_type,
            'category', category,
            'description', description,
            'evidence', evidence,
            'created_at', created_at
          ) ORDER BY created_at)
          FROM qa_findings 
          WHERE work_order_id = NEW.id), '[]'::jsonb
        )
      )
    INTO v_qa_results;
    
    -- Build verification log
    SELECT COALESCE(
      jsonb_agg(jsonb_build_object(
        'timestamp', created_at,
        'verification_type', phase,
        'passed', (detail->>'success')::boolean,
        'evidence', detail
      ) ORDER BY created_at),
      '[]'::jsonb
    )
    INTO v_verification_log
    FROM work_order_execution_log
    WHERE work_order_id = NEW.id
      AND phase IN ('verification', 'testing', 'validation');
    
    -- Build enforcer result (FIX: ORDER BY inside jsonb_agg)
    SELECT 
      jsonb_build_object(
        'verified', COALESCE(NEW.enforcer_verified, false),
        'verified_at', NEW.enforcer_verified_at,
        'run_id', NEW.enforcer_run_id,
        'findings', COALESCE(
          (SELECT jsonb_agg(jsonb_build_object(
            'type', finding_type,
            'severity', severity,
            'status', status,
            'description', description,
            'evidence', evidence
          ) ORDER BY created_at)
          FROM enforcer_findings 
          WHERE work_order_id = NEW.slug), '[]'::jsonb
        )
      )
    INTO v_enforcer_result;
    
    -- Build cost metrics
    SELECT 
      jsonb_build_object(
        'total_tokens', 0,
        'total_cost_usd', 0,
        'model_usage', '[]'::jsonb
      )
    INTO v_cost_metrics;
    
    -- Build tool calls from execution log (FIX: ORDER BY inside jsonb_agg)
    SELECT COALESCE(
      jsonb_agg(jsonb_build_object(
        'timestamp', created_at,
        'tool_name', detail->>'tool_name',
        'phase', phase,
        'success', COALESCE((detail->>'success')::boolean, true),
        'result_summary', detail
      ) ORDER BY created_at),
      '[]'::jsonb
    )
    INTO v_tool_calls
    FROM work_order_execution_log
    WHERE work_order_id = NEW.id
      AND detail ? 'tool_name';
    
    -- Build code changes (FIX: ORDER BY inside jsonb_agg)
    SELECT 
      jsonb_build_object(
        'schema_changes', COALESCE(
          (SELECT jsonb_agg(jsonb_build_object(
            'type', change_type,
            'name', object_name,
            'object_type', object_type,
            'description', reason,
            'created_at', created_at
          ) ORDER BY created_at)
          FROM schema_changes 
          WHERE work_order_id = NEW.id), '[]'::jsonb
        ),
        'state_mutations', COALESCE(
          (SELECT jsonb_agg(jsonb_build_object(
            'type', mutation_type,
            'target_table', target_table,
            'created_at', created_at
          ) ORDER BY created_at)
          FROM state_mutations 
          WHERE work_order_id = NEW.id), '[]'::jsonb
        )
      )
    INTO v_code_changes;
    
    -- Insert or update the evidence bundle
    INSERT INTO evidence_bundles (
      work_order_id,
      generated_at,
      bundle_version,
      execution_summary,
      qa_results,
      verification_log,
      enforcer_result,
      cost_metrics,
      tool_calls,
      code_changes
    ) VALUES (
      NEW.id,
      now(),
      'v1',
      v_execution_summary,
      v_qa_results,
      v_verification_log,
      v_enforcer_result,
      v_cost_metrics,
      v_tool_calls,
      v_code_changes
    )
    ON CONFLICT (work_order_id) DO UPDATE SET
      generated_at = now(),
      execution_summary = v_execution_summary,
      qa_results = v_qa_results,
      verification_log = v_verification_log,
      enforcer_result = v_enforcer_result,
      cost_metrics = v_cost_metrics,
      tool_calls = v_tool_calls,
      code_changes = v_code_changes,
      updated_at = now();
      
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION auto_populate_evidence_bundle(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.auto_populate_evidence_bundle() IS 'Auto-assembles evidence bundle when WO transitions from review to done';


--
-- Name: auto_populate_qa_checklist(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_populate_qa_checklist() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF current_setting('app.wo_transition_active', true) = 'true' THEN
    RETURN NEW;
  END IF;
  
  DECLARE
    v_criteria_source TEXT;
  BEGIN
    IF NEW.status = 'review' 
       AND (OLD.status IS DISTINCT FROM 'review')
       AND (NEW.qa_checklist IS NULL OR NEW.qa_checklist = '[]'::jsonb) THEN
      
      v_criteria_source := COALESCE(
        NULLIF(trim(COALESCE(NEW.acceptance_criteria, '')), ''),
        NULLIF(trim(COALESCE(NEW.objective, '')), '')
      );
      
      IF v_criteria_source IS NOT NULL 
         AND count_acceptance_criteria(v_criteria_source) > 0 THEN
        
        UPDATE work_orders 
        SET qa_checklist = parse_criteria_to_checklist(v_criteria_source)
        WHERE id = NEW.id;
        
        INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
        VALUES (
          'qa_checklist_populated', 'system', 'auto_populate_qa_checklist',
          'work_order', NEW.id,
          format('Auto-populated %s checklist items from %s', 
            count_acceptance_criteria(v_criteria_source),
            CASE WHEN NEW.acceptance_criteria IS NOT NULL AND trim(NEW.acceptance_criteria) != '' 
                 THEN 'acceptance_criteria' ELSE 'objective' END),
          jsonb_build_object(
            'wo_slug', NEW.slug,
            'criteria_count', count_acceptance_criteria(v_criteria_source),
            'source', CASE WHEN NEW.acceptance_criteria IS NOT NULL AND trim(NEW.acceptance_criteria) != '' 
                          THEN 'acceptance_criteria' ELSE 'objective' END
          )
        );
      END IF;
    END IF;
    
    RETURN NEW;
  END;
END;
$$;


--
-- Name: FUNCTION auto_populate_qa_checklist(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.auto_populate_qa_checklist() IS 'Auto-populates qa_checklist JSONB with default items when work order enters review status';


--
-- Name: auto_promote_critical_lesson(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_promote_critical_lesson() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_directive_id UUID;
BEGIN
  IF NEW.severity = 'critical' AND NOT NEW.applied_to_directives THEN
    BEGIN
      v_directive_id := promote_lesson_to_directive(
        NEW.id,
        'rule',
        'hard',
        90,
        'auto_promote_critical'
      );
      RAISE NOTICE 'Auto-promoted critical lesson % to directive %', NEW.id, v_directive_id;
    EXCEPTION WHEN OTHERS THEN
      RAISE WARNING 'Failed to auto-promote critical lesson %: %', NEW.id, SQLERRM;
    END;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: auto_route_portal_insert(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_route_portal_insert() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_agent_id UUID;
  v_agent_name TEXT;
  v_tags TEXT[];
  v_routing_reason TEXT;
  v_skip_detection BOOLEAN := false;
  v_detected_local BOOLEAN := false;
BEGIN
  IF NEW.assigned_to IS NOT NULL THEN RETURN NEW; END IF;
  IF NEW.status NOT IN ('draft', 'ready') THEN RETURN NEW; END IF;

  v_tags := COALESCE(NEW.tags, ARRAY[]::TEXT[]);
  v_skip_detection := ('remediation' = ANY(v_tags)) OR (NEW.source IN ('auto-qa', 'api'));

  -- ========================================================
  -- RULE 0: Remediation WOs ALWAYS go to builder (they need code writes)
  -- This MUST be first — overrides source-based routing
  -- ========================================================
  IF 'remediation' = ANY(v_tags) THEN
    SELECT id, name INTO v_agent_id, v_agent_name 
    FROM agents WHERE name = 'builder' AND status = 'active';
    v_routing_reason := 'remediation: always builder (needs write tools)';

  -- Rule 1: System-generated QA evaluations → qa-gate  
  ELSIF NEW.source = 'auto-qa' THEN
    SELECT id, name INTO v_agent_id, v_agent_name 
    FROM agents WHERE name = 'qa-gate' AND status = 'active';
    v_routing_reason := 'system-routed: auto-qa source → qa-gate';

  -- Rule 2: Pure security review → security (no code tags)
  ELSIF ARRAY['security-review', 'red-team', 'vulnerability-scan'] && v_tags
     AND NOT ARRAY['code-change', 'migration', 'deploy', 'pipeline-phase', 'sql-only', 'hardening'] && v_tags THEN
    SELECT id, name INTO v_agent_id, v_agent_name 
    FROM agents WHERE name = 'security' AND status = 'active';
    v_routing_reason := 'read-only: security review → security';

  -- Rule 3: Pure health/monitoring → ops (no code tags)
  ELSIF ARRAY['health-check', 'monitoring', 'stuck-detection'] && v_tags
     AND NOT ARRAY['code-change', 'migration', 'deploy', 'pipeline-phase', 'sql-only'] && v_tags THEN
    SELECT id, name INTO v_agent_id, v_agent_name 
    FROM agents WHERE name = 'ops' AND status = 'active';
    v_routing_reason := 'read-only: monitoring → ops';

  -- Rule 4: Pure QA/review → qa-gate (no code tags)
  ELSIF ARRAY['qa', 'review', 'evaluation', 'compliance'] && v_tags
     AND NOT ARRAY['code-change', 'migration', 'deploy', 'pipeline-phase', 'sql-only'] && v_tags THEN
    SELECT id, name INTO v_agent_id, v_agent_name 
    FROM agents WHERE name = 'qa-gate' AND status = 'active';
    v_routing_reason := 'read-only: QA/review → qa-gate';

  -- Rule 5: Frontend code → frontend agent (no backend tags)
  ELSIF ARRAY['frontend', 'ui', 'portal', 'dashboard', 'html'] && v_tags
     AND NOT ARRAY['migration', 'sql-only', 'edge-function', 'supabase'] && v_tags THEN
    SELECT id, name INTO v_agent_id, v_agent_name 
    FROM agents WHERE name = 'frontend' AND status = 'active';
    v_routing_reason := 'code-writer: frontend-tagged → frontend agent';

  -- Rule 6: Everything else → builder
  ELSE
    SELECT id, name INTO v_agent_id, v_agent_name 
    FROM agents WHERE name = 'builder' AND status = 'active';
    v_routing_reason := 'default: builder handles all unmatched WOs';
  END IF;

  -- Local filesystem detection
  IF v_agent_name = 'builder' AND NOT v_skip_detection THEN
    v_detected_local := detect_local_filesystem_need(NEW.objective, NEW.acceptance_criteria);
    IF v_detected_local THEN
      v_routing_reason := v_routing_reason || ', local-filesystem detected';
    END IF;
  END IF;

  IF v_agent_id IS NOT NULL THEN
    NEW.assigned_to := v_agent_id;
    IF NEW.approved_at IS NULL THEN
      IF NEW.priority IN ('p1_high', 'p2_medium', 'p3_low') THEN NEW.approved_at := now();
      ELSIF NEW.source = 'auto-qa' THEN NEW.approved_at := now();
      END IF;
    END IF;
    INSERT INTO state_mutations (mutation_type, target_table, target_id, payload)
    VALUES ('INSERT', 'work_orders', NEW.id,
      jsonb_build_object('action', 'auto_route', 'assigned_agent', v_agent_name,
        'routing_reason', v_routing_reason, 'source', NEW.source, 'wo_tags', v_tags));
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: auto_route_review(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_route_review() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF current_setting('app.wo_transition_active', true) = 'true' THEN RETURN NEW; END IF;
  IF NEW.status = 'review' AND OLD.status IS DISTINCT FROM 'review' THEN
    UPDATE work_orders SET assigned_to = NULL WHERE id = NEW.id;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION auto_route_review(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.auto_route_review() IS 'Routes work orders to appropriate reviewers and triggers automated audit review with auto-approval for low-risk passing WOs';


--
-- Name: auto_route_work_order(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_route_work_order() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_agent_id UUID;
  v_agent_name TEXT;
  v_tags TEXT[];
  v_local_tags TEXT[] := ARRAY['local-filesystem', 'rollback', 'portal-frontend', 'git-delivery'];
  v_has_local_tag BOOLEAN := false;
  v_detected_local BOOLEAN := false;
  v_should_auto_approve BOOLEAN;
  v_routing_reason TEXT;
BEGIN
  -- Only trigger on status change to 'ready' (approval)
  IF NEW.status != 'ready' OR (OLD IS NOT NULL AND OLD.status = 'ready') THEN
    RETURN NEW;
  END IF;

  -- Skip if already assigned
  IF NEW.assigned_to IS NOT NULL THEN
    RETURN NEW;
  END IF;

  v_tags := COALESCE(NEW.tags, ARRAY[]::TEXT[]);

  -- Check if any tags match local-only routing (manual tags)
  SELECT EXISTS (
    SELECT 1 FROM unnest(v_tags) t WHERE t = ANY(v_local_tags)
  ) INTO v_has_local_tag;

  -- Smart detection: scan objective + acceptance_criteria for local-filesystem indicators
  IF NOT v_has_local_tag THEN
    v_detected_local := detect_local_filesystem_need(NEW.objective, NEW.acceptance_criteria);
    
    IF v_detected_local THEN
      -- Auto-add 'local-filesystem' tag so downstream systems also know
      v_tags := array_append(v_tags, 'local-filesystem');
      NEW.tags := v_tags;
      v_has_local_tag := true;
    END IF;
  END IF;

  IF v_has_local_tag THEN
    -- Route to ilmarinen (local CLI executor)
    v_agent_name := 'ilmarinen';
    v_routing_reason := CASE 
      WHEN v_detected_local THEN 'auto-detected local-filesystem need from objective/ACs text'
      ELSE 'local tag detected, routed to ilmarinen (CLI)'
    END;
  ELSE
    -- Route to builder (server-side executor) for everything else
    v_agent_name := 'builder';
    v_routing_reason := 'server-side routing to builder (wo-agent)';
  END IF;

  -- Look up agent ID
  SELECT id INTO v_agent_id FROM agents WHERE name = v_agent_name AND status = 'active';

  IF v_agent_id IS NOT NULL THEN
    NEW.assigned_to := v_agent_id;

    -- Auto-approve P2/P3 WOs on creation
    v_should_auto_approve := NEW.priority IN ('p2_medium', 'p3_low');
    
    IF v_should_auto_approve AND NEW.approved_at IS NULL THEN
      NEW.approved_at := now();
      NEW.approved_by := 'auto-approval-routing';
      
      INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
      VALUES (NEW.id, 'stream', 'system',
        jsonb_build_object(
          'action', 'auto_approved',
          'reason', 'priority_policy',
          'priority', NEW.priority,
          'policy', 'p2_p3_auto_approve',
          'assigned_agent', v_agent_name
        )
      );
    END IF;

    INSERT INTO state_mutations (mutation_type, target_table, target_id, payload)
    VALUES ('UPDATE', 'work_orders', NEW.id,
      jsonb_build_object(
        'action', 'auto_route',
        'assigned_agent', v_agent_name,
        'routing_reason', v_routing_reason,
        'auto_detected_local', v_detected_local,
        'tags', v_tags,
        'auto_approved', v_should_auto_approve
      )
    );
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: auto_start_approved_ready(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_start_approved_ready() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  IF current_setting('app.wo_transition_active', true) = 'true' THEN RETURN NEW; END IF;
  IF NEW.status = 'draft' AND NEW.approved_at IS NOT NULL AND OLD.approved_at IS NULL THEN
    NEW.status := 'ready';
  END IF;
  IF NEW.status = 'ready' AND NEW.approved_at IS NOT NULL AND OLD.status IS DISTINCT FROM 'ready' THEN
    NEW.started_at := NOW();
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: auto_start_on_insert_draft(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_start_on_insert_draft() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF current_setting('app.wo_transition_active', true) = 'true' THEN RETURN NEW; END IF;
  IF NEW.status = 'draft' AND NEW.requires_approval = false THEN
    UPDATE work_orders SET status = 'in_progress', started_at = NOW() WHERE id = NEW.id;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: auto_start_on_insert_ready(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_start_on_insert_ready() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_all_deps_done BOOLEAN := true;
  v_dep_id UUID;
  v_dep_status TEXT;
  v_agent_name TEXT;
BEGIN
  -- Only fire for WOs inserted as ready with assignment and approval
  IF NEW.status != 'ready' THEN
    RETURN NULL; -- AFTER trigger, return value ignored
  END IF;

  IF NEW.assigned_to IS NULL OR NEW.approved_at IS NULL THEN
    RETURN NULL;
  END IF;

  -- Check all dependencies are done
  IF NEW.depends_on IS NOT NULL AND array_length(NEW.depends_on, 1) > 0 THEN
    FOR v_dep_id IN SELECT unnest(NEW.depends_on)
    LOOP
      SELECT status INTO v_dep_status FROM work_orders WHERE id = v_dep_id;
      IF v_dep_status IS NULL OR v_dep_status != 'done' THEN
        v_all_deps_done := false;
        EXIT;
      END IF;
    END LOOP;
  END IF;

  IF NOT v_all_deps_done THEN
    -- Dependencies not met — stay in ready, cascade trigger will start later
    INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
    VALUES (NEW.id, 'stream', 'system',
      jsonb_build_object(
        'action', 'insert_ready_deferred',
        'reason', 'dependencies not yet complete',
        'depends_on', NEW.depends_on
      )
    );
    RETURN NULL;
  END IF;

  -- All conditions met — transition ready → in_progress
  PERFORM set_config('app.wo_trigger_context', 'true', true);
  PERFORM set_config('app.wo_executor_bypass', 'true', true);

  SELECT name INTO v_agent_name FROM agents WHERE id = NEW.assigned_to;

  UPDATE work_orders
  SET status = 'in_progress',
      started_at = COALESCE(started_at, now()),
      updated_at = now()
  WHERE id = NEW.id AND status = 'ready';

  -- Log the auto-start
  INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
  VALUES (NEW.id, 'stream', COALESCE(v_agent_name, 'system'),
    jsonb_build_object(
      'action', 'auto_started_on_insert',
      'wo_slug', NEW.slug,
      'assigned_to', v_agent_name,
      'deps_met', true
    )
  );

  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
  VALUES (
    'auto_start', 'system', 'trg_auto_start_insert',
    'work_order', NEW.id,
    format('Auto-started %s on insert (assigned to %s)', NEW.slug, COALESCE(v_agent_name, 'unknown')),
    jsonb_build_object('wo_slug', NEW.slug, 'agent', v_agent_name)
  );

  RETURN NULL;
END;
$$;


--
-- Name: auto_trigger_enforcer_on_failure(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_trigger_enforcer_on_failure() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- If a WO transitions to 'cancelled' (closest existing status to "failed/rejected"), trigger enforcer
  IF NEW.status = 'cancelled' AND OLD.status IS DISTINCT FROM 'cancelled' THEN
    PERFORM trigger_audit_enforcer(NEW.slug::text, 'wo_failure');
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: auto_unblock_dependents_for_wo(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_unblock_dependents_for_wo(p_work_order_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE work_orders 
  SET status = 'ready', updated_at = NOW() 
  WHERE status = 'blocked_on_input' 
    AND depends_on && ARRAY[p_work_order_id];
END;
$$;


--
-- Name: auto_update_phase_on_wo_completion(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_update_phase_on_wo_completion() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.status = 'done' AND OLD.status != 'done' THEN
    IF NEW.project_brief_id IS NOT NULL THEN
      UPDATE project_briefs SET current_phase = current_phase + 1, completion_pct = LEAST(100, completion_pct + 10)
      WHERE id = NEW.project_brief_id;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: auto_update_project_docs_on_manifest(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_update_project_docs_on_manifest() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- When a state_mutation targets system_manifest, update all architecture docs
  IF NEW.target_table = 'system_manifest' THEN
    UPDATE project_documents
    SET updated_at = NOW()
    WHERE doc_type IN ('architecture', 'system_architecture', 'component_registry');
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: auto_update_project_documents_on_manifest_change(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_update_project_documents_on_manifest_change() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Update all architecture-related document types when manifest changes
  -- Use project_id from project_briefs (METIS-001 project)
  UPDATE project_documents
  SET updated_at = NOW()
  WHERE doc_type IN ('architecture', 'schema', 'manifest', 'system_overview')
    AND project_id IN (SELECT id FROM project_briefs WHERE code = 'METIS-001');
  
  RETURN NEW;
END;
$$;


--
-- Name: autoroute_work_order(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.autoroute_work_order(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo RECORD;
  v_gate RECORD;
  v_context JSONB;
  v_approval_id UUID;
  v_result JSONB;
BEGIN
  -- Get work order
  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  
  IF v_wo IS NULL THEN
    RETURN jsonb_build_object('error', 'Work order not found');
  END IF;
  
  -- Build context
  v_context := jsonb_build_object(
    'priority', v_wo.priority,
    'cost_usd', 0,
    'complexity', v_wo.complexity,
    'tags', v_wo.tags
  );
  
  -- Check decision gate
  SELECT * INTO v_gate FROM check_decision_gate('work_order_execute', v_context);
  
  IF v_gate.needs_approval THEN
    -- FIX: Do NOT change status to pending_approval (invisible on portal).
    -- Leave WO in current status (draft) so it stays visible in portal Inbox.
    -- Just log the gate decision and queue for approval.
    
    -- Insert approval queue entry (for tracking, no status change)
    INSERT INTO approval_queue (
      gate_id, work_order_id, request_type, request_summary, request_detail,
      status, requested_by
    ) VALUES (
      v_gate.gate_id, p_work_order_id, 'work_order_execute', 
      v_wo.name, v_context, 'pending', 'autorouter'
    ) RETURNING id INTO v_approval_id;
    
    v_result := jsonb_build_object(
      'action', 'queued_for_approval',
      'approval_id', v_approval_id,
      'gate', v_gate.gate_name,
      'assignee', v_gate.assignee,
      'reason', v_gate.reason,
      'note', 'WO remains in draft status for portal visibility'
    );
  ELSE
    -- Auto-route to agent (needs bypass for state changes)
    PERFORM set_config('app.wo_trigger_context', 'true', true);
    PERFORM set_config('app.wo_executor_bypass', 'true', true);
    
    UPDATE work_orders 
    SET status = 'ready', 
        assigned_to = (SELECT id FROM agents WHERE name = v_gate.assignee LIMIT 1),
        approved_at = now(),
        approved_by = 'autorouter'
    WHERE id = p_work_order_id;
    
    -- Log auto-approval
    INSERT INTO approval_queue (
      gate_id, work_order_id, request_type, request_summary, request_detail,
      status, requested_by, decided_by, decided_at, decision_notes
    ) VALUES (
      v_gate.gate_id, p_work_order_id, 'work_order_execute',
      v_wo.name, v_context, 'auto_approved', 'autorouter', 'auto', now(),
      'Auto-approved via gate: ' || v_gate.gate_name
    );
    
    v_result := jsonb_build_object(
      'action', 'auto_routed',
      'gate', v_gate.gate_name,
      'assigned_to', v_gate.assignee,
      'status', 'ready'
    );
  END IF;
  
  -- Log routing decision
  INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
  VALUES (p_work_order_id, 'gate_evaluation', 'autorouter', v_result);
  
  RETURN v_result;
END;
$$;


--
-- Name: backfill_evidence_bundles(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.backfill_evidence_bundles(p_limit integer DEFAULT 10) RETURNS TABLE(work_order_id uuid, success boolean, error_message text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_wo RECORD;
    v_bundle JSONB;
    v_duration NUMERIC;
BEGIN
    FOR v_wo IN 
        SELECT wo.id, wo.started_at, wo.completed_at, wo.enforcer_verified, wo.verification_status
        FROM work_orders wo
        WHERE wo.status = 'done' 
          AND wo.completed_at IS NOT NULL
          AND NOT EXISTS (
            SELECT 1 FROM evidence_bundles eb WHERE eb.work_order_id = wo.id
          )
        ORDER BY wo.completed_at DESC
        LIMIT p_limit
    LOOP
        BEGIN
            -- Generate bundle
            v_bundle := assemble_evidence_bundle(v_wo.id);
            v_duration := EXTRACT(EPOCH FROM (v_wo.completed_at - v_wo.started_at));
            
            -- Insert evidence bundle
            INSERT INTO evidence_bundles (
                work_order_id,
                bundle,
                total_duration_seconds,
                total_tokens,
                total_cost_usd,
                qa_passed,
                enforcer_passed,
                verification_passed
            )
            VALUES (
                v_wo.id,
                v_bundle,
                v_duration,
                COALESCE((v_bundle->'cost'->>'total_tokens')::INTEGER, 0),
                COALESCE((v_bundle->'cost'->>'total_cost_usd')::NUMERIC, 0),
                COALESCE((v_bundle->'qa'->>'passed')::BOOLEAN, true),
                v_wo.enforcer_verified,
                CASE 
                    WHEN v_wo.verification_status = 'verified' THEN true
                    WHEN v_wo.verification_status = 'failed' THEN false
                    ELSE NULL
                END
            );
            
            work_order_id := v_wo.id;
            success := true;
            error_message := NULL;
            RETURN NEXT;
            
        EXCEPTION WHEN OTHERS THEN
            work_order_id := v_wo.id;
            success := false;
            error_message := SQLERRM;
            RETURN NEXT;
        END;
    END LOOP;
END;
$$;


--
-- Name: build_mutation_dependency_graph(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.build_mutation_dependency_graph(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_adjacency_list jsonb := '[]'::jsonb;
    v_edges jsonb := '[]'::jsonb;
    v_mutation_ids uuid[];
    v_mutation_record RECORD;
    v_depends_on_record RECORD;
    v_dep RECORD;
BEGIN
    -- Get all mutations for this work order ordered by created_at
    SELECT ARRAY_AGG(id ORDER BY created_at) INTO v_mutation_ids
    FROM wo_mutations 
    WHERE work_order_id = p_work_order_id;

    IF v_mutation_ids IS NULL OR array_length(v_mutation_ids, 1) IS NULL THEN
        RETURN jsonb_build_object(
            'work_order_id', p_work_order_id,
            'edges', '[]'::jsonb,
            'adjacency_list', '[]'::jsonb,
            'message', 'No mutations found for work order'
        );
    END IF;

    -- Analyze dependencies between mutations
    FOR v_mutation_record IN 
        SELECT id, tool_name, object_type, object_id, action, created_at
        FROM wo_mutations 
        WHERE work_order_id = p_work_order_id
        ORDER BY created_at
    LOOP
        -- Check for schema dependencies: CREATE TABLE before INSERT INTO same table
        IF v_mutation_record.tool_name IN ('apply_migration', 'create_table') AND 
           v_mutation_record.action IN ('CREATE', 'CREATE TABLE') THEN
            
            FOR v_depends_on_record IN
                SELECT m.id, m.tool_name, m.object_id
                FROM wo_mutations m
                WHERE m.work_order_id = p_work_order_id
                  AND m.id != v_mutation_record.id
                  AND m.created_at < v_mutation_record.created_at
                  AND m.tool_name IN ('execute_sql', 'apply_migration')
                  AND m.object_id = v_mutation_record.object_id
                  AND m.action LIKE '%INSERT%'
                ORDER BY m.created_at DESC
                LIMIT 1
            LOOP
                -- Insert edge into wo_mutation_dependencies
                INSERT INTO wo_mutation_dependencies (mutation_id, depends_on_mutation_id, dependency_type)
                VALUES (v_depends_on_record.id, v_mutation_record.id, 'schema')
                ON CONFLICT DO NOTHING;

                v_edges := v_edges || jsonb_build_array(jsonb_build_object(
                    'from', v_depends_on_record.id,
                    'to', v_mutation_record.id,
                    'type', 'schema'
                ));
            END LOOP;
        END IF;

        -- Check for function dependencies: apply_migration (CREATE FUNCTION) before deploy
        IF v_mutation_record.tool_name = 'apply_migration' AND 
           v_mutation_record.action LIKE '%FUNCTION%' THEN
            
            FOR v_depends_on_record IN
                SELECT m.id, m.tool_name, m.object_id
                FROM wo_mutations m
                WHERE m.work_order_id = p_work_order_id
                  AND m.id != v_mutation_record.id
                  AND m.created_at < v_mutation_record.created_at
                  AND m.tool_name = 'deploy_edge_function'
                  AND m.object_id = v_mutation_record.object_id
                ORDER BY m.created_at DESC
                LIMIT 1
            LOOP
                INSERT INTO wo_mutation_dependencies (mutation_id, depends_on_mutation_id, dependency_type)
                VALUES (v_depends_on_record.id, v_mutation_record.id, 'function')
                ON CONFLICT DO NOTHING;

                v_edges := v_edges || jsonb_build_array(jsonb_build_object(
                    'from', v_depends_on_record.id,
                    'to', v_mutation_record.id,
                    'type', 'function'
                ));
            END LOOP;
        END IF;

        -- Check for sequential dependencies: ALTER FUNCTION before execute_sql verify
        IF v_mutation_record.tool_name = 'apply_migration' AND 
           v_mutation_record.action LIKE '%FUNCTION%' AND
           v_mutation_record.action LIKE '%ALTER%' THEN
            
            FOR v_depends_on_record IN
                SELECT m.id, m.tool_name, m.object_id
                FROM wo_mutations m
                WHERE m.work_order_id = p_work_order_id
                  AND m.id != v_mutation_record.id
                  AND m.created_at < v_mutation_record.created_at
                  AND m.tool_name = 'execute_sql'
                  AND m.object_id = v_mutation_record.object_id
                  AND m.action LIKE '%SELECT%'
                ORDER BY m.created_at DESC
                LIMIT 1
            LOOP
                INSERT INTO wo_mutation_dependencies (mutation_id, depends_on_mutation_id, dependency_type)
                VALUES (v_depends_on_record.id, v_mutation_record.id, 'sequential')
                ON CONFLICT DO NOTHING;

                v_edges := v_edges || jsonb_build_array(jsonb_build_object(
                    'from', v_depends_on_record.id,
                    'to', v_mutation_record.id,
                    'type', 'sequential'
                ));
            END LOOP;
        END IF;
    END LOOP;

    -- Build adjacency list using cursor and array accumulation
    FOR v_dep IN
        SELECT DISTINCT mutation_id, depends_on_mutation_id
        FROM wo_mutation_dependencies
        WHERE mutation_id = ANY(v_mutation_ids)
    LOOP
        v_adjacency_list := v_adjacency_list || jsonb_build_array(jsonb_build_object(
            'mutation_id', v_dep.mutation_id,
            'depends_on', v_dep.depends_on_mutation_id
        ));
    END LOOP;

    IF v_adjacency_list IS NULL THEN
        v_adjacency_list := '[]'::jsonb;
    END IF;

    RETURN jsonb_build_object(
        'work_order_id', p_work_order_id,
        'edges', v_edges,
        'adjacency_list', v_adjacency_list,
        'mutation_count', array_length(v_mutation_ids, 1),
        'dependency_count', jsonb_array_length(v_edges)
    );
END;
$$;


--
-- Name: build_remediation_objective(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.build_remediation_objective(p_wo_id uuid, p_failure_reason text DEFAULT 'Unknown failure'::text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_wo record;
  v_ok text;
  v_fail text;
  v_qaf text;
  v_qac text;
  v_chain text;
  v_exec text;
  v_prev int;
  v_fc int;
BEGIN
  SELECT * INTO v_wo FROM work_orders WHERE id = p_wo_id;
  IF v_wo IS NULL THEN RETURN 'Fix failure: ' || p_failure_reason; END IF;

  -- Successful mutations (DO NOT REDO)
  SELECT string_agg(
    '  + ' || tool_name || ': ' || LEFT(COALESCE(context::text, ''), 150),
    E'\n' ORDER BY created_at
  ) INTO v_ok
  FROM wo_mutations WHERE work_order_id = p_wo_id AND success = true;

  -- Failed mutations (DO NOT RETRY)
  SELECT string_agg(
    '  - ' || tool_name || ': ' || LEFT(COALESCE(error_detail, context::text, ''), 150),
    E'\n' ORDER BY created_at
  ) INTO v_fail
  FROM wo_mutations WHERE work_order_id = p_wo_id AND success = false;

  -- QA findings detail
  SELECT COUNT(*), string_agg(
    '  - [' || COALESCE(category, 'general') || '] ' || LEFT(description, 200),
    E'\n' ORDER BY created_at
  ) INTO v_fc, v_qaf
  FROM qa_findings
  WHERE work_order_id = p_wo_id AND finding_type = 'fail' AND resolved_at IS NULL;

  -- QA checklist status
  IF v_wo.qa_checklist IS NOT NULL AND v_wo.qa_checklist != '[]'::jsonb THEN
    SELECT string_agg(
      '  ' || CASE
        WHEN (item->>'status') = 'passed' THEN '[PASS]'
        WHEN (item->>'status') = 'failed' THEN '[FAIL]'
        ELSE '[    ]'
      END || ' ' || (item->>'description'),
      E'\n'
    ) INTO v_qac
    FROM jsonb_array_elements(v_wo.qa_checklist) AS item;
  END IF;

  -- Previous remediation chain
  SELECT count(*), string_agg(
    '  ' || rwo.slug || ': ' || rwo.status || ' - ' || LEFT(COALESCE(rwo.summary, 'no summary'), 150),
    E'\n' ORDER BY rwo.created_at
  ) INTO v_prev, v_chain
  FROM work_orders rwo
  WHERE rwo.parent_id = p_wo_id
    AND 'remediation' = ANY(rwo.tags)
    AND rwo.status IN ('failed', 'cancelled', 'done');

  -- Execution log summary (last 10 entries)
  SELECT string_agg(sub.line, E'\n') INTO v_exec
  FROM (
    SELECT '  [' || phase || '] '
      || COALESCE(detail->>'tool_name', detail->>'event_type', '?')
      || ': ' || LEFT(COALESCE(detail->>'content', detail->>'error', ''), 100) AS line
    FROM work_order_execution_log
    WHERE work_order_id = p_wo_id
    ORDER BY created_at DESC
    LIMIT 10
  ) sub;

  -- Assemble rich objective
  RETURN 'Fix failure in ' || v_wo.slug
    || E'\n\n## FAILURE REASON\n' || p_failure_reason
    || E'\n\n## ORIGINAL OBJECTIVE\n' || LEFT(COALESCE(v_wo.objective, ''), 500)
    || CASE WHEN COALESCE(v_wo.acceptance_criteria, '') != ''
         THEN E'\n\n## ORIGINAL ACCEPTANCE CRITERIA\n' || v_wo.acceptance_criteria ELSE '' END
    || CASE WHEN v_ok IS NOT NULL
         THEN E'\n\n## COMPLETED MUTATIONS (DO NOT REDO)\n' || v_ok ELSE '' END
    || CASE WHEN v_fail IS NOT NULL
         THEN E'\n\n## FAILED MUTATIONS (DO NOT RETRY SAME APPROACH)\n' || v_fail ELSE '' END
    || CASE WHEN v_qac IS NOT NULL
         THEN E'\n\n## QA CHECKLIST STATUS\n' || v_qac ELSE '' END
    || CASE WHEN v_fc > 0 AND v_qaf IS NOT NULL
         THEN E'\n\n## QA FINDINGS (' || v_fc || E' unresolved)\n' || v_qaf ELSE '' END
    || CASE WHEN v_exec IS NOT NULL
         THEN E'\n\n## RECENT EXECUTION LOG\n' || v_exec ELSE '' END
    || CASE WHEN v_prev > 0 AND v_chain IS NOT NULL
         THEN E'\n\n## PREVIOUS REMEDIATION ATTEMPTS (' || v_prev || E')\n' || v_chain
           || E'\n\nDo NOT repeat approaches that already failed.' ELSE '' END;
END;
$$;


--
-- Name: calculate_execution_log_hash(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calculate_execution_log_hash() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  last_hash TEXT;
  last_iteration INT;
  hash_input TEXT;
BEGIN
  SELECT 
    COALESCE(MAX(iteration), 0),
    (SELECT entry_hash FROM work_order_execution_log 
     WHERE work_order_id = NEW.work_order_id 
     ORDER BY iteration DESC, id DESC 
     LIMIT 1)
  INTO last_iteration, last_hash
  FROM work_order_execution_log
  WHERE work_order_id = NEW.work_order_id;
  
  IF NEW.iteration IS NULL OR NEW.iteration = 1 THEN
    NEW.iteration := last_iteration + 1;
  END IF;
  
  IF NEW.iteration > 1 THEN
    SELECT entry_hash INTO last_hash
    FROM work_order_execution_log
    WHERE work_order_id = NEW.work_order_id
    AND iteration = NEW.iteration - 1
    LIMIT 1;
  ELSE
    last_hash := NULL;
  END IF;
  
  NEW.prev_hash := last_hash;
  
  hash_input := 
    NEW.work_order_id::TEXT || '|' ||
    NEW.phase || '|' ||
    COALESCE(NEW.agent_name, '') || '|' ||
    COALESCE(NEW.detail::TEXT, '{}') || '|' ||
    COALESCE(last_hash, '') || '|' ||
    NEW.created_at::TEXT;
  
  -- Fix: use convert_to() instead of ::bytea cast
  -- ::bytea expects escape-format input, fails on arbitrary text with special chars
  NEW.entry_hash := encode(extensions.digest(convert_to(hash_input, 'UTF-8'), 'sha256'), 'hex');
  
  RETURN NEW;
END;
$$;


--
-- Name: cancel_children_on_parent_done(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cancel_children_on_parent_done() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  child_rec RECORD;
BEGIN
  -- Only fire on transition TO done
  IF OLD.status = NEW.status THEN
    RETURN NEW;
  END IF;

  -- Find all remediation children that are still in-flight
  FOR child_rec IN
    SELECT id, slug, status
    FROM work_orders
    WHERE parent_id = NEW.id
      AND status IN ('draft', 'ready', 'in_progress', 'review', 'failed')
      AND 'remediation' = ANY(tags)
  LOOP
    -- Use direct bypass (like other auto-transitions) instead of RPC
    PERFORM set_config('app.wo_trigger_context', 'true', true);
    PERFORM set_config('app.wo_executor_bypass', 'true', true);
    UPDATE work_orders
    SET status = 'cancelled',
        summary = COALESCE(summary, '') || ' [Auto-cancelled: parent WO completed]',
        completed_at = NOW(),
        updated_at = NOW()
    WHERE id = child_rec.id;
    PERFORM set_config('app.wo_executor_bypass', 'false', true);
    PERFORM set_config('app.wo_trigger_context', '', true);

    -- Audit log
    INSERT INTO audit_log (
      event_type, actor_type, actor_id, target_type, target_id,
      action, payload, previous_state, new_state, work_order_id
    ) VALUES (
      'wo_cancelled', 'system', 'cancel_children_on_parent_done',
      'work_order', child_rec.id,
      'auto_cancel_remediation_child',
      jsonb_build_object(
        'reason', 'Parent WO completed - remediation no longer needed',
        'parent_id', NEW.id,
        'parent_slug', NEW.slug,
        'child_slug', child_rec.slug,
        'previous_status', child_rec.status
      ),
      jsonb_build_object('status', child_rec.status),
      jsonb_build_object('status', 'cancelled'),
      child_rec.id
    );
  END LOOP;

  RETURN NEW;
END;
$$;


--
-- Name: capture_execution_snapshot(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.capture_execution_snapshot(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_snapshot JSONB;
  v_edge_functions JSONB;
  v_db_schema JSONB;
BEGIN
  -- Capture current edge function versions
  SELECT jsonb_agg(
    jsonb_build_object(
      'name', name,
      'version', version,
      'status', status,
      'config', config
    )
  ) INTO v_edge_functions
  FROM system_manifest
  WHERE component_type = 'edge_function'
    AND status = 'active';

  -- Capture relevant database schema info
  SELECT jsonb_build_object(
    'tables', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'name', name,
          'version', version
        )
      )
      FROM system_manifest
      WHERE component_type = 'table'
    ),
    'rpc_functions', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'name', name,
          'version', version
        )
      )
      FROM system_manifest
      WHERE component_type = 'rpc_function'
    )
  ) INTO v_db_schema;

  -- Build complete snapshot
  v_snapshot := jsonb_build_object(
    'captured_at', NOW(),
    'work_order_id', p_work_order_id,
    'edge_functions', COALESCE(v_edge_functions, '[]'::jsonb),
    'db_schema', COALESCE(v_db_schema, '{}'::jsonb)
  );

  -- Store snapshot in work order
  UPDATE work_orders
  SET pre_execution_snapshot = v_snapshot
  WHERE id = p_work_order_id;

  RETURN v_snapshot;
END;
$$;


--
-- Name: FUNCTION capture_execution_snapshot(p_work_order_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.capture_execution_snapshot(p_work_order_id uuid) IS 'WO-0076: Captures pre-execution snapshot including edge function versions, database schema state. Called before WO execution begins to enable rollback.';


--
-- Name: cascade_on_completion(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cascade_on_completion() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Suppression guard: skip if wo_transition is actively processing
  IF current_setting('app.wo_transition_active', true) = 'true' THEN RETURN NEW; END IF;
  
  IF NEW.status IN ('done', 'cancelled', 'failed') AND OLD.status NOT IN ('done', 'cancelled', 'failed') THEN
    UPDATE work_orders SET status = NEW.status, cancellation_reason = NEW.cancellation_reason
    WHERE parent_id = NEW.id AND status NOT IN ('done', 'cancelled', 'failed');
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: check_agent_fit(text, text[], integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_agent_fit(p_agent_name text, p_required_tools text[], p_scope_size integer) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_profile record;
  v_tools_available boolean := true;
  v_missing_tools text[];
  v_model text;
  v_context_window int;
  v_estimated_tokens int;
  v_fits_context boolean;
  v_agent_role text;
  v_role_match boolean := true;
  v_tool_categories text[];
  v_allowed_tools text[];
  v_tool text;
  v_allowed_tools_json jsonb;
  v_agent_tools text[];
BEGIN
  v_missing_tools := ARRAY[]::text[];
  v_tool_categories := ARRAY[]::text[];
  v_allowed_tools := ARRAY[]::text[];
  
  -- Get agent profile
  SELECT * INTO v_profile
  FROM agent_execution_profiles
  WHERE agent_name = p_agent_name
  LIMIT 1;
  
  -- If no profile found, check agents table
  IF v_profile.agent_name IS NULL THEN
    SELECT role, tools_allowed, model INTO v_agent_role, v_agent_tools, v_model
    FROM agents
    WHERE name = p_agent_name
    LIMIT 1;
    
    v_allowed_tools := COALESCE(v_agent_tools, ARRAY[]::text[]);
    
    IF v_agent_role IS NULL THEN
      RETURN jsonb_build_object(
        'tools_available', false,
        'missing_tools', p_required_tools,
        'model', NULL,
        'context_window', NULL,
        'estimated_tokens', p_scope_size * 500,
        'fits_context', false,
        'agent_role', NULL,
        'role_match', false,
        'error', 'Agent not found: ' || p_agent_name
      );
    END IF;
  ELSE
    -- Profile found - use profile data AND merge agents.tools_allowed
    v_tool_categories := COALESCE(v_profile.tool_categories, ARRAY[]::text[]);
    v_model := v_profile.model;
    v_agent_role := p_agent_name;
    
    -- Extract allowed_tools from profile scope_boundaries
    v_allowed_tools_json := v_profile.scope_boundaries->'allowed_tools';
    IF v_allowed_tools_json IS NOT NULL AND jsonb_typeof(v_allowed_tools_json) = 'array' THEN
      v_allowed_tools := ARRAY(SELECT jsonb_array_elements_text(v_allowed_tools_json));
    END IF;
    
    -- ALSO merge in agents.tools_allowed for exact-match completeness
    SELECT tools_allowed INTO v_agent_tools FROM agents WHERE name = p_agent_name;
    IF v_agent_tools IS NOT NULL THEN
      v_allowed_tools := v_allowed_tools || v_agent_tools;
    END IF;
  END IF;
  
  -- Determine context window based on model
  CASE 
    WHEN v_model ILIKE '%opus%4%' THEN v_context_window := 200000;
    WHEN v_model ILIKE '%sonnet%4%' THEN v_context_window := 200000;
    WHEN v_model ILIKE '%minimax%' OR v_model ILIKE '%haiku%' THEN v_context_window := 1000000;
    WHEN v_model IS NULL OR v_model = '' THEN v_context_window := 100000;
    ELSE v_context_window := 100000;
  END CASE;
  
  v_estimated_tokens := p_scope_size * 500;
  v_fits_context := v_estimated_tokens < (v_context_window * 0.6);
  
  -- Check tool availability
  IF p_required_tools IS NOT NULL AND array_length(p_required_tools, 1) > 0 THEN
    FOREACH v_tool IN ARRAY p_required_tools LOOP
      IF NOT (
        -- Exact match against merged allowed_tools
        v_tool = ANY(v_allowed_tools) OR 
        -- Category match
        v_tool = ANY(v_tool_categories) OR
        -- FIX: Wildcard match — check if required tool matches an allowed pattern
        -- e.g. 'github_push_files' LIKE 'github_%' (from 'github_*')
        EXISTS (
          SELECT 1 FROM unnest(v_allowed_tools) AS at 
          WHERE v_tool LIKE replace(at, '*', '%')
        )
      ) THEN
        v_tools_available := false;
        v_missing_tools := array_append(v_missing_tools, v_tool);
      END IF;
    END LOOP;
  END IF;
  
  RETURN jsonb_build_object(
    'tools_available', v_tools_available,
    'missing_tools', v_missing_tools,
    'model', v_model,
    'context_window', v_context_window,
    'estimated_tokens', v_estimated_tokens,
    'fits_context', v_fits_context,
    'agent_role', v_agent_role,
    'role_match', v_role_match
  );
END;
$$;


--
-- Name: check_allowed_action(text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_allowed_action(p_action_name text, p_agent_id uuid DEFAULT NULL::uuid, p_work_order_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_action record;
  v_errors text[] := '{}';
  v_wo_status text;
BEGIN
  -- Look up the action
  SELECT * INTO v_action FROM allowed_actions 
  WHERE action_name = p_action_name AND enabled = true;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'allowed', false,
      'errors', jsonb_build_array('Unknown or disabled action: ' || p_action_name)
    );
  END IF;

  -- ════════════════════════════════════════
  -- CHECK 1: Agent authorization
  -- ════════════════════════════════════════
  IF v_action.allowed_agents IS NOT NULL AND array_length(v_action.allowed_agents, 1) > 0 THEN
    IF p_agent_id IS NULL THEN
      v_errors := array_append(v_errors, 'agent_id required for action: ' || p_action_name);
    ELSIF NOT (p_agent_id = ANY(v_action.allowed_agents)) THEN
      v_errors := array_append(v_errors, format('Agent %s not authorized for action: %s', p_agent_id, p_action_name));
    END IF;
  END IF;

  -- ════════════════════════════════════════
  -- CHECK 2: Work order requirement
  -- ════════════════════════════════════════
  IF v_action.requires_work_order THEN
    IF p_work_order_id IS NULL THEN
      v_errors := array_append(v_errors, 'Work order required for action: ' || p_action_name);
    ELSE
      -- Verify WO is in executable state
      SELECT status::text INTO v_wo_status FROM work_orders WHERE id = p_work_order_id;
      IF v_wo_status IS NULL THEN
        v_errors := array_append(v_errors, 'Work order not found: ' || p_work_order_id);
      ELSIF v_wo_status NOT IN ('in_progress', 'ready') THEN
        v_errors := array_append(v_errors, format('Work order not executable (status: %s)', v_wo_status));
      END IF;
    END IF;
  END IF;

  -- ════════════════════════════════════════
  -- CHECK 3: Rate limit (uses existing check_rate_limit)
  -- ════════════════════════════════════════
  IF v_action.rate_limit_per_minute IS NOT NULL AND p_agent_id IS NOT NULL THEN
    -- Rate limiting is already handled by check_rate_limit in the executor
    -- but we record the limit here for reference
    NULL;
  END IF;

  -- ════════════════════════════════════════
  -- RESULT
  -- ════════════════════════════════════════
  IF array_length(v_errors, 1) > 0 THEN
    -- Log rejection
    INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
    VALUES (
      'action_rejected', 
      CASE WHEN p_agent_id IS NOT NULL THEN 'agent' ELSE 'unknown' END,
      COALESCE(p_agent_id::text, 'anonymous'),
      'allowed_action', NULL,
      p_action_name,
      jsonb_build_object('errors', to_jsonb(v_errors), 'work_order_id', p_work_order_id)
    );

    RETURN jsonb_build_object(
      'allowed', false,
      'action', p_action_name,
      'errors', to_jsonb(v_errors)
    );
  END IF;

  RETURN jsonb_build_object(
    'allowed', true,
    'action', p_action_name,
    'requires_work_order', v_action.requires_work_order,
    'rate_limit_per_minute', v_action.rate_limit_per_minute
  );
END;
$$;


--
-- Name: check_and_set_intake_complete(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_and_set_intake_complete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_project_id UUID;
  v_ready JSONB;
BEGIN
  v_project_id := COALESCE(NEW.project_id, OLD.project_id);
  
  IF v_project_id IS NULL THEN RETURN NEW; END IF;

  v_ready := check_project_intake_ready(v_project_id);
  
  IF (v_ready->>'ready')::boolean THEN
    UPDATE project_briefs 
    SET intake_complete = TRUE, updated_at = NOW()
    WHERE id = v_project_id AND (intake_complete IS NULL OR intake_complete = FALSE);
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: check_build_duplicates(text, text[], uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_build_duplicates(p_description text, p_keywords text[] DEFAULT '{}'::text[], p_exclude_wo_id uuid DEFAULT NULL::uuid) RETURNS TABLE(source text, component_type text, name text, description text, relevance double precision, recommendation text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_search_query tsquery;
  v_keyword TEXT;
  v_keyword_queries tsquery[];
BEGIN
  -- Build OR-based tsquery from keywords (primary match signal)
  -- If keywords provided, use them; otherwise extract from description
  IF array_length(p_keywords, 1) > 0 THEN
    v_search_query := NULL;
    FOREACH v_keyword IN ARRAY p_keywords LOOP
      IF v_search_query IS NULL THEN
        v_search_query := plainto_tsquery('english', v_keyword);
      ELSE
        v_search_query := v_search_query || plainto_tsquery('english', v_keyword);
      END IF;
    END LOOP;
  ELSE
    -- Fallback: use description as OR query by splitting on spaces
    v_search_query := to_tsquery('english', 
      array_to_string(
        ARRAY(SELECT lexeme FROM unnest(to_tsvector('english', p_description)) LIMIT 8),
        ' | '
      )
    );
  END IF;

  -- Safety: if we still have no query, return empty
  IF v_search_query IS NULL THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT r.source, r.component_type, r.name, r.description, r.relevance, r.recommendation
  FROM (
    -- Active system_manifest components
    SELECT
      'system_manifest'::TEXT AS source,
      sm.component_type::TEXT AS component_type,
      sm.name::TEXT AS name,
      sm.description::TEXT AS description,
      ts_rank(sm.search_vector, v_search_query)::FLOAT AS relevance,
      CASE
        WHEN sm.status = 'active' THEN 'EXISTS - Consider modifying instead of rebuilding'
        WHEN sm.status = 'deprecated' THEN 'DEPRECATED - May need replacement'
        WHEN sm.status = 'planned' THEN 'PLANNED - Check if already in progress'
        ELSE 'REVIEW'
      END AS recommendation
    FROM system_manifest sm
    WHERE sm.search_vector @@ v_search_query
      AND ts_rank(sm.search_vector, v_search_query) > 0.01

    UNION ALL

    -- Work orders with actual ts_rank, completed WOs weighted down
    SELECT
      'work_orders'::TEXT,
      'work_order'::TEXT,
      wo.slug::TEXT,
      wo.name::TEXT,
      (ts_rank(
        to_tsvector('english', wo.name || ' ' || coalesce(wo.objective, '')),
        v_search_query
      ) * CASE wo.status
        WHEN 'done' THEN 0.3
        WHEN 'review' THEN 0.7
        ELSE 1.0
      END)::FLOAT,
      CASE wo.status
        WHEN 'done' THEN 'COMPLETED - This may already be built'
        WHEN 'in_progress' THEN 'IN PROGRESS - Duplicate work risk'
        WHEN 'review' THEN 'IN REVIEW - Nearly complete'
        ELSE 'PENDING - May overlap'
      END
    FROM work_orders wo
    WHERE to_tsvector('english', wo.name || ' ' || coalesce(wo.objective, '')) @@ v_search_query
      AND wo.status != 'cancelled'
      AND (p_exclude_wo_id IS NULL OR wo.id != p_exclude_wo_id)

    UNION ALL

    -- Schema changes
    SELECT
      'schema_changes'::TEXT,
      sc.object_type::TEXT,
      sc.object_name::TEXT,
      sc.reason::TEXT,
      0.3::FLOAT,
      'SCHEMA EXISTS - ' || sc.change_type
    FROM schema_changes sc
    WHERE sc.object_name ILIKE ANY(SELECT '%' || unnest(p_keywords) || '%')

    UNION ALL

    -- Backlog items
    SELECT
      'backlog'::TEXT,
      'backlog_item'::TEXT,
      bl.name::TEXT,
      bl.summary::TEXT,
      ts_rank(
        to_tsvector('english', bl.name || ' ' || coalesce(bl.summary, '')),
        v_search_query
      )::FLOAT,
      CASE bl.status
        WHEN 'active' THEN 'IN BACKLOG - Already planned'
        ELSE 'BACKLOG (' || bl.status || ')'
      END
    FROM backlog bl
    WHERE to_tsvector('english', bl.name || ' ' || coalesce(bl.summary, '')) @@ v_search_query
  ) r
  WHERE r.relevance > 0.005
  ORDER BY r.relevance DESC
  LIMIT 10;
END;
$$;


--
-- Name: check_complexity_invariant(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_complexity_invariant(p_wo jsonb) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_objective text;
  v_acceptance_criteria text;
  v_complexity_threshold int;
  v_complexity_result jsonb;
  v_complexity_score int;
BEGIN
  v_objective := COALESCE(p_wo->>'objective', '');
  v_acceptance_criteria := COALESCE(p_wo->>'acceptance_criteria', '');

  IF v_objective = '' AND v_acceptance_criteria = '' THEN
    RETURN true;  -- No content to score
  END IF;

  SELECT COALESCE((setting_value->>'value')::int, 5) INTO v_complexity_threshold
  FROM system_settings WHERE setting_key = 'complexity_gate_threshold';

  v_complexity_result := score_wo_complexity(v_objective, v_acceptance_criteria);
  v_complexity_score := (v_complexity_result->>'complexity_score')::int;

  RETURN v_complexity_score <= COALESCE(v_complexity_threshold, 5);
END;
$$;


--
-- Name: check_consensus(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_consensus(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_votes RECORD;
  v_approve_count INT;
  v_reject_count INT;
  v_total_count INT;
  v_consensus TEXT;
BEGIN
  SELECT 
    count(*) FILTER (WHERE vote = 'approve') as approves,
    count(*) FILTER (WHERE vote = 'reject') as rejects,
    count(*) as total
  INTO v_approve_count, v_reject_count, v_total_count
  FROM consensus_votes
  WHERE work_order_id = p_work_order_id;
  
  -- Consensus rules:
  -- 1. If any reject, no consensus (needs human review)
  -- 2. If all approve, consensus reached
  -- 3. If no votes, cannot proceed
  
  IF v_total_count = 0 THEN
    v_consensus := 'pending';
  ELSIF v_reject_count > 0 THEN
    v_consensus := 'blocked';
  ELSIF v_approve_count > 0 THEN
    v_consensus := 'approved';
  ELSE
    v_consensus := 'pending';
  END IF;
  
  RETURN jsonb_build_object(
    'work_order_id', p_work_order_id,
    'consensus', v_consensus,
    'approve_count', v_approve_count,
    'reject_count', v_reject_count,
    'total_votes', v_total_count,
    'can_complete', v_consensus = 'approved'
  );
END;
$$;


--
-- Name: check_decision_gate(text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_decision_gate(p_trigger_type text, p_context jsonb) RETURNS TABLE(needs_approval boolean, gate_name text, gate_id uuid, assignee text, reason text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  gate RECORD;
  cond JSONB;
  matches BOOLEAN;
BEGIN
  FOR gate IN 
    SELECT * FROM decision_gates 
    WHERE trigger_type = p_trigger_type AND active = true
    ORDER BY requires_approval DESC -- Check approval-required gates first
  LOOP
    cond := gate.conditions;
    matches := true;
    
    -- Check priority condition
    IF cond ? 'priority' AND p_context ? 'priority' THEN
      IF NOT (cond->'priority' @> to_jsonb(p_context->>'priority')) THEN
        matches := false;
      END IF;
    END IF;
    
    -- Check cost threshold
    IF cond ? 'cost_usd_gt' AND p_context ? 'cost_usd' THEN
      IF (p_context->>'cost_usd')::numeric <= (cond->>'cost_usd_gt')::numeric THEN
        matches := false;
      END IF;
    END IF;
    
    IF cond ? 'cost_usd_lt' AND p_context ? 'cost_usd' THEN
      IF (p_context->>'cost_usd')::numeric >= (cond->>'cost_usd_lt')::numeric THEN
        matches := false;
      END IF;
    END IF;
    
    -- Check table restrictions
    IF cond ? 'tables' AND p_context ? 'table_name' THEN
      IF NOT (cond->'tables' @> to_jsonb(p_context->>'table_name')) THEN
        matches := false;
      END IF;
    END IF;
    
    IF cond ? 'tables_exclude' AND p_context ? 'table_name' THEN
      IF (cond->'tables_exclude' @> to_jsonb(p_context->>'table_name')) THEN
        matches := false; -- Excluded table, skip this gate
      END IF;
    END IF;
    
    IF matches THEN
      RETURN QUERY SELECT 
        gate.requires_approval,
        gate.name,
        gate.id,
        gate.default_assignee,
        gate.description;
      RETURN;
    END IF;
  END LOOP;
  
  -- Default: require approval if no gate matched
  RETURN QUERY SELECT true, 'default'::TEXT, NULL::UUID, 'human'::TEXT, 'No matching gate - defaulting to human approval'::TEXT;
END;
$$;


--
-- Name: check_directive_compliance(text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_directive_compliance(p_check_point text, p_context jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_directive RECORD;
  v_violations JSONB := '[]'::jsonb;
  v_warnings JSONB := '[]'::jsonb;
  v_checks_run INTEGER := 0;
  v_thread_id UUID;
  v_message_count INTEGER;
  v_project_code TEXT;
BEGIN
  v_thread_id := (p_context->>'thread_id')::uuid;
  v_project_code := p_context->>'project_code';

  -- Iterate over enforceable directives matching this check_point
  FOR v_directive IN 
    SELECT name, check_key, enforcement, enforcement_mode, violation_message, content
    FROM system_directives 
    WHERE active = true 
      AND check_key IS NOT NULL
      AND enforcement_mode != 'context_only'
      AND (
        (p_check_point = 'pre_chat' AND enforcement_mode IN ('pre_check'))
        OR (p_check_point = 'pre_wo_transition' AND enforcement_mode IN ('gate_check'))
        OR (p_check_point = 'post_response' AND enforcement_mode IN ('post_check'))
        OR (p_check_point = 'pre_tool_call' AND enforcement_mode IN ('pre_check'))
      )
  LOOP
    v_checks_run := v_checks_run + 1;

    -- Execute check by check_key
    CASE v_directive.check_key

      WHEN 'memory_recall_first_msg' THEN
        -- Check: is this the first message in thread? If so, memory-recall should be called.
        IF v_thread_id IS NOT NULL THEN
          SELECT COUNT(*) INTO v_message_count 
          FROM thread_messages WHERE thread_id = v_thread_id;
          IF v_message_count <= 1 THEN
            -- First message - flag as needing memory recall
            v_warnings := v_warnings || jsonb_build_array(jsonb_build_object(
              'directive', v_directive.name,
              'check_key', v_directive.check_key,
              'message', 'First message in thread - memory recall should be invoked',
              'enforcement', v_directive.enforcement
            ));
          END IF;
        END IF;

      WHEN 'session_persist_interval' THEN
        -- Check: have 5+ messages passed since last session-capture?
        IF v_thread_id IS NOT NULL THEN
          SELECT COUNT(*) INTO v_message_count
          FROM thread_messages WHERE thread_id = v_thread_id;
          IF v_message_count > 0 AND v_message_count % 10 = 0 THEN
            v_warnings := v_warnings || jsonb_build_array(jsonb_build_object(
              'directive', v_directive.name,
              'check_key', v_directive.check_key,
              'message', format('Thread has %s messages - session persistence recommended', v_message_count),
              'enforcement', v_directive.enforcement
            ));
          END IF;
        END IF;

      WHEN 'project_brief_exists' THEN
        -- Check: does a project brief exist for this project?
        IF v_project_code IS NOT NULL THEN
          IF NOT EXISTS (SELECT 1 FROM project_briefs WHERE code = v_project_code AND status = 'active') THEN
            IF v_directive.enforcement = 'hard' THEN
              v_violations := v_violations || jsonb_build_array(jsonb_build_object(
                'directive', v_directive.name,
                'check_key', v_directive.check_key,
                'message', format('No active project brief for %s - create one before implementation', v_project_code),
                'enforcement', 'hard'
              ));
            END IF;
          END IF;
        END IF;

      WHEN 'project_context_loaded' THEN
        -- This is checked at the application level (portal-chat loads context)
        -- Here we just verify a project_brief exists for the referenced project
        IF v_project_code IS NOT NULL THEN
          IF NOT EXISTS (SELECT 1 FROM project_briefs WHERE code = v_project_code) THEN
            v_warnings := v_warnings || jsonb_build_array(jsonb_build_object(
              'directive', v_directive.name,
              'check_key', v_directive.check_key,
              'message', format('Project %s not found - context cannot be loaded', v_project_code),
              'enforcement', v_directive.enforcement
            ));
          END IF;
        END IF;

      WHEN 'wo_only_for_builds' THEN
        -- This is enforced in portal-chat's shouldCreateWorkOrder logic
        -- Post-check: verify WOs aren't being created for non-build requests
        NULL; -- Application-level check

      WHEN 'check_connections_before_tools' THEN
        -- This is an application-level check (portal-chat should verify tool availability)
        NULL; -- Application-level check

      ELSE
        NULL; -- Unknown check_key, skip
    END CASE;
  END LOOP;

  RETURN jsonb_build_object(
    'compliant', jsonb_array_length(v_violations) = 0,
    'checks_run', v_checks_run,
    'violations', v_violations,
    'warnings', v_warnings,
    'check_point', p_check_point,
    'checked_at', now()
  );
END;
$$;


--
-- Name: check_doc_currency(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_doc_currency(p_project_id uuid DEFAULT '7558abf4-78d4-4ca2-a4dd-457f5b061e25'::uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_last_schema_change TIMESTAMPTZ;
  v_last_manifest_mutation TIMESTAMPTZ;
  v_last_system_change TIMESTAMPTZ;
  v_arch_doc_updated TIMESTAMPTZ;
  v_drift_detected BOOLEAN := false;
  v_drift_hours NUMERIC;
  v_details JSONB := '[]'::jsonb;
  v_row RECORD;
BEGIN
  SELECT max(created_at) INTO v_last_schema_change FROM schema_changes;
  SELECT max(created_at) INTO v_last_manifest_mutation FROM state_mutations WHERE target_table = 'system_manifest';
  v_last_system_change := greatest(v_last_schema_change, v_last_manifest_mutation);

  SELECT max(updated_at) INTO v_arch_doc_updated 
  FROM project_documents WHERE project_id = p_project_id AND doc_type = 'architecture';

  IF v_arch_doc_updated IS NULL THEN
    v_drift_detected := true;
    v_details := v_details || jsonb_build_object('issue', 'No architecture doc exists', 'severity', 'critical');
  ELSIF v_last_system_change > v_arch_doc_updated THEN
    v_drift_detected := true;
    v_drift_hours := extract(epoch FROM (v_last_system_change - v_arch_doc_updated)) / 3600.0;
    v_details := v_details || jsonb_build_object(
      'issue', 'Architecture doc behind system changes',
      'drift_hours', round(v_drift_hours::numeric, 1),
      'doc_updated_at', v_arch_doc_updated,
      'last_system_change', v_last_system_change,
      'severity', CASE WHEN v_drift_hours > 24 THEN 'warning' ELSE 'info' END
    );
  END IF;

  FOR v_row IN
    SELECT doc_type, updated_at FROM project_documents
    WHERE project_id = p_project_id AND doc_type IN ('state_machine', 'tech_stack')
    AND updated_at < v_last_system_change
  LOOP
    v_drift_detected := true;
    v_details := v_details || jsonb_build_object(
      'issue', v_row.doc_type || ' doc is stale', 'doc_type', v_row.doc_type,
      'doc_updated_at', v_row.updated_at, 'severity', 'info'
    );
  END LOOP;

  RETURN jsonb_build_object(
    'check', 'doc_currency', 'passed', NOT v_drift_detected, 'drift_detected', v_drift_detected,
    'last_doc_update', v_arch_doc_updated, 'last_system_change', v_last_system_change,
    'last_schema_change', v_last_schema_change, 'last_manifest_mutation', v_last_manifest_mutation,
    'details', v_details, 'checked_at', now()
  );
END;
$$;


--
-- Name: check_enforcer_schema_integrity(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_enforcer_schema_integrity() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_expected_tables TEXT[] := ARRAY[
    'work_orders',
    'work_order_execution_log',
    'audit_log',
    'state_mutations',
    'enforcer_runs',
    'enforcer_findings',
    'enforcer_canary_test'
  ];
  v_missing_tables TEXT[];
  v_result JSONB;
BEGIN
  -- Check for missing critical tables
  SELECT ARRAY_AGG(table_name)
  INTO v_missing_tables
  FROM UNNEST(v_expected_tables) AS table_name
  WHERE NOT EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema = 'public'
    AND table_name = table_name
  );

  -- Build result
  v_result := jsonb_build_object(
    'expected_tables', v_expected_tables,
    'missing_tables', COALESCE(v_missing_tables, ARRAY[]::TEXT[]),
    'has_drift', COALESCE(array_length(v_missing_tables, 1), 0) > 0
  );

  RETURN v_result;
END;
$$;


--
-- Name: check_lesson_acknowledgments_gate(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_lesson_acknowledgments_gate() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_unacked_count INT;
  v_lessons JSONB;
BEGIN
  -- Skip when called from wo_transition
  IF current_setting('app.wo_validation_bypass', true) = 'true' THEN
    RETURN NEW;
  END IF;

  IF NEW.status IN ('ready', 'in_progress') AND (OLD.status IS NULL OR OLD.status NOT IN ('ready', 'in_progress')) THEN
    SELECT count(*), jsonb_agg(jsonb_build_object('id', l.id, 'title', l.title))
    INTO v_unacked_count, v_lessons
    FROM get_relevant_lessons(NEW.id) l
    WHERE NOT EXISTS (
      SELECT 1 FROM lesson_acknowledgments la
      WHERE la.lesson_id = l.id AND la.work_order_id = NEW.id
    );

    IF v_unacked_count > 0 THEN
      INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
      VALUES (NEW.id, 'stream', 'lesson_gate',
        jsonb_build_object('warning', 'UNACKED_LESSONS', 'count', v_unacked_count, 'lessons', v_lessons));
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION check_lesson_acknowledgments_gate(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.check_lesson_acknowledgments_gate() IS 'AC2: Gate that blocks draft→ready transitions when domain-relevant unapplied lessons exist without acknowledgment';


--
-- Name: check_ops_heartbeat(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_ops_heartbeat() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_last_heartbeat timestamptz;
  v_age interval;
BEGIN
  SELECT (setting_value #>> '{}')::timestamptz INTO v_last_heartbeat
  FROM system_settings WHERE setting_key = 'ops_last_heartbeat';

  IF v_last_heartbeat IS NULL THEN
    INSERT INTO audit_log (event_type, agent_name, target_type, target_id, payload)
    VALUES ('ops_dead', 'meta-monitor', 'system', 'ops', '{"reason": "no heartbeat found"}'::jsonb);
    RETURN;
  END IF;

  v_age := now() - v_last_heartbeat;

  IF v_age > interval '90 minutes' THEN
    INSERT INTO audit_log (event_type, agent_name, target_type, target_id, payload)
    VALUES ('ops_dead', 'meta-monitor', 'system', 'ops', 
      jsonb_build_object('reason', 'heartbeat stale', 'last_heartbeat', v_last_heartbeat::text, 'age_minutes', EXTRACT(EPOCH FROM v_age) / 60));
  END IF;
END;
$$;


--
-- Name: check_pipeline_dependencies(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_pipeline_dependencies(p_pipeline_run_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_deps uuid[];
  v_blocking jsonb := '[]'::jsonb;
  v_dep_id uuid;
  v_dep_record record;
BEGIN
  SELECT depends_on_pipeline_ids INTO v_deps
  FROM pipeline_runs WHERE id = p_pipeline_run_id;

  IF v_deps IS NULL OR array_length(v_deps, 1) IS NULL THEN
    RETURN jsonb_build_object('satisfied', true, 'blocking', '[]'::jsonb);
  END IF;

  FOREACH v_dep_id IN ARRAY v_deps LOOP
    SELECT pr.id, pr.status, wo.slug as spec_wo_slug
    INTO v_dep_record
    FROM pipeline_runs pr
    LEFT JOIN work_orders wo ON wo.id = pr.spec_wo_id
    WHERE pr.id = v_dep_id;

    IF v_dep_record.status IS NULL OR v_dep_record.status != 'completed' THEN
      v_blocking := v_blocking || jsonb_build_array(jsonb_build_object(
        'id', v_dep_id,
        'status', COALESCE(v_dep_record.status, 'not_found'),
        'spec_wo_slug', COALESCE(v_dep_record.spec_wo_slug, 'unknown')
      ));
    END IF;
  END LOOP;

  RETURN jsonb_build_object(
    'satisfied', jsonb_array_length(v_blocking) = 0,
    'blocking', v_blocking
  );
END;
$$;


--
-- Name: check_pre_execution_invariant(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_pre_execution_invariant(p_wo jsonb) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_pre_exec_gate_enabled boolean;
  v_wo_id uuid;
  v_gate_result jsonb;
  v_tags text[];
BEGIN
  v_pre_exec_gate_enabled := COALESCE(
    (SELECT (setting_value->>'value')::boolean FROM system_settings WHERE setting_key = 'pre_execution_gate_enabled'),
    true
  );

  IF NOT v_pre_exec_gate_enabled THEN
    RETURN true;
  END IF;

  v_wo_id := (p_wo->>'id')::uuid;
  IF v_wo_id IS NULL THEN
    v_wo_id := (p_wo->>'work_order_id')::uuid;
  END IF;

  IF v_wo_id IS NULL THEN
    RETURN true;  -- No WO ID to check
  END IF;

  -- Exempt remediation and pipeline-phase WOs
  SELECT tags INTO v_tags FROM work_orders WHERE id = v_wo_id;
  IF 'remediation' = ANY(COALESCE(v_tags, ARRAY[]::text[])) OR
     'pipeline-phase' = ANY(COALESCE(v_tags, ARRAY[]::text[])) THEN
    RETURN true;
  END IF;

  v_gate_result := run_pre_execution_gate(v_wo_id);
  RETURN COALESCE((v_gate_result->>'passed')::boolean, false);
END;
$$;


--
-- Name: check_project_intake_ready(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_project_intake_ready(p_project_id uuid) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_total INTEGER;
  v_generated INTEGER;
  v_required INTEGER := 8;  -- 8 doc types in framework
  v_missing TEXT[];
BEGIN
  IF p_project_id IS NULL THEN
    RETURN jsonb_build_object('ready', false, 'reason', 'No project_id provided');
  END IF;

  SELECT COUNT(*) INTO v_total
  FROM project_documents WHERE project_id = p_project_id;

  SELECT COUNT(*) INTO v_generated
  FROM project_documents 
  WHERE project_id = p_project_id 
  AND status IN ('generated', 'approved');

  SELECT ARRAY(
    SELECT unnest(ARRAY['prd','app_flow','tech_stack','frontend_guidelines','backend_structure','implementation_plan','security_model','testing_strategy'])
    EXCEPT
    SELECT doc_type FROM project_documents 
    WHERE project_id = p_project_id 
    AND status IN ('generated', 'approved')
  ) INTO v_missing;

  RETURN jsonb_build_object(
    'ready', v_generated >= v_required,
    'total_docs', v_total,
    'generated_or_approved', v_generated,
    'required', v_required,
    'missing_doc_types', v_missing,
    'project_id', p_project_id
  );
END;
$$;


--
-- Name: check_rate_limit(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_rate_limit(p_agent_id uuid, p_quota_type text DEFAULT 'requests_per_minute'::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_quota RECORD;
  v_window_duration INTERVAL;
  v_allowed BOOLEAN;
BEGIN
  -- Get quota config
  SELECT * INTO v_quota FROM agent_quotas 
  WHERE agent_id = p_agent_id AND quota_type = p_quota_type AND enabled = true;
  
  IF NOT FOUND THEN
    -- No quota configured = unlimited
    RETURN jsonb_build_object('allowed', true, 'reason', 'no_quota_configured');
  END IF;
  
  -- Determine window duration
  v_window_duration := CASE p_quota_type
    WHEN 'requests_per_minute' THEN INTERVAL '1 minute'
    WHEN 'requests_per_hour' THEN INTERVAL '1 hour'
    WHEN 'mutations_per_hour' THEN INTERVAL '1 hour'
    WHEN 'llm_tokens_per_day' THEN INTERVAL '1 day'
    ELSE INTERVAL '1 minute'
  END;
  
  -- Reset window if expired
  IF v_quota.window_start + v_window_duration < now() THEN
    UPDATE agent_quotas 
    SET current_value = 0, window_start = now()
    WHERE id = v_quota.id;
    v_quota.current_value := 0;
  END IF;
  
  -- Check limit
  v_allowed := v_quota.current_value < v_quota.limit_value;
  
  -- Increment counter
  IF v_allowed THEN
    UPDATE agent_quotas SET current_value = current_value + 1 WHERE id = v_quota.id;
  END IF;
  
  -- Log the check
  INSERT INTO rate_limit_log (agent_id, quota_type, allowed, current_count, limit_value)
  VALUES (p_agent_id, p_quota_type, v_allowed, v_quota.current_value, v_quota.limit_value);
  
  RETURN jsonb_build_object(
    'allowed', v_allowed,
    'current', v_quota.current_value,
    'limit', v_quota.limit_value,
    'remaining', GREATEST(0, v_quota.limit_value - v_quota.current_value - 1),
    'resets_at', v_quota.window_start + v_window_duration,
    'retry_after', CASE WHEN NOT v_allowed 
      THEN EXTRACT(EPOCH FROM (v_quota.window_start + v_window_duration - now()))::int
      ELSE NULL END
  );
END;
$$;


--
-- Name: check_recurring_error_pattern(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_recurring_error_pattern() RETURNS TABLE(error_code text, occurrences bigint, first_seen timestamp with time zone, last_seen timestamp with time zone, recent_context text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  WITH error_counts AS (
    SELECT 
      coalesce(payload->>'error_code', payload->'error_codes'->>0, 'unknown') as code,
      count(*) as cnt,
      min(created_at) as first_ts,
      max(created_at) as last_ts
    FROM audit_log
    WHERE event_type = 'wo_transition_rejected'
      AND created_at >= now() - interval '7 days'
    GROUP BY coalesce(payload->>'error_code', payload->'error_codes'->>0, 'unknown')
    HAVING count(*) >= 3
  ),
  recent_messages AS (
    SELECT 
      code,
      string_agg(
        format('%s: %s', 
          to_char(created_at, 'YYYY-MM-DD HH24:MI'),
          coalesce(payload->'errors'->0->>'message', payload->>'errors', 'No message')
        ), 
        E'\n'
        ORDER BY created_at DESC
      ) as context
    FROM (
      SELECT 
        coalesce(payload->>'error_code', payload->'error_codes'->>0, 'unknown') as code,
        created_at,
        payload
      FROM audit_log
      WHERE event_type = 'wo_transition_rejected'
        AND created_at >= now() - interval '7 days'
      ORDER BY created_at DESC
      LIMIT 5
    ) recent
    GROUP BY code
  )
  SELECT 
    ec.code,
    ec.cnt,
    ec.first_ts,
    ec.last_ts,
    rm.context
  FROM error_counts ec
  LEFT JOIN recent_messages rm ON ec.code = rm.code
  ORDER BY ec.cnt DESC, ec.last_ts DESC;
END;
$$;


--
-- Name: check_remediation_qa_tools_invariant(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_remediation_qa_tools_invariant(p_wo jsonb) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_wo_id uuid;
BEGIN
  v_wo_id := (p_wo->>'id')::uuid;
  IF v_wo_id IS NULL THEN
    v_wo_id := (p_wo->>'work_order_id')::uuid;
  END IF;

  IF v_wo_id IS NULL THEN
    RETURN true;
  END IF;

  RETURN guard_remediation_qa_tools(v_wo_id);
END;
$$;


--
-- Name: check_retry_limit_invariant(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_retry_limit_invariant(p_wo jsonb) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_retry_count int;
  v_max_retries int;
BEGIN
  v_retry_count := COALESCE((p_wo->>'retry_count')::int, 0);
  v_max_retries := COALESCE((p_wo->>'max_retries')::int, 3);
  RETURN v_retry_count < v_max_retries;
END;
$$;


--
-- Name: check_stale_wo_events(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_stale_wo_events() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_stale_event RECORD;
  v_event_id uuid;
  v_age interval;
  v_count integer := 0;
BEGIN
  -- Query stale pending wo_events (older than 5 minutes)
  FOR v_stale_event IN
    SELECT id, created_at
    FROM wo_events
    WHERE status = 'pending'
      AND created_at < now() - interval '5 minutes'
  LOOP
    -- Calculate age
    v_age := now() - v_stale_event.created_at;
    v_event_id := v_stale_event.id;
    
    -- Insert into error_events
    INSERT INTO error_events (
      id,
      severity,
      source_function,
      error_code,
      message,
      context,
      created_at
    ) VALUES (
      gen_random_uuid(),
      'warning',
      'check_stale_wo_events',
      'STALE_EVENT',
      format('Stale wo_event detected: %s has been pending for %s', v_event_id, v_age),
      jsonb_build_object(
        'event_id', v_event_id,
        'age_minutes', extract(epoch from v_age) / 60,
        'checked_at', now()
      ),
      now()
    );
    
    v_count := v_count + 1;
  END LOOP;
  
  RETURN v_count;
END;
$$;


--
-- Name: check_transition_approval(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_transition_approval(p_work_order_id uuid, p_action_pattern text) RETURNS boolean
    LANGUAGE sql STABLE
    AS $$
  SELECT EXISTS(
    SELECT 1 FROM audit_log
    WHERE target_type = 'work_order'
    AND target_id = p_work_order_id
    AND action ILIKE p_action_pattern
    AND actor_type = 'user'
    AND created_at >= NOW() - INTERVAL '5 minutes'
  );
$$;


--
-- Name: FUNCTION check_transition_approval(p_work_order_id uuid, p_action_pattern text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.check_transition_approval(p_work_order_id uuid, p_action_pattern text) IS 'Checks if human approval exists for a WO transition in the last 5 minutes';


--
-- Name: check_wo_approval(uuid, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_wo_approval(p_work_order_id uuid, p_old_status text, p_new_status text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_approval_record record;
BEGIN
  -- System bypass (set by triggers like settle_children_on_parent_terminal)
  -- WO-0399: Also require trigger context for bypass
  -- COALESCE handles NULL (config never set)
  IF current_setting('app.wo_executor_bypass', true) = 'true'
     AND COALESCE(current_setting('app.wo_trigger_context', true), '') = 'true' THEN
    RETURN jsonb_build_object('approved', true, 'reason', 'system_bypass');
  END IF;

  -- UNRESTRICTED: Normal execution flow (no approval needed)
  IF p_old_status = 'in_progress' AND p_new_status IN ('review', 'failed') THEN
    RETURN jsonb_build_object('approved', true, 'reason', 'normal_execution_flow');
  END IF;

  IF (p_old_status = 'draft' AND p_new_status IN ('ready', 'pending_approval')) OR
     (p_old_status = 'ready' AND p_new_status = 'in_progress') OR
     (p_old_status = 'pending_approval' AND p_new_status = 'ready') OR
     (p_old_status = 'review' AND p_new_status = 'in_progress') OR
     (p_old_status = 'blocked' AND p_new_status IN ('in_progress', 'draft')) OR
     (p_old_status = 'failed' AND p_new_status = 'draft') THEN
    RETURN jsonb_build_object('approved', true, 'reason', 'normal_execution_flow');
  END IF;

  -- HARD BLOCKED: failed->done shortcut (AC4)
  IF p_old_status = 'failed' AND p_new_status = 'done' THEN
    RETURN jsonb_build_object('approved', false, 
      'reason', 'failed_to_done_blocked',
      'help', 'Must restart lifecycle: failed->draft->ready->in_progress->review->done');
  END IF;

  -- RESTRICTED: Cancellation requires user approval (AC3)
  IF p_new_status = 'cancelled' THEN
    SELECT INTO v_approval_record *
    FROM audit_log
    WHERE target_id = p_work_order_id
      AND actor_type = 'user'
      AND created_at > NOW() - INTERVAL '5 minutes'
    ORDER BY created_at DESC
    LIMIT 1;
    
    IF v_approval_record.id IS NOT NULL THEN
      RETURN jsonb_build_object('approved', true, 'reason', 'user_approval_found', 'audit_id', v_approval_record.id);
    ELSE
      RETURN jsonb_build_object('approved', false, 'reason', 'cancellation_requires_user_approval');
    END IF;
  END IF;

  -- RESTRICTED: review->done manual close
  IF p_old_status = 'review' AND p_new_status = 'done' THEN
    SELECT INTO v_approval_record *
    FROM audit_log
    WHERE target_id = p_work_order_id
      AND actor_type IN ('user', 'system')
      AND created_at > NOW() - INTERVAL '5 minutes'
    ORDER BY created_at DESC
    LIMIT 1;
    
    IF v_approval_record.id IS NOT NULL THEN
      RETURN jsonb_build_object('approved', true, 'reason', 'approval_found', 'audit_id', v_approval_record.id);
    ELSE
      RETURN jsonb_build_object('approved', false, 'reason', 'review_to_done_requires_approval');
    END IF;
  END IF;

  -- RESTRICTED: Resurrecting cancelled WOs
  IF p_old_status = 'cancelled' AND p_new_status = 'draft' THEN
    SELECT INTO v_approval_record *
    FROM audit_log
    WHERE target_id = p_work_order_id
      AND actor_type = 'user'
      AND created_at > NOW() - INTERVAL '5 minutes'
    ORDER BY created_at DESC
    LIMIT 1;
    
    IF v_approval_record.id IS NOT NULL THEN
      RETURN jsonb_build_object('approved', true, 'reason', 'user_approval_found', 'audit_id', v_approval_record.id);
    ELSE
      RETURN jsonb_build_object('approved', false, 'reason', 'resurrection_requires_user_approval');
    END IF;
  END IF;

  -- DEFAULT: Any other transition requires approval record
  SELECT INTO v_approval_record *
  FROM audit_log
  WHERE target_id = p_work_order_id
    AND actor_type IN ('user', 'system')
    AND created_at > NOW() - INTERVAL '5 minutes'
  ORDER BY created_at DESC
  LIMIT 1;
  
  IF v_approval_record.id IS NOT NULL THEN
    RETURN jsonb_build_object('approved', true, 'reason', 'approval_found', 'audit_id', v_approval_record.id);
  END IF;
  
  RETURN jsonb_build_object('approved', false, 
    'reason', format('transition_%s_to_%s_requires_approval', p_old_status, p_new_status));
END;
$$;


--
-- Name: check_wo_approval(uuid, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_wo_approval(p_work_order_id uuid, p_old_status text, p_new_status text, p_calling_agent text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_approval_record record;
BEGIN
  -- Allow self-submit (in_progress → review)
  IF p_old_status = 'in_progress' AND p_new_status = 'review' THEN
    RETURN jsonb_build_object('approved', true, 'reason', 'self_submit_allowed');
  END IF;
  
  -- Cancellation ALWAYS requires human approval
  IF p_new_status = 'cancelled' THEN
    SELECT INTO v_approval_record *
    FROM audit_log
    WHERE target_id = p_work_order_id
      AND actor_type = 'human'
      AND (action ILIKE '%cancel%' OR action ILIKE '%approve%')
      AND created_at > NOW() - INTERVAL '5 minutes'
    ORDER BY created_at DESC
    LIMIT 1;
    
    IF v_approval_record.id IS NOT NULL THEN
      RETURN jsonb_build_object('approved', true, 'reason', 'human_approval_found', 'audit_id', v_approval_record.id);
    ELSE
      RETURN jsonb_build_object('approved', false, 'reason', 'cancellation_requires_human_approval');
    END IF;
  END IF;
  
  -- Block failed → done shortcut (must go through full lifecycle)
  IF p_old_status = 'failed' AND p_new_status = 'done' THEN
    RETURN jsonb_build_object('approved', false, 'reason', 'failed_to_done_shortcut_blocked_must_restart_lifecycle');
  END IF;
  
  -- For other master agent transitions, require approval record
  SELECT INTO v_approval_record *
  FROM audit_log
  WHERE target_id = p_work_order_id
    AND actor_type IN ('human', 'system')
    AND (action ILIKE '%approve%' OR event_type ILIKE '%approve%')
    AND created_at > NOW() - INTERVAL '5 minutes'
  ORDER BY created_at DESC
  LIMIT 1;
  
  IF v_approval_record.id IS NOT NULL THEN
    RETURN jsonb_build_object('approved', true, 'reason', 'approval_record_found', 'audit_id', v_approval_record.id);
  END IF;
  
  -- No approval found
  RETURN jsonb_build_object('approved', false, 'reason', 'no_recent_approval_record_within_5min');
END;
$$;


--
-- Name: check_wo_directive_compliance(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_wo_directive_compliance(p_work_order_id uuid, p_target_status text) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_wo RECORD;
  v_project_code TEXT;
  v_result JSONB;
BEGIN
  -- Only check on transitions to in_progress (execution start)
  IF p_target_status != 'in_progress' THEN
    RETURN jsonb_build_object('compliant', true, 'skipped', true, 'reason', 'Only checked on in_progress transitions');
  END IF;

  -- Get WO details
  SELECT wo.*, pb.code as project_code
  INTO v_wo
  FROM work_orders wo
  LEFT JOIN project_briefs pb ON wo.project_brief_id = pb.id
  WHERE wo.id = p_work_order_id;

  IF v_wo IS NULL THEN
    RETURN jsonb_build_object('compliant', true, 'skipped', true, 'reason', 'Work order not found');
  END IF;

  v_project_code := COALESCE(v_wo.project_code, 'ENDGAME-001');

  -- Run directive compliance check
  v_result := check_directive_compliance(
    'pre_wo_transition',
    jsonb_build_object('project_code', v_project_code, 'work_order_id', p_work_order_id)
  );

  RETURN v_result;
END;
$$;


--
-- Name: check_wo_liveness(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_wo_liveness(p_wo_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_wo record;
  v_last_activity timestamptz;
  v_age interval;
BEGIN
  SELECT * INTO v_wo FROM work_orders WHERE id = p_wo_id;
  IF v_wo.id IS NULL THEN
    RETURN jsonb_build_object('action', 'none', 'reason', 'WO not found');
  END IF;
  IF v_wo.status != 'in_progress' THEN
    RETURN jsonb_build_object('action', 'none', 'reason', 'WO not in_progress, status=' || v_wo.status);
  END IF;
  
  SELECT GREATEST(
    COALESCE((SELECT MAX(created_at) FROM work_order_execution_log WHERE work_order_id = p_wo_id), '1970-01-01'::timestamptz),
    COALESCE((SELECT MAX(created_at) FROM wo_mutations WHERE work_order_id = p_wo_id), '1970-01-01'::timestamptz),
    COALESCE(v_wo.started_at, v_wo.updated_at, '1970-01-01'::timestamptz)
  ) INTO v_last_activity;
  
  v_age := now() - v_last_activity;
  
  IF v_age > interval '5 minutes' THEN
    PERFORM wo_transition(p_wo_id, 'mark_failed',
      jsonb_build_object('failure_reason', 'Dead-man switch: no activity for ' || EXTRACT(EPOCH FROM v_age)::int || 's',
        'last_activity', v_last_activity::text, 'detected_by', 'check_wo_liveness'),
      'ops');
    RETURN jsonb_build_object('action', 'marked_failed', 'age_seconds', EXTRACT(EPOCH FROM v_age)::int);
  END IF;
  RETURN jsonb_build_object('action', 'none', 'reason', 'WO still active', 'age_seconds', EXTRACT(EPOCH FROM v_age)::int);
END;
$$;


--
-- Name: check_wo_needs_interrogation(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_wo_needs_interrogation(p_work_order_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_wo work_orders;
  v_project project_briefs;
  v_has_context BOOLEAN;
BEGIN
  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  
  IF v_wo.id IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Check if project has sufficient context
  IF v_wo.project_brief_id IS NOT NULL THEN
    SELECT * INTO v_project FROM project_briefs WHERE id = v_wo.project_brief_id;
    
    -- Check if project has docs
    SELECT EXISTS (
      SELECT 1 FROM project_documents WHERE project_id = v_project.id
    ) INTO v_has_context;
    
    IF NOT v_has_context AND v_wo.complexity IN ('large', 'unknown') THEN
      -- Log suggestion
      INSERT INTO trace_events (
        trace_id, event_type, name, level, payload
      )
      SELECT 
        current_setting('app.current_trace_id', true),
        'annotation',
        'interrogation_suggested',
        'warn',
        jsonb_build_object(
          'work_order_id', p_work_order_id,
          'reason', 'Complex WO without project documentation',
          'suggestion', 'Run /interrogate before execution'
        )
      WHERE current_setting('app.current_trace_id', true) IS NOT NULL 
        AND current_setting('app.current_trace_id', true) != '';
      
      RETURN TRUE;
    END IF;
  END IF;
  
  RETURN FALSE;
END;
$$;


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: wo_events; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wo_events (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid,
    event_type text NOT NULL,
    previous_status text,
    new_status text,
    payload jsonb DEFAULT '{}'::jsonb,
    actor text NOT NULL,
    depth integer DEFAULT 0,
    status text DEFAULT 'pending'::text,
    retry_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    processed_at timestamp with time zone,
    error_detail text,
    CONSTRAINT wo_events_event_type_check CHECK ((event_type = ANY (ARRAY['status_changed'::text, 'created'::text, 'approved'::text, 'rejected'::text, 'assigned'::text, 'comment_added'::text, 'attachment_added'::text, 'start_work'::text, 'submit_for_review'::text, 'mark_done'::text, 'mark_failed'::text, 'report_blocked'::text, 'request_retry'::text, 'qa_passed'::text, 'qa_failed'::text, 'approve'::text, 'cancel'::text, 'submit_for_planning'::text, 'complete_planning'::text, 'unblock'::text, 'retry'::text, 'reopen'::text, 'pre_execution_gate'::text, 'pipeline_phase_advanced'::text, 'pipeline_dispatch'::text]))),
    CONSTRAINT wo_events_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'done'::text, 'failed'::text])))
);


--
-- Name: TABLE wo_events; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.wo_events IS 'Outbox table for state machine event sourcing. Records all state transitions for audit and replay.';


--
-- Name: claim_pending_events(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.claim_pending_events(p_batch_size integer DEFAULT 10) RETURNS SETOF public.wo_events
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  UPDATE wo_events
  SET 
    status = 'processing',
    processed_at = now()
  WHERE id IN (
    SELECT id 
    FROM wo_events 
    WHERE status = 'pending' 
    ORDER BY created_at 
    LIMIT p_batch_size 
    FOR UPDATE SKIP LOCKED
  )
  RETURNING *;
END;
$$;


--
-- Name: claim_work_order(text, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.claim_work_order(p_agent_name text, p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_agent_id UUID;
  v_current_status TEXT;
  v_current_assigned UUID;
  v_lock_result JSONB;
  v_wo_updated_at TIMESTAMPTZ;
  v_wo_created_at TIMESTAMPTZ;
  v_project_brief_id UUID;
  v_freshness_check_result JSONB;
  v_is_fresh BOOLEAN := true;
  v_freshness_issues TEXT[] := ARRAY[]::TEXT[];
BEGIN
  -- Get agent
  SELECT id INTO v_agent_id FROM agents WHERE name = p_agent_name AND status = 'active';
  IF v_agent_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Agent not found or inactive');
  END IF;
  
  -- Check work order exists and get metadata for freshness check
  SELECT status, assigned_to, updated_at, created_at, project_brief_id 
  INTO v_current_status, v_current_assigned, v_wo_updated_at, v_wo_created_at, v_project_brief_id
  FROM work_orders WHERE id = p_work_order_id;
  
  IF v_current_status IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Work order not found');
  END IF;
  
  -- FRESHNESS CHECK: Validate work order currency
  -- Check 1: Work order must have been updated in the last 30 days
  IF v_wo_updated_at < (NOW() - INTERVAL '30 days') THEN
    v_is_fresh := false;
    v_freshness_issues := array_append(v_freshness_issues, 
      'Work order has not been updated in over 30 days');
  END IF;
  
  -- Check 2: If project-scoped, verify project intake is complete
  IF v_project_brief_id IS NOT NULL THEN
    DECLARE
      v_intake_status TEXT;
    BEGIN
      SELECT intake_status INTO v_intake_status 
      FROM project_briefs 
      WHERE id = v_project_brief_id;
      
      IF v_intake_status IS NULL OR v_intake_status != 'complete' THEN
        v_is_fresh := false;
        v_freshness_issues := array_append(v_freshness_issues, 
          'Project intake is not complete');
      END IF;
    END;
  END IF;
  
  -- Check 3: Work order must not be too old (created > 90 days ago without updates)
  IF v_wo_created_at < (NOW() - INTERVAL '90 days') AND 
     v_wo_updated_at = v_wo_created_at THEN
    v_is_fresh := false;
    v_freshness_issues := array_append(v_freshness_issues, 
      'Work order is stale (created over 90 days ago with no updates)');
  END IF;
  
  -- Build freshness check result
  v_freshness_check_result := jsonb_build_object(
    'is_fresh', v_is_fresh,
    'checked_at', NOW(),
    'work_order_id', p_work_order_id,
    'updated_at', v_wo_updated_at,
    'created_at', v_wo_created_at,
    'issues', v_freshness_issues
  );
  
  -- Log freshness check to execution_log
  INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
  VALUES (
    p_work_order_id, 
    'freshness_check', 
    p_agent_name,
    v_freshness_check_result
  );
  
  -- Log to audit_log
  INSERT INTO audit_log (
    event_type, 
    actor_type, 
    actor_id, 
    target_type, 
    target_id,
    action,
    payload
  ) VALUES (
    'wo_freshness_check',
    'agent',
    v_agent_id::text,
    'work_order',
    p_work_order_id,
    'claim_freshness_validation',
    v_freshness_check_result
  );
  
  -- If not fresh, return 422 equivalent (success=false with freshness_check_blocked)
  IF NOT v_is_fresh THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'Work order failed freshness check',
      'freshness_check_blocked', true,
      'freshness_check', v_freshness_check_result
    );
  END IF;
  
  -- Continue with existing claim logic if fresh
  IF v_current_status NOT IN ('draft', 'ready') THEN
    RETURN jsonb_build_object('success', false, 'error', 'Work order not claimable', 'current_status', v_current_status);
  END IF;
  
  IF v_current_assigned IS NOT NULL AND v_current_assigned != v_agent_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Work order assigned to another agent');
  END IF;
  
  -- Acquire exclusive lock
  v_lock_result := acquire_lock(p_agent_name, 'work_order', p_work_order_id::text, 'exclusive', 60, 'Claimed for execution');
  IF NOT (v_lock_result->>'success')::boolean THEN
    RETURN v_lock_result;
  END IF;
  
  -- Update work order
  UPDATE work_orders 
  SET status = 'in_progress', 
      assigned_to = v_agent_id,
      started_at = COALESCE(started_at, now()),
      updated_at = now()
  WHERE id = p_work_order_id;
  
  -- Log event
  INSERT INTO workspace_events (agent_id, event_type, work_order_id, payload)
  VALUES (v_agent_id, 'claimed', p_work_order_id, jsonb_build_object('claimed_at', now()));
  
  RETURN jsonb_build_object(
    'success', true, 
    'work_order_id', p_work_order_id, 
    'lock_id', v_lock_result->>'lock_id',
    'freshness_check', v_freshness_check_result
  );
END;
$$;


--
-- Name: cleanup_expired_sessions(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_expired_sessions() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_count INT;
BEGIN
  DELETE FROM active_sessions WHERE expires_at < now();
  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;


--
-- Name: cleanup_stale_approvals(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_stale_approvals() RETURNS TABLE(approval_id uuid, wo_slug text, wo_status public.work_order_status, gate_name text)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  UPDATE approval_queue aq
  SET 
    status = 'expired',
    decided_by = 'system_manual_cleanup',
    decided_at = NOW(),
    decision_notes = 'Manual cleanup: work order already in terminal state'
  FROM work_orders wo
  WHERE 
    aq.work_order_id = wo.id
    AND aq.status = 'pending'
    AND wo.status IN ('done', 'cancelled', 'failed')
  RETURNING 
    aq.id as approval_id,
    wo.slug as wo_slug,
    wo.status as wo_status,
    (SELECT name FROM decision_gates WHERE id = aq.gate_id) as gate_name;
END;
$$;


--
-- Name: FUNCTION cleanup_stale_approvals(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.cleanup_stale_approvals() IS 'Manually cleanup stale pending approvals for work orders already in terminal states';


--
-- Name: close_parent_wo_via_remediation(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.close_parent_wo_via_remediation(p_parent_id uuid, p_remediation_slug text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_parent_slug TEXT;
  v_parent_status TEXT;
BEGIN
  SELECT slug, status INTO v_parent_slug, v_parent_status
  FROM work_orders WHERE id = p_parent_id;

  IF v_parent_status = 'failed' THEN
    -- Use proper RPC for state transition
    PERFORM update_work_order_state(
      p_work_order_id := p_parent_id,
      p_status := 'done',
      p_completed_at := now(),
      p_summary := format('Completed via remediation %s', p_remediation_slug)
    );

    -- Log the auto-close
    INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
    VALUES (
      'parent_auto_closed', 
      'system', 
      'close_parent_wo_via_remediation',
      'work_order', 
      p_parent_id,
      format('Parent %s auto-closed by remediation %s', v_parent_slug, p_remediation_slug),
      jsonb_build_object(
        'parent_slug', v_parent_slug, 
        'remediation_slug', p_remediation_slug, 
        'parent_old_status', 'failed'
      )
    );
  END IF;
END;
$$;


--
-- Name: close_pending_approvals_for_wo(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.close_pending_approvals_for_wo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- If WO transitions to a terminal state (done, cancelled, failed)
  -- then close any pending approvals with status 'expired'
  IF NEW.status IN ('done', 'cancelled', 'failed') AND OLD.status != NEW.status THEN
    UPDATE approval_queue
    SET 
      status = 'expired',
      decided_by = 'system_auto_cleanup',
      decided_at = NOW(),
      decision_notes = 'Auto-expired: work order reached terminal state ' || NEW.status
    WHERE 
      work_order_id = NEW.id 
      AND status = 'pending';
    
    -- Log the cleanup action
    INSERT INTO audit_log (
      event_type,
      actor_type,
      actor_id,
      target_type,
      target_id,
      action,
      payload
    ) VALUES (
      'approval_cleanup',
      'system',
      'close_pending_approvals_trigger',
      'work_order',
      NEW.id,
      'expire_pending_approvals',
      jsonb_build_object(
        'wo_slug', NEW.slug,
        'wo_status', NEW.status,
        'reason', 'Work order reached terminal state'
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION close_pending_approvals_for_wo(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.close_pending_approvals_for_wo() IS 'Trigger function to automatically expire pending approvals when WO reaches terminal state';


--
-- Name: collect_platform_snapshot(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.collect_platform_snapshot(p_triggered_by text DEFAULT 'manual'::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  new_snapshot_id UUID;
BEGIN
  INSERT INTO platform_health_snapshots (
    snapshot_at,
    wo_total,
    wo_done,
    wo_cancelled,
    wo_cancel_rate_pct,
    wo_in_flight,
    qa_findings_total,
    qa_pass_count,
    qa_fail_count,
    qa_pass_rate_pct,
    verification_total,
    verification_passed,
    verification_pass_rate_pct,
    enforcer_runs_total,
    enforcer_findings_total,
    enforcer_coverage_pct,
    lessons_total,
    lessons_applied,
    lesson_application_rate_pct,
    auto_approval_attempted,
    auto_approval_succeeded,
    auto_approval_success_rate_pct,
    edge_functions_total,
    edge_functions_jwt_enabled,
    jwt_coverage_pct,
    total_tokens_consumed,
    total_cost_usd,
    dead_tables_count,
    triggered_by
  )
  SELECT
    NOW() AS snapshot_at,
    COALESCE((SELECT COUNT(*) FROM work_orders), 0) AS wo_total,
    COALESCE((SELECT COUNT(*) FROM work_orders WHERE status = 'done'), 0) AS wo_done,
    COALESCE((SELECT COUNT(*) FROM work_orders WHERE status = 'cancelled'), 0) AS wo_cancelled,
    CASE 
      WHEN COALESCE((SELECT COUNT(*) FROM work_orders), 0) > 0 
      THEN ROUND(100.0 * COALESCE((SELECT COUNT(*) FROM work_orders WHERE status = 'cancelled'), 0) / COALESCE((SELECT COUNT(*) FROM work_orders), 0), 1)
      ELSE 0
    END AS wo_cancel_rate_pct,
    COALESCE((SELECT COUNT(*) FROM work_orders WHERE status IN ('in_progress', 'review', 'blocked', 'pending_approval')), 0) AS wo_in_flight,
    COALESCE((SELECT COUNT(*) FROM qa_findings), 0) AS qa_findings_total,
    COALESCE((SELECT COUNT(*) FROM qa_findings WHERE finding_type = 'pass'), 0) AS qa_pass_count,
    COALESCE((SELECT COUNT(*) FROM qa_findings WHERE finding_type = 'fail'), 0) AS qa_fail_count,
    CASE 
      WHEN COALESCE((SELECT COUNT(*) FROM qa_findings), 0) > 0 
      THEN ROUND(100.0 * COALESCE((SELECT COUNT(*) FROM qa_findings WHERE finding_type = 'pass'), 0) / COALESCE((SELECT COUNT(*) FROM qa_findings), 0), 1)
      ELSE 0
    END AS qa_pass_rate_pct,
    0 AS verification_total,
    0 AS verification_passed,
    0 AS verification_pass_rate_pct,
    0 AS enforcer_runs_total,
    0 AS enforcer_findings_total,
    0 AS enforcer_coverage_pct,
    COALESCE((SELECT COUNT(*) FROM lessons), 0) AS lessons_total,
    COALESCE((SELECT COUNT(*) FROM lessons WHERE applied_to_directives = true), 0) AS lessons_applied,
    CASE 
      WHEN COALESCE((SELECT COUNT(*) FROM lessons), 0) > 0 
      THEN ROUND(100.0 * COALESCE((SELECT COUNT(*) FROM lessons WHERE applied_to_directives = true), 0) / COALESCE((SELECT COUNT(*) FROM lessons), 0), 1)
      ELSE 0
    END AS lesson_application_rate_pct,
    0 AS auto_approval_attempted,
    0 AS auto_approval_succeeded,
    0 AS auto_approval_success_rate_pct,
    0 AS edge_functions_total,
    0 AS edge_functions_jwt_enabled,
    0 AS jwt_coverage_pct,
    0 AS total_tokens_consumed,
    0 AS total_cost_usd,
    0 AS dead_tables_count,
    p_triggered_by AS triggered_by
  RETURNING id INTO new_snapshot_id;
  
  RETURN new_snapshot_id;
END;
$$;


--
-- Name: compare_manifest_to_mutations(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.compare_manifest_to_mutations(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_result jsonb;
  v_matched jsonb;
  v_missing jsonb;
  v_failed jsonb;
  v_discovered jsonb;
  v_total_required int;
  v_matched_count int;
  v_missing_count int;
  v_failed_count int;
  v_discovered_count int;
  v_match_confidence numeric;
  v_verdict text;
BEGIN
  -- Get matched: manifest expected_tool = mutation tool_name AND expected_object_id = mutation object_id AND success = true
  SELECT jsonb_agg(
    jsonb_build_object(
      'manifest_id', m.id,
      'ac_number', m.ac_number,
      'step_order', m.step_order,
      'expected_tool', m.expected_tool,
      'expected_object_id', m.expected_object_id,
      'mutation_id', wm.id
    )
  ) INTO v_matched
  FROM wo_execution_manifest m
  JOIN wo_mutations wm ON m.work_order_id = wm.work_order_id 
    AND m.expected_tool = wm.tool_name 
    AND m.expected_object_id = wm.object_id
    AND wm.success = true
  WHERE m.work_order_id = p_work_order_id;

  -- Get missing: required=true manifest steps with zero corresponding mutations
  SELECT jsonb_agg(
    jsonb_build_object(
      'manifest_id', m.id,
      'ac_number', m.ac_number,
      'step_order', m.step_order,
      'expected_tool', m.expected_tool,
      'expected_action', m.expected_action,
      'expected_object_type', m.expected_object_type,
      'expected_object_id', m.expected_object_id
    )
  ) INTO v_missing
  FROM wo_execution_manifest m
  WHERE m.work_order_id = p_work_order_id
    AND m.required = true
    AND NOT EXISTS (
      SELECT 1 FROM wo_mutations wm 
      WHERE wm.work_order_id = m.work_order_id 
        AND wm.tool_name = m.expected_tool 
        AND wm.object_id = m.expected_object_id
    );

  -- Get failed: manifest steps with corresponding mutations that have success=false
  SELECT jsonb_agg(
    jsonb_build_object(
      'manifest_id', m.id,
      'ac_number', m.ac_number,
      'step_order', m.step_order,
      'expected_tool', m.expected_tool,
      'expected_object_id', m.expected_object_id,
      'mutation_id', wm.id,
      'error_class', wm.error_class,
      'error_detail', wm.error_detail
    )
  ) INTO v_failed
  FROM wo_execution_manifest m
  JOIN wo_mutations wm ON m.work_order_id = wm.work_order_id 
    AND m.expected_tool = wm.tool_name 
    AND m.expected_object_id = wm.object_id
    AND wm.success = false
  WHERE m.work_order_id = p_work_order_id;

  -- Get discovered: non-read mutations not in manifest
  SELECT jsonb_agg(
    jsonb_build_object(
      'mutation_id', wm.id,
      'tool_name', wm.tool_name,
      'object_type', wm.object_type,
      'object_id', wm.object_id,
      'action', wm.action
    )
  ) INTO v_discovered
  FROM wo_mutations wm
  WHERE wm.work_order_id = p_work_order_id
    AND wm.action != 'read'
    AND NOT EXISTS (
      SELECT 1 FROM wo_execution_manifest m
      WHERE m.work_order_id = wm.work_order_id
        AND m.expected_tool = wm.tool_name
        AND m.expected_object_id = wm.object_id
    );

  -- Calculate counts
  v_matched_count := COALESCE(jsonb_array_length(v_matched), 0);
  v_missing_count := COALESCE(jsonb_array_length(v_missing), 0);
  v_failed_count := COALESCE(jsonb_array_length(v_failed), 0);
  v_discovered_count := COALESCE(jsonb_array_length(v_discovered), 0);

  -- Calculate match_confidence
  IF (v_matched_count + v_missing_count + v_failed_count) > 0 THEN
    v_match_confidence := v_matched_count::numeric / (v_matched_count + v_missing_count + v_failed_count)::numeric;
  ELSE
    v_match_confidence := 0;
  END IF;

  -- Determine verdict
  -- Check if there are any manifest steps at all
  SELECT COUNT(*) INTO v_total_required
  FROM wo_execution_manifest m
  WHERE m.work_order_id = p_work_order_id;

  IF v_total_required = 0 THEN
    v_verdict := 'no_manifest';
  ELSIF v_missing_count = 0 AND v_failed_count = 0 THEN
    v_verdict := 'complete';
  ELSIF v_failed_count > 0 THEN
    v_verdict := 'failed';
  ELSIF v_missing_count > 0 THEN
    v_verdict := 'incomplete';
  ELSIF v_discovered_count > 3 THEN
    v_verdict := 'diverged';
  ELSE
    v_verdict := 'complete';
  END IF;

  -- Build result
  v_result := jsonb_build_object(
    'matched', COALESCE(v_matched, '[]'::jsonb),
    'missing', COALESCE(v_missing, '[]'::jsonb),
    'failed', COALESCE(v_failed, '[]'::jsonb),
    'discovered', COALESCE(v_discovered, '[]'::jsonb),
    'match_confidence', v_match_confidence,
    'verdict', v_verdict
  );

  RETURN v_result;
END;
$$;


--
-- Name: complete_batch_execution(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.complete_batch_execution(p_batch_id uuid, p_summary text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_total_wos INTEGER;
  v_completed_wos INTEGER;
  v_failed_wos INTEGER;
BEGIN
  -- Count work orders
  SELECT COUNT(*) INTO v_total_wos
  FROM work_orders
  WHERE batch_id = p_batch_id;

  SELECT COUNT(*) INTO v_completed_wos
  FROM work_orders
  WHERE batch_id = p_batch_id
    AND status = 'done';

  SELECT COUNT(*) INTO v_failed_wos
  FROM work_orders
  WHERE batch_id = p_batch_id
    AND status IN ('failed', 'cancelled');

  -- Update batch
  UPDATE wo_batches
  SET 
    execution_completed_at = NOW(),
    status = CASE 
      WHEN v_completed_wos = v_total_wos THEN 'done'
      WHEN v_failed_wos > 0 THEN 'partial'
      ELSE 'in_progress'
    END,
    updated_at = NOW(),
    metadata = metadata || jsonb_build_object(
      'completion_summary', p_summary,
      'total_wos', v_total_wos,
      'completed_wos', v_completed_wos,
      'failed_wos', v_failed_wos
    )
  WHERE id = p_batch_id;

  RETURN jsonb_build_object(
    'success', true,
    'batch_id', p_batch_id,
    'total_wos', v_total_wos,
    'completed_wos', v_completed_wos,
    'failed_wos', v_failed_wos,
    'completion_rate', ROUND((v_completed_wos::numeric / NULLIF(v_total_wos, 0) * 100), 2)
  );
END;
$$;


--
-- Name: FUNCTION complete_batch_execution(p_batch_id uuid, p_summary text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.complete_batch_execution(p_batch_id uuid, p_summary text) IS 'Marks batch as complete and calculates completion statistics';


--
-- Name: complete_harness_span(uuid, jsonb, text, text, numeric, integer, integer, integer, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.complete_harness_span(p_span_id uuid, p_output jsonb DEFAULT NULL::jsonb, p_status text DEFAULT 'completed'::text, p_error_message text DEFAULT NULL::text, p_cost_usd numeric DEFAULT NULL::numeric, p_input_tokens integer DEFAULT NULL::integer, p_output_tokens integer DEFAULT NULL::integer, p_latency_ms integer DEFAULT NULL::integer, p_metadata jsonb DEFAULT NULL::jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE spans SET
    ended_at = now(),
    output = p_output,
    status = p_status,
    error_message = p_error_message,
    cost_usd = p_cost_usd,
    input_tokens = p_input_tokens,
    output_tokens = p_output_tokens,
    -- latency_ms is a generated column (auto-computed from ended_at - started_at)
    metadata = CASE 
      WHEN p_metadata IS NOT NULL AND metadata IS NOT NULL THEN metadata || p_metadata
      WHEN p_metadata IS NOT NULL THEN p_metadata
      ELSE metadata
    END
  WHERE span_id = p_span_id::text;

  IF NOT FOUND THEN
    RAISE WARNING 'Span not found for span_id: %', p_span_id;
  END IF;
END;
$$;


--
-- Name: complete_interrogation(uuid, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.complete_interrogation(p_session_id uuid, p_summary text DEFAULT NULL::text, p_generated_docs jsonb DEFAULT NULL::jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_session interrogation_sessions;
BEGIN
  SELECT * INTO v_session FROM interrogation_sessions WHERE id = p_session_id;
  
  IF v_session.id IS NULL THEN
    RETURN jsonb_build_object('error', 'Session not found');
  END IF;

  UPDATE interrogation_sessions
  SET 
    status = 'completed',
    summary = COALESCE(p_summary, summary),
    generated_docs = COALESCE(p_generated_docs, generated_docs),
    completed_at = NOW(),
    updated_at = NOW()
  WHERE id = p_session_id;

  RETURN jsonb_build_object(
    'session_id', p_session_id,
    'status', 'completed',
    'project_id', v_session.project_id,
    'completed_at', NOW()
  );
END;
$$;


--
-- Name: complete_wo_trace(text, text, jsonb, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.complete_wo_trace(p_trace_id text, p_status text DEFAULT 'completed'::text, p_output jsonb DEFAULT NULL::jsonb, p_error_message text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_total_cost NUMERIC;
  v_total_tokens INTEGER;
BEGIN
  -- Calculate totals from spans
  SELECT 
    COALESCE(SUM(cost_usd), 0),
    COALESCE(SUM(input_tokens + output_tokens), 0)
  INTO v_total_cost, v_total_tokens
  FROM spans
  WHERE trace_id = p_trace_id;
  
  -- Update trace
  UPDATE traces SET
    ended_at = now(),
    output = p_output,
    status = p_status,
    error_message = p_error_message,
    total_cost_usd = v_total_cost,
    total_tokens = v_total_tokens
  WHERE trace_id = p_trace_id;
  
  -- Clear trace context
  PERFORM set_config('app.current_trace_id', '', false);
END;
$$;


--
-- Name: complete_work_order(text, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.complete_work_order(p_agent_name text, p_work_order_id uuid, p_result jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_agent_id UUID;
  v_work_order RECORD;
BEGIN
  SELECT id INTO v_agent_id FROM agents WHERE name = p_agent_name;
  IF v_agent_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Agent not found');
  END IF;
  
  SELECT * INTO v_work_order FROM work_orders WHERE id = p_work_order_id;
  IF v_work_order.assigned_to != v_agent_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Work order not assigned to this agent');
  END IF;
  
  -- Update work order
  UPDATE work_orders 
  SET status = 'review', 
      updated_at = now(),
      history = COALESCE(history, '[]'::jsonb) || jsonb_build_object(
        'event', 'completed',
        'agent', p_agent_name,
        'timestamp', now(),
        'result', p_result
      )
  WHERE id = p_work_order_id;
  
  -- Release lock
  PERFORM release_lock(p_agent_name, 'work_order', p_work_order_id::text);
  
  -- Log event
  INSERT INTO workspace_events (agent_id, event_type, work_order_id, payload)
  VALUES (v_agent_id, 'completed', p_work_order_id, p_result);
  
  RETURN jsonb_build_object('success', true, 'status', 'review');
END;
$$;


--
-- Name: compute_valid_paths(uuid, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.compute_valid_paths(p_wo_id uuid, p_target text DEFAULT 'done'::text, p_max_depth integer DEFAULT 10) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_wo record;
  v_wo_jsonb jsonb;
  v_current_status text;
  v_paths jsonb := '[]'::jsonb;
  v_queue jsonb;
  v_item jsonb;
  v_path jsonb;
  v_visited jsonb;
  v_last_status text;
  v_transition record;
  v_new_path jsonb;
  v_new_visited jsonb;
  v_blocking jsonb;
  v_precond_result jsonb;
  v_spec_transitions jsonb;
  v_trans_spec jsonb;
  v_preconditions jsonb;
  v_precond_names text[];
  v_avg_duration jsonb;
  v_cost numeric;
  v_iterations int := 0;
  v_max_iterations int := 500;
BEGIN
  SELECT * INTO v_wo FROM work_orders WHERE id = p_wo_id;
  IF v_wo.id IS NULL THEN
    RETURN jsonb_build_object('error', 'Work order not found', 'paths', '[]'::jsonb);
  END IF;

  v_current_status := v_wo.status::text;
  v_wo_jsonb := row_to_json(v_wo)::jsonb;

  IF v_current_status = p_target THEN
    RETURN jsonb_build_object(
      'paths', '[]'::jsonb, 'current_status', v_current_status,
      'target', p_target, 'message', 'Already at target state'
    );
  END IF;

  SELECT spec->'transitions' INTO v_spec_transitions
  FROM kernel_spec ORDER BY id DESC LIMIT 1;

  -- Precompute average durations per transition type (two-step: lag then aggregate)
  SELECT jsonb_object_agg(event_type, jsonb_build_object('avg_seconds', avg_secs, 'sample_count', cnt))
  INTO v_avg_duration
  FROM (
    SELECT event_type,
      round(extract(epoch from avg(duration))::numeric, 1) as avg_secs,
      count(*) as cnt
    FROM (
      SELECT event_type, stream_id, version,
        occurred_at - lag(occurred_at) OVER (PARTITION BY stream_id ORDER BY version) as duration
      FROM wo_event_stream
    ) with_lag
    WHERE duration IS NOT NULL
    GROUP BY event_type
  ) agg;

  v_queue := jsonb_build_array(
    jsonb_build_object('path', '[]'::jsonb, 'visited', jsonb_build_array(v_current_status), 'last_status', v_current_status)
  );

  WHILE jsonb_array_length(v_queue) > 0 AND v_iterations < v_max_iterations LOOP
    v_iterations := v_iterations + 1;
    v_item := v_queue->0;
    v_queue := v_queue - 0;
    v_path := v_item->'path';
    v_visited := v_item->'visited';
    v_last_status := v_item->>'last_status';

    IF jsonb_array_length(v_path) >= p_max_depth THEN
      CONTINUE;
    END IF;

    FOR v_transition IN
      SELECT from_status::text as from_s, event, to_status::text as to_s
      FROM wo_state_machine WHERE from_status::text = v_last_status
    LOOP
      IF v_visited ? v_transition.to_s THEN
        CONTINUE;
      END IF;

      v_new_path := v_path || jsonb_build_array(jsonb_build_object(
        'event', v_transition.event, 'from_status', v_transition.from_s, 'to_status', v_transition.to_s
      ));
      v_new_visited := v_visited || jsonb_build_array(v_transition.to_s);

      IF v_transition.to_s = p_target THEN
        v_blocking := '[]'::jsonb;
        IF v_spec_transitions IS NOT NULL AND jsonb_array_length(v_path) = 0 THEN
          SELECT value INTO v_trans_spec
          FROM jsonb_array_elements(v_spec_transitions)
          WHERE value->>'from_status' = v_transition.from_s AND value->>'event' = v_transition.event
          LIMIT 1;

          IF v_trans_spec IS NOT NULL AND v_trans_spec ? 'preconditions'
             AND jsonb_typeof(v_trans_spec->'preconditions') = 'array'
             AND jsonb_array_length(v_trans_spec->'preconditions') > 0 THEN
            SELECT array_agg(elem) INTO v_precond_names
            FROM jsonb_array_elements_text(v_trans_spec->'preconditions') AS elem;
            v_precond_result := evaluate_invariants(v_wo_jsonb, v_precond_names);
            SELECT COALESCE(jsonb_agg(r), '[]'::jsonb) INTO v_blocking
            FROM jsonb_array_elements(v_precond_result->'results') AS r
            WHERE (r->>'passed')::boolean = false;
          END IF;
        END IF;

        v_cost := 0;
        FOR i IN 0..(jsonb_array_length(v_new_path) - 1) LOOP
          IF v_avg_duration IS NOT NULL AND v_avg_duration ? (v_new_path->i->>'event') THEN
            v_cost := v_cost + COALESCE((v_avg_duration->(v_new_path->i->>'event')->>'avg_seconds')::numeric, 0);
          END IF;
        END LOOP;

        v_paths := v_paths || jsonb_build_array(jsonb_build_object(
          'steps', v_new_path, 'step_count', jsonb_array_length(v_new_path),
          'blocking_invariants', COALESCE(v_blocking, '[]'::jsonb),
          'estimated_seconds', v_cost
        ));
      ELSE
        v_queue := v_queue || jsonb_build_array(jsonb_build_object(
          'path', v_new_path, 'visited', v_new_visited, 'last_status', v_transition.to_s
        ));
      END IF;
    END LOOP;
  END LOOP;

  SELECT COALESCE(jsonb_agg(p ORDER BY (p->>'step_count')::int), '[]'::jsonb)
  INTO v_paths FROM jsonb_array_elements(v_paths) AS p;

  RETURN jsonb_build_object(
    'paths', v_paths, 'current_status', v_current_status,
    'target', p_target, 'path_count', jsonb_array_length(v_paths),
    'iterations', v_iterations
  );
END;
$$;


--
-- Name: config_mutation_guard_check(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.config_mutation_guard_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_bypass text;
  v_agent text;
BEGIN
  -- Check if we're in agent execution context (bypass key is set)
  BEGIN
    v_bypass := current_setting('app.wo_executor_bypass', true);
  EXCEPTION WHEN OTHERS THEN
    v_bypass := NULL;
  END;

  -- If no bypass set, this is direct admin SQL — allow
  IF v_bypass IS NULL OR v_bypass = '' THEN
    RETURN NEW;
  END IF;

  -- In agent context: check which agent
  BEGIN
    v_agent := current_setting('app.current_agent_name', true);
  EXCEPTION WHEN OTHERS THEN
    v_agent := NULL;
  END;

  -- Master agent (ilmarinen) is allowed
  IF v_agent = 'ilmarinen' THEN
    RETURN NEW;
  END IF;

  -- All other agents are blocked from config mutations
  RAISE EXCEPTION 'CONFIG_GUARD: Agent "%" cannot modify system configuration table "%" . Only ilmarinen (master) can modify config tables. Escalate this change to the master agent.', 
    COALESCE(v_agent, 'unknown'), TG_TABLE_NAME;
END;
$$;


--
-- Name: count_acceptance_criteria(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.count_acceptance_criteria(p_criteria text) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $$
  SELECT COALESCE(
    (SELECT count(*)::int 
     FROM unnest(string_to_array(p_criteria, E'\n')) AS line
     WHERE trim(line) ~ '^\d+[\.)\:]\s'
        OR trim(line) ~ '^[-*]\s'
        OR trim(line) ~ '^AC\d+[\:\.]\s'),
    0
  );
$$;


--
-- Name: create_draft_work_order(text, text, text, public.work_order_priority, text, text[], text, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_draft_work_order(p_slug text DEFAULT NULL::text, p_name text DEFAULT NULL::text, p_objective text DEFAULT NULL::text, p_priority public.work_order_priority DEFAULT 'p2_medium'::public.work_order_priority, p_source text DEFAULT 'cli'::text, p_tags text[] DEFAULT '{}'::text[], p_acceptance_criteria text DEFAULT NULL::text, p_parent_id uuid DEFAULT NULL::uuid, p_client_info jsonb DEFAULT NULL::jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
  v_wo_id UUID;
  v_result jsonb;
  v_generated_slug text;
  v_next_number int;
  v_acceptance_criteria text;
  v_ac_validation record;
  v_routing jsonb;
  v_agent_id UUID;
  v_approved_at TIMESTAMPTZ;
BEGIN
  PERFORM set_config('app.state_write_bypass', 'true', true);
  PERFORM set_config('app.wo_trigger_context', 'true', true);
  PERFORM set_config('app.wo_executor_bypass', 'true', true);

  -- Generate slug if not provided
  IF p_slug IS NULL OR p_slug = '' THEN
    SELECT COALESCE(MAX(
      CASE WHEN slug ~ '^WO-[0-9]{4}$' THEN CAST(SUBSTRING(slug FROM 4) AS INTEGER) ELSE 0 END
    ), 0) + 1 INTO v_next_number FROM work_orders;
    v_generated_slug := 'WO-' || LPAD(v_next_number::text, 4, '0');
  ELSE
    v_generated_slug := p_slug;
  END IF;

  -- Auto-generate acceptance criteria from objective if not provided
  IF p_acceptance_criteria IS NOT NULL AND length(trim(p_acceptance_criteria)) > 10 THEN
    v_acceptance_criteria := p_acceptance_criteria;
  ELSIF p_objective IS NOT NULL AND length(trim(p_objective)) > 10 THEN
    v_acceptance_criteria := '1. Objective completed: ' || left(p_objective, 200) || E'\\n2. Changes verified and no regressions introduced\\n3. Evidence logged in execution_log';
  ELSE
    v_acceptance_criteria := NULL;
  END IF;

  -- === INLINED from trg_ac_quality_gate (trg_validate_acceptance_criteria) ===
  IF v_acceptance_criteria IS NULL OR trim(v_acceptance_criteria) = '' THEN
    RAISE EXCEPTION 'acceptance_criteria required: must contain at least 1 numbered or bulleted criterion';
  END IF;
  SELECT * INTO v_ac_validation FROM validate_acceptance_criteria(v_acceptance_criteria);
  IF v_ac_validation.line_count < 1 THEN
    RAISE EXCEPTION 'acceptance_criteria required: must contain at least 1 numbered or bulleted criterion';
  END IF;
  IF NOT v_ac_validation.is_valid THEN
    RAISE EXCEPTION 'acceptance_criteria must contain specific, testable criteria — generic filler rejected';
  END IF;

  -- === INLINED from trg_auto_route_portal_insert (auto_route_portal_insert) ===
  v_routing := route_work_order(p_tags, p_source, p_objective, v_acceptance_criteria, NULL, 'draft', p_priority::text);
  v_agent_id := (v_routing->>'agent_id')::UUID;
  v_approved_at := (v_routing->>'approved_at')::TIMESTAMPTZ;

  INSERT INTO work_orders (
    id, slug, name, objective, acceptance_criteria, priority, status,
    created_by, source, tags, requires_approval,
    parent_id, client_info, assigned_to, approved_at
  ) VALUES (
    gen_random_uuid(), v_generated_slug, p_name, p_objective, v_acceptance_criteria, p_priority,
    'draft'::work_order_status,
    'engineering', p_source, p_tags, true,
    p_parent_id, p_client_info, v_agent_id, v_approved_at
  ) RETURNING id INTO v_wo_id;

  PERFORM set_config('app.state_write_bypass', 'false', true);
  PERFORM set_config('app.wo_executor_bypass', 'false', true);
  PERFORM set_config('app.wo_trigger_context', '', true);

  -- Log routing decision
  INSERT INTO state_mutations (mutation_type, target_table, target_id, payload)
  VALUES ('INSERT', 'work_orders', v_wo_id,
    jsonb_build_object(
      'name', p_name, 'slug', v_generated_slug, 'objective', p_objective,
      'priority', p_priority, 'source', p_source,
      'has_acceptance_criteria', v_acceptance_criteria IS NOT NULL,
      'routing', v_routing
    )
  );

  SELECT jsonb_build_object('id', id, 'slug', slug, 'status', status, 'name', name, 'priority', priority)
  INTO v_result FROM work_orders WHERE id = v_wo_id;

  RETURN v_result;
END;
$_$;


--
-- Name: create_lesson_from_error_span(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_lesson_from_error_span() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  existing_count INTEGER;
  mapped_category TEXT;
  mapped_severity TEXT;
BEGIN
  -- Only fire on error spans
  IF NEW.status != 'error' THEN
    RETURN NEW;
  END IF;

  -- Deduplicate: don't create if one already exists for this trace+span combo
  SELECT COUNT(*) INTO existing_count
  FROM lessons
  WHERE trace_id = NEW.trace_id
    AND reported_by = 'auto:error_span'
    AND context LIKE '%' || NEW.span_id || '%';

  IF existing_count > 0 THEN
    RETURN NEW;
  END IF;

  -- Map span_type to valid lesson category
  mapped_category := CASE NEW.span_type
    WHEN 'llm-generation' THEN 'hallucination'
    WHEN 'tool-call' THEN 'tool_misuse'
    WHEN 'db-query' THEN 'performance'
    WHEN 'http-request' THEN 'performance'
    WHEN 'embedding' THEN 'performance'
    WHEN 'retrieval' THEN 'context_loss'
    WHEN 'agent-step' THEN 'execution'
    ELSE 'general'
  END;

  -- Map severity: LLM and agent errors are higher severity
  mapped_severity := CASE NEW.span_type
    WHEN 'llm-generation' THEN 'error'
    WHEN 'agent-step' THEN 'error'
    WHEN 'tool-call' THEN 'warning'
    ELSE 'warning'
  END;

  INSERT INTO lessons (
    id, occurred_at, pattern, context, rule,
    severity, category, trace_id, reported_by,
    applied_to_directives, reviewed, review_status,
    created_at, updated_at
  ) VALUES (
    gen_random_uuid(),
    COALESCE(NEW.ended_at, NOW()),
    'Error in ' || COALESCE(NEW.span_type, 'unknown') || ' span: ' || 
      LEFT(COALESCE(NEW.error_message, NEW.name, 'unknown error'), 200),
    jsonb_build_object(
      'span_id', NEW.span_id,
      'span_type', NEW.span_type,
      'span_name', NEW.name,
      'agent_name', NEW.agent_name,
      'model', NEW.model,
      'trace_id', NEW.trace_id,
      'latency_ms', NEW.latency_ms,
      'metadata', NEW.metadata
    )::text,
    'Investigate and resolve: ' || COALESCE(NEW.error_message, 'error in ' || COALESCE(NEW.name, 'span')),
    mapped_severity,
    mapped_category,
    NEW.trace_id,
    'auto:error_span',
    false,
    false,
    'pending',
    NOW(),
    NOW()
  );

  RETURN NEW;
END;
$$;


--
-- Name: create_pipeline(uuid, text, text, text, jsonb, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_pipeline(p_spec_wo_id uuid DEFAULT NULL::uuid, p_slug text DEFAULT NULL::text, p_display_name text DEFAULT NULL::text, p_description text DEFAULT NULL::text, p_config jsonb DEFAULT '{}'::jsonb, p_target text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_pipeline_id UUID;
  v_slug TEXT;
BEGIN
  -- Generate slug if not provided
  IF p_slug IS NULL OR p_slug = '' THEN
    v_slug := left(md5(gen_random_uuid()::text), 8);
  ELSE
    v_slug := p_slug;
  END IF;

  -- Create the pipeline run
  INSERT INTO pipeline_runs (
    spec_wo_id,
    slug,
    display_name,
    current_phase,
    status,
    config,
    target,
    description
  )
  VALUES (
    p_spec_wo_id,
    v_slug,
    p_display_name,
    'spec',
    'active',
    p_config,
    p_target,
    p_description
  )
  RETURNING id INTO v_pipeline_id;

  -- Log creation
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
  VALUES (
    'pipeline_created',
    'agent',
    'builder',
    'pipeline_runs',
    v_pipeline_id,
    'CREATE',
    jsonb_build_object(
      'slug', v_slug,
      'display_name', p_display_name,
      'spec_wo_id', p_spec_wo_id
    )
  );

  RETURN jsonb_build_object(
    'success', true,
    'pipeline_id', v_pipeline_id,
    'slug', v_slug,
    'display_name', p_display_name
  );
END;
$$;


--
-- Name: create_session(text, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_session(p_user_id text, p_source text, p_ttl_minutes integer DEFAULT 60) RETURNS TABLE(session_id uuid, session_token text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_id UUID;
  v_token TEXT;
BEGIN
  v_id := gen_random_uuid();
  v_token := encode(gen_random_bytes(32), 'hex');
  
  INSERT INTO active_sessions (id, session_token, user_id, source, expires_at)
  VALUES (v_id, v_token, p_user_id, p_source, now() + (p_ttl_minutes || ' minutes')::interval);
  
  RETURN QUERY SELECT v_id, v_token;
END;
$$;


--
-- Name: create_wo_batch(text, text, uuid, uuid[], text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_wo_batch(p_name text, p_description text DEFAULT NULL::text, p_project_brief_id uuid DEFAULT NULL::uuid, p_work_order_ids uuid[] DEFAULT NULL::uuid[], p_created_by text DEFAULT 'engineering'::text, p_metadata jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_batch_id UUID;
  v_batch RECORD;
  v_wo_count INT := 0;
  v_wo_id UUID;
BEGIN
  -- Create the batch
  INSERT INTO wo_batches (name, description, project_brief_id, created_by, metadata)
  VALUES (p_name, p_description, p_project_brief_id, p_created_by, p_metadata)
  RETURNING id INTO v_batch_id;

  -- Associate work orders if provided
  IF p_work_order_ids IS NOT NULL AND array_length(p_work_order_ids, 1) > 0 THEN
    FOREACH v_wo_id IN ARRAY p_work_order_ids
    LOOP
      UPDATE work_orders 
      SET batch_id = v_batch_id, updated_at = now()
      WHERE id = v_wo_id;
      
      IF FOUND THEN
        v_wo_count := v_wo_count + 1;
      END IF;
    END LOOP;
  END IF;

  -- Log to audit_log
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
  VALUES (
    'batch_created',
    'agent',
    p_created_by,
    'wo_batch',
    v_batch_id,
    'CREATE',
    jsonb_build_object(
      'batch_name', p_name,
      'wo_count', v_wo_count,
      'project_brief_id', p_project_brief_id
    )
  );

  -- Return batch details
  SELECT 
    id, name, description, project_brief_id, status, created_by, 
    created_at, updated_at, metadata
  INTO v_batch
  FROM wo_batches
  WHERE id = v_batch_id;

  RETURN jsonb_build_object(
    'success', true,
    'batch_id', v_batch_id,
    'batch', row_to_json(v_batch),
    'wo_count', v_wo_count
  );
END;
$$;


--
-- Name: FUNCTION create_wo_batch(p_name text, p_description text, p_project_brief_id uuid, p_work_order_ids uuid[], p_created_by text, p_metadata jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.create_wo_batch(p_name text, p_description text, p_project_brief_id uuid, p_work_order_ids uuid[], p_created_by text, p_metadata jsonb) IS 'Create a new WO batch/sprint and optionally associate existing work orders with it';


--
-- Name: cross_validate_audit_trail(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cross_validate_audit_trail() RETURNS TABLE(discrepancy_type text, entity_type text, entity_id text, details jsonb)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Find state_mutations without corresponding audit_log entries
  RETURN QUERY
  SELECT 
    'mutation_without_audit'::TEXT,
    sm.entity_type,
    sm.entity_id,
    jsonb_build_object(
      'mutation_id', sm.id,
      'mutation_timestamp', sm.timestamp,
      'change_type', sm.change_type
    ) AS details
  FROM state_mutations sm
  WHERE NOT EXISTS (
    SELECT 1 FROM audit_log al
    WHERE al.entity_type = sm.entity_type
    AND al.entity_id = sm.entity_id
    AND al.timestamp BETWEEN sm.timestamp - INTERVAL '5 seconds' 
                          AND sm.timestamp + INTERVAL '5 seconds'
  )
  AND sm.timestamp > NOW() - INTERVAL '7 days'
  LIMIT 100;

  -- Find audit_log entries without corresponding state_mutations
  RETURN QUERY
  SELECT 
    'audit_without_mutation'::TEXT,
    al.entity_type,
    al.entity_id,
    jsonb_build_object(
      'audit_id', al.id,
      'audit_timestamp', al.timestamp,
      'action', al.action
    ) AS details
  FROM audit_log al
  WHERE al.action IN ('create', 'update', 'delete')
  AND NOT EXISTS (
    SELECT 1 FROM state_mutations sm
    WHERE sm.entity_type = al.entity_type
    AND sm.entity_id = al.entity_id
    AND sm.timestamp BETWEEN al.timestamp - INTERVAL '5 seconds' 
                          AND al.timestamp + INTERVAL '5 seconds'
  )
  AND al.timestamp > NOW() - INTERVAL '7 days'
  LIMIT 100;
END;
$$;


--
-- Name: decide_approval(uuid, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.decide_approval(p_approval_id uuid, p_decision text, p_decided_by text, p_notes text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_approval RECORD;
  v_wo_id UUID;
BEGIN
  SELECT * INTO v_approval FROM approval_queue WHERE id = p_approval_id;
  
  IF v_approval IS NULL THEN
    RETURN jsonb_build_object('error', 'Approval not found');
  END IF;
  
  IF v_approval.status != 'pending' THEN
    RETURN jsonb_build_object('error', 'Approval already decided', 'status', v_approval.status);
  END IF;
  
  -- Update approval
  UPDATE approval_queue SET
    status = p_decision,
    decided_by = p_decided_by,
    decided_at = now(),
    decision_notes = p_notes
  WHERE id = p_approval_id;
  
  -- Update work order if approved
  IF p_decision = 'approved' AND v_approval.work_order_id IS NOT NULL THEN
    UPDATE work_orders SET 
      status = 'ready',
      approved_at = now(),
      approved_by = p_decided_by
    WHERE id = v_approval.work_order_id;
    
    -- Log
    INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
    VALUES (v_approval.work_order_id, 'approved', p_decided_by, 
      jsonb_build_object('notes', p_notes, 'approval_id', p_approval_id));
  END IF;
  
  IF p_decision = 'rejected' AND v_approval.work_order_id IS NOT NULL THEN
    UPDATE work_orders SET status = 'cancelled' WHERE id = v_approval.work_order_id;
  END IF;
  
  RETURN jsonb_build_object(
    'status', p_decision,
    'work_order_id', v_approval.work_order_id,
    'decided_by', p_decided_by
  );
END;
$$;


--
-- Name: dedupe_builder_tools(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.dedupe_builder_tools() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  UPDATE agents SET tools_allowed = array(
    SELECT DISTINCT elem FROM unnest(tools_allowed) AS elem
  ) WHERE name = 'builder';
END;
$$;


--
-- Name: detect_circular_dependencies(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.detect_circular_dependencies(p_wo_id uuid DEFAULT NULL::uuid) RETURNS TABLE(cycle_wos uuid[], cycle_slugs text[], severity text)
    LANGUAGE sql STABLE
    AS $$
WITH RECURSIVE dep_walk AS (
  -- Start with specified WO or all WOs with dependencies
  SELECT 
    wo.id,
    wo.slug,
    wo.depends_on,
    ARRAY[wo.id] as path,
    ARRAY[wo.slug] as slug_path,
    false as has_cycle
  FROM work_orders wo
  WHERE (p_wo_id IS NULL OR wo.id = p_wo_id)
    AND wo.depends_on IS NOT NULL 
    AND array_length(wo.depends_on, 1) > 0
  
  UNION ALL
  
  -- Follow dependency chain
  SELECT 
    wo.id,
    wo.slug,
    wo.depends_on,
    dw.path || wo.id,
    dw.slug_path || wo.slug,
    wo.id = ANY(dw.path) as has_cycle
  FROM work_orders wo
  INNER JOIN dep_walk dw ON wo.id = ANY(dw.depends_on)
  WHERE NOT dw.has_cycle
    AND array_length(dw.path, 1) < 20
)
SELECT 
  path as cycle_wos,
  slug_path as cycle_slugs,
  CASE 
    WHEN array_length(path, 1) > 5 THEN 'critical'
    WHEN array_length(path, 1) > 3 THEN 'high'
    ELSE 'medium'
  END as severity
FROM dep_walk
WHERE has_cycle
ORDER BY array_length(path, 1) DESC;
$$;


--
-- Name: detect_decomposition_need(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.detect_decomposition_need(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_ac text;
  v_result jsonb;
  v_score int;
  v_flags jsonb;
  v_needs boolean;
  v_suggested text := '';
BEGIN
  SELECT acceptance_criteria INTO v_ac
  FROM work_orders
  WHERE id = p_work_order_id;

  IF v_ac IS NULL THEN
    RETURN jsonb_build_object(
      'needs_decomposition', false,
      'score', 0,
      'flags', '[]'::jsonb,
      'suggested_split', 'No acceptance criteria found'
    );
  END IF;

  v_result := score_ac_specificity(v_ac);
  v_score := (v_result->>'score')::int;
  v_flags := v_result->'flags';
  v_needs := v_score < 40;

  IF v_needs THEN
    v_suggested := 'ACs scored ' || v_score || '/100. Rewrite with: exact file paths, exact function names (with params), exact SQL statements. Eliminate vague verbs (find, investigate, discover). Replace open-ended enumeration (all tables, each candidate) with specific lists.';
  END IF;

  RETURN jsonb_build_object(
    'needs_decomposition', v_needs,
    'score', v_score,
    'ac_count', v_result->>'ac_count',
    'flags', v_flags,
    'suggested_split', v_suggested
  );
END;
$$;


--
-- Name: detect_error_spikes(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.detect_error_spikes(p_time_window_minutes integer DEFAULT 10, p_threshold integer DEFAULT 5) RETURNS TABLE(error_code text, source_function text, count bigint, first_occurrence timestamp with time zone, last_occurrence timestamp with time zone, severity text, sample_message text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ee.error_code,
    ee.source_function,
    COUNT(*) as count,
    MIN(ee.created_at) as first_occurrence,
    MAX(ee.created_at) as last_occurrence,
    MAX(ee.severity) as severity,
    MAX(ee.message) as sample_message
  FROM error_events ee
  WHERE 
    ee.created_at >= now() - (p_time_window_minutes || ' minutes')::interval
    AND ee.error_code IS NOT NULL
  GROUP BY ee.error_code, ee.source_function
  HAVING COUNT(*) >= p_threshold
  ORDER BY count DESC, last_occurrence DESC;
END;
$$;


--
-- Name: FUNCTION detect_error_spikes(p_time_window_minutes integer, p_threshold integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.detect_error_spikes(p_time_window_minutes integer, p_threshold integer) IS 'Detect error spikes (>5 same error in 10 min by default) for ops health monitoring';


--
-- Name: detect_lesson_gaps(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.detect_lesson_gaps() RETURNS TABLE(category text, lesson_count bigint, severities text[], sample_pattern text, sample_rule text, has_open_wo boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  WITH category_stats AS (
    SELECT
      l.category,
      count(*) as cnt,
      array_agg(DISTINCT l.severity) as sevs,
      (array_agg(l.pattern ORDER BY l.created_at DESC))[1] as latest_pattern,
      (array_agg(l.rule ORDER BY l.created_at DESC))[1] as latest_rule
    FROM lessons l
    WHERE l.review_status = 'pending'
      AND l.applied_to_directives = false
    GROUP BY l.category
    HAVING count(*) >= 3
       OR bool_or(l.severity = 'critical' AND l.created_at < now() - interval '24 hours')
  ),
  open_wo_categories AS (
    SELECT DISTINCT unnest(tags) as tag
    FROM work_orders
    WHERE status NOT IN ('done', 'cancelled')
      AND 'self-update' = ANY(tags)
  )
  SELECT
    cs.category,
    cs.cnt,
    cs.sevs,
    cs.latest_pattern,
    cs.latest_rule,
    EXISTS (
      SELECT 1 FROM open_wo_categories owc
      WHERE owc.tag = 'cat:' || cs.category
    ) as has_open_wo
  FROM category_stats cs;
END;
$$;


--
-- Name: detect_local_filesystem_need(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.detect_local_filesystem_need(p_objective text, p_acceptance_criteria text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  v_combined TEXT;
  -- Patterns that indicate local-filesystem / CLI execution is needed
  v_patterns TEXT[] := ARRAY[
    -- CLI deploy patterns
    'cli deploy',
    'deploy.*via cli',
    'deploy.*edge function',
    'supabase functions deploy',
    'functions deploy',
    'deploy.*function.*cli',
    -- File system patterns
    'local file',
    'file system',
    'filesystem',
    'local-filesystem',
    'write.*file',
    'file.*write',
    'workspace\.html',
    -- Git operations
    'git push',
    'git commit',
    'git delivery',
    'git-delivery',
    'git operations',
    -- Portal frontend
    'portal frontend',
    'portal-frontend',
    'frontend.*code',
    'frontend.*deploy',
    'vercel.*deploy',
    -- Rollback
    'rollback',
    'roll back',
    -- Large edge function deployment (>100 lines must use CLI)
    'large.*edge function',
    'edge function.*large',
    -- Workspace / local paths
    'local workspace',
    'local path',
    'local director',
    -- Daemon-related
    'daemon.*file',
    'daemon.*deploy',
    'daemon.*config',
    'daemon.*restart',
    -- Import map / deno config (needs local deploy)
    'import.map',
    'deno\.json',
    'import-map'
  ];
  v_pattern TEXT;
BEGIN
  -- Combine objective and acceptance criteria for scanning
  v_combined := lower(COALESCE(p_objective, '') || ' ' || COALESCE(p_acceptance_criteria, ''));
  
  -- Check each pattern
  FOREACH v_pattern IN ARRAY v_patterns
  LOOP
    IF v_combined ~ v_pattern THEN
      RETURN TRUE;
    END IF;
  END LOOP;
  
  RETURN FALSE;
END;
$$;


--
-- Name: FUNCTION detect_local_filesystem_need(p_objective text, p_acceptance_criteria text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.detect_local_filesystem_need(p_objective text, p_acceptance_criteria text) IS 'Scans WO objective/acceptance_criteria text for patterns indicating local-filesystem execution is needed (CLI deploy, file writes, git ops, portal frontend, rollback). Used by auto-routing triggers.';


--
-- Name: detect_silent_completion_failures(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.detect_silent_completion_failures() RETURNS TABLE(work_order_id uuid, slug text, name text, status public.work_order_status, last_execution_complete timestamp with time zone, has_state_mutation boolean, issue_type text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  WITH execution_complete_wos AS (
    SELECT DISTINCT 
      woel.work_order_id,
      MAX(woel.created_at) as last_complete_log
    FROM work_order_execution_log woel
    WHERE woel.phase = 'execution_complete'
    GROUP BY woel.work_order_id
  ),
  mark_complete_success AS (
    SELECT DISTINCT
      woel.work_order_id,
      MAX(woel.created_at) as last_success_log
    FROM work_order_execution_log woel
    WHERE woel.phase = 'stream'
      AND woel.detail->>'message' ILIKE '%mark_complete%success%'
    GROUP BY woel.work_order_id
  ),
  state_transitions AS (
    SELECT DISTINCT
      sm.work_order_id,
      bool_or(
        sm.mutation_type = 'UPDATE' 
        AND sm.target_table = 'work_orders'
        AND (sm.payload->>'status' = 'review' OR sm.previous_state->>'status' = 'in_progress')
      ) as has_transition
    FROM state_mutations sm
    WHERE sm.created_at > NOW() - INTERVAL '24 hours'
    GROUP BY sm.work_order_id
  )
  SELECT 
    wo.id as work_order_id,
    wo.slug,
    wo.name,
    wo.status,
    COALESCE(ec.last_complete_log, mcs.last_success_log) as last_execution_complete,
    COALESCE(st.has_transition, false) as has_state_mutation,
    CASE 
      WHEN ec.last_complete_log IS NOT NULL AND wo.status = 'in_progress' THEN 'execution_complete_logged_but_stuck'
      WHEN mcs.last_success_log IS NOT NULL AND NOT COALESCE(st.has_transition, false) THEN 'mark_complete_success_but_no_state_mutation'
      ELSE 'unknown'
    END as issue_type
  FROM work_orders wo
  LEFT JOIN execution_complete_wos ec ON ec.work_order_id = wo.id
  LEFT JOIN mark_complete_success mcs ON mcs.work_order_id = wo.id
  LEFT JOIN state_transitions st ON st.work_order_id = wo.id
  WHERE (
    -- Case 1: execution_complete logged but status still in_progress
    (ec.last_complete_log IS NOT NULL AND wo.status = 'in_progress' AND ec.last_complete_log > NOW() - INTERVAL '1 hour')
    OR
    -- Case 2: mark_complete success logged but no state_mutation for transition
    (mcs.last_success_log IS NOT NULL AND NOT COALESCE(st.has_transition, false) AND mcs.last_success_log > NOW() - INTERVAL '1 hour')
  )
  ORDER BY COALESCE(ec.last_complete_log, mcs.last_success_log) DESC;
END;
$$;


--
-- Name: FUNCTION detect_silent_completion_failures(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.detect_silent_completion_failures() IS 'WO-0213: Detects WOs where mark_complete RPC call silently failed, leaving status stuck despite completion logs. Returns WOs with execution_complete phase logged but status=in_progress, or mark_complete success logged but no corresponding state_mutation.';


--
-- Name: detect_zombie_work_orders(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.detect_zombie_work_orders(p_timeout_minutes integer DEFAULT 30) RETURNS TABLE(work_order_id uuid, slug text, name text, status text, last_mutation_at timestamp with time zone, minutes_stale integer)
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
    SELECT 
        wo.id,
        wo.slug::text,
        wo.name::text,
        wo.status::text,
        COALESCE(wm.last_mutation_at, wo.started_at),
        EXTRACT(EPOCH FROM (now() - COALESCE(wm.last_mutation_at, wo.started_at))) / 60::int
    FROM work_orders wo
    LEFT JOIN LATERAL (
        SELECT MAX(created_at) AS last_mutation_at 
        FROM wo_mutations 
        WHERE work_order_id = wo.id
    ) wm ON true
    WHERE wo.status = 'in_progress'
      AND wo.assigned_to IS NOT NULL
      AND (wm.last_mutation_at IS NULL OR wm.last_mutation_at < now() - (GREATEST(p_timeout_minutes, 1) || ' minutes')::interval)
    ORDER BY EXTRACT(EPOCH FROM (now() - COALESCE(wm.last_mutation_at, wo.started_at))) / 60 DESC;
$$;


--
-- Name: dispatch_work_order(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.dispatch_work_order(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo record;
  v_agent_name text;
  v_auth_key text;
  v_request_id bigint;
  v_dispatch_result record;
BEGIN
  -- Get WO state with lock
  SELECT * INTO v_wo 
  FROM work_orders 
  WHERE id = p_work_order_id 
  FOR UPDATE;
  
  IF v_wo IS NULL THEN
    RAISE EXCEPTION 'Work order not found: %', p_work_order_id;
  END IF;

  -- Validate WO is in_progress status
  IF v_wo.status != 'in_progress' THEN
    RAISE EXCEPTION 'Cannot dispatch WO in status: % (must be in_progress)', v_wo.status;
  END IF;

  -- Resolve assigned agent name
  SELECT name INTO v_agent_name
  FROM agents
  WHERE id = v_wo.assigned_to;

  -- Skip dispatch if ilmarinen
  IF v_agent_name = 'ilmarinen' THEN
    RETURN jsonb_build_object(
      'dispatched', false,
      'reason', 'ilmarinen is interactive CLI agent, no dispatch needed',
      'work_order_id', p_work_order_id
    );
  END IF;

  -- Get anon key from system_settings
  SELECT (setting_value#>>'{}')::text INTO v_auth_key
  FROM system_settings
  WHERE setting_key = 'supabase_anon_key';

  IF v_auth_key IS NULL THEN
    RAISE EXCEPTION 'supabase_anon_key not found in system_settings';
  END IF;

  -- Update dispatch tracking BEFORE attempting dispatch
  UPDATE work_orders
  SET 
    dispatch_attempts = COALESCE(dispatch_attempts, 0) + 1,
    last_dispatch_at = now(),
    last_dispatch_error = NULL,  -- Clear previous error
    updated_at = now()
  WHERE id = p_work_order_id;

  -- Fire pg_net POST to wo-agent/execute
  SELECT id INTO v_request_id
  FROM net.http_post(
    url := 'https://phfblljwuvzqzlbzkzpr.supabase.co/functions/v1/wo-agent/execute',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || v_auth_key,
      'apikey', v_auth_key
    ),
    body := jsonb_build_object(
      'work_order_id', p_work_order_id::text,
      'trigger', 'manual_dispatch'
    )
  );

  -- Wait briefly for response (non-blocking, just capture status)
  -- Then update tracking based on result
  BEGIN
    -- Small delay to allow response
    PERFORM pg_sleep(1);
    
    -- Check response status
    SELECT status_code::text INTO v_dispatch_result.status_code
    FROM net._http_response
    WHERE id = v_request_id
    LIMIT 1;

    -- If we got a response, track it
    IF v_dispatch_result.status_code IS NOT NULL THEN
      IF v_dispatch_result.status_code::int >= 500 THEN
        -- Server error - track for retry
        UPDATE work_orders
        SET last_dispatch_error = 'HTTP ' || v_dispatch_result.status_code
        WHERE id = p_work_order_id;
      END IF;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- Response not available yet - that's ok
      NULL;
  END;

  -- Log dispatch to execution_log
  INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
  VALUES (
    p_work_order_id,
    'stream',
    'system',
    jsonb_build_object(
      'event_type', 'dispatch_attempt',
      'target_agent', v_agent_name,
      'pg_net_request_id', v_request_id,
      'dispatch_attempts', v_wo.dispatch_attempts + 1
    )
  );

  -- Return result
  RETURN jsonb_build_object(
    'dispatched', true,
    'work_order_id', p_work_order_id,
    'agent', v_agent_name,
    'pg_net_request_id', v_request_id,
    'dispatch_attempts', v_wo.dispatch_attempts + 1
  );
END;
$$;


--
-- Name: FUNCTION dispatch_work_order(p_work_order_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.dispatch_work_order(p_work_order_id uuid) IS 'WO-0555: Manually dispatch in_progress work order to wo-agent/execute endpoint';


--
-- Name: emit_harness_span(text, text, text, jsonb, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.emit_harness_span(p_trace_id text, p_span_type text, p_name text, p_input jsonb DEFAULT NULL::jsonb, p_metadata jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_span_id UUID;
BEGIN
  -- Generate span ID
  v_span_id := gen_random_uuid();
  
  -- Insert span (will be completed later)
  INSERT INTO spans (
    trace_id,
    span_id,
    span_type,
    name,
    input,
    metadata,
    status
  ) VALUES (
    p_trace_id,
    v_span_id::text,
    p_span_type,
    p_name,
    p_input,
    p_metadata,
    'running'
  );
  
  RETURN v_span_id;
EXCEPTION WHEN OTHERS THEN
  -- Don't fail the parent operation if span emission fails
  RAISE WARNING 'Failed to emit span: %', SQLERRM;
  RETURN NULL;
END;
$$;


--
-- Name: enforce_append_only(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.enforce_append_only() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_allowed_updates TEXT[];
BEGIN
  IF TG_TABLE_NAME = 'traces' THEN
    v_allowed_updates := ARRAY['ended_at', 'output', 'status', 'error_message', 'total_cost_usd', 'total_tokens'];
  ELSIF TG_TABLE_NAME = 'spans' THEN
    v_allowed_updates := ARRAY['ended_at', 'output', 'status', 'error_message'];
  ELSE
    RAISE EXCEPTION 'Updates not allowed on %', TG_TABLE_NAME;
  END IF;
  
  IF TG_OP = 'UPDATE' THEN
    IF OLD.id != NEW.id OR 
       OLD.created_at != NEW.created_at OR
       OLD.started_at != NEW.started_at OR
       (OLD.input IS DISTINCT FROM NEW.input AND OLD.input IS NOT NULL) THEN
      RAISE EXCEPTION 'Cannot modify immutable fields on %', TG_TABLE_NAME;
    END IF;
    
    IF TG_TABLE_NAME IN ('traces', 'spans') THEN
      IF OLD.ended_at IS NOT NULL AND NEW.ended_at IS DISTINCT FROM OLD.ended_at THEN
        RAISE EXCEPTION 'Cannot modify ended_at after it has been set';
      END IF;
      IF OLD.output IS NOT NULL AND NEW.output IS DISTINCT FROM OLD.output THEN
        RAISE EXCEPTION 'Cannot modify output after it has been set';
      END IF;
    END IF;
  END IF;
  
  IF TG_OP = 'DELETE' THEN
    RAISE EXCEPTION 'Deletes not allowed on % (append-only)', TG_TABLE_NAME;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: enforce_remediation_qa_tools(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.enforce_remediation_qa_tools() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_has_findings BOOLEAN;
  v_has_resolve_call BOOLEAN;
  v_has_update_call BOOLEAN;
  v_is_remediation BOOLEAN;
BEGIN
  -- Only check if transitioning to 'done' or 'review' status
  IF NEW.status NOT IN ('done', 'review') THEN
    RETURN NEW;
  END IF;

  -- Check if this is a remediation WO
  v_is_remediation := 'remediation' = ANY(NEW.tags);
  
  IF NOT v_is_remediation THEN
    RETURN NEW;
  END IF;

  -- Check if there are unresolved QA findings
  SELECT EXISTS(
    SELECT 1 FROM qa_findings 
    WHERE work_order_id = NEW.id 
    AND resolved_at IS NULL
  ) INTO v_has_findings;

  -- If no findings, no enforcement needed
  IF NOT v_has_findings THEN
    RETURN NEW;
  END IF;

  -- Check if resolve_qa_findings was called in execution log
  SELECT EXISTS(
    SELECT 1 FROM work_order_execution_log
    WHERE work_order_id = NEW.id
    AND phase = 'stream'
    AND detail->>'tool_name' = 'resolve_qa_findings'
    AND detail->>'event_type' = 'tool_result'
  ) INTO v_has_resolve_call;

  -- Check if update_qa_checklist was called
  SELECT EXISTS(
    SELECT 1 FROM work_order_execution_log
    WHERE work_order_id = NEW.id
    AND phase = 'stream'
    AND detail->>'tool_name' = 'update_qa_checklist'
    AND detail->>'event_type' = 'tool_result'
  ) INTO v_has_update_call;

  -- Block if tools weren't called
  IF NOT v_has_resolve_call OR NOT v_has_update_call THEN
    RAISE EXCEPTION 'ERR_QA_TOOLS_NOT_CALLED: Remediation WO has unresolved findings but QA tools were not called. Required: resolve_qa_findings=%, update_qa_checklist=%', 
      v_has_resolve_call, v_has_update_call
    USING ERRCODE = '23514'; -- check_violation
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION enforce_remediation_qa_tools(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.enforce_remediation_qa_tools() IS 'Enforces that remediation WOs with unresolved QA findings must call resolve_qa_findings and update_qa_checklist tools before transitioning to done or review status';


--
-- Name: enforce_state_write(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.enforce_state_write() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_bypass TEXT;
BEGIN
  -- Check if bypass flag is set (set by state_write function)
  v_bypass := current_setting('app.state_write_bypass', true);
  
  IF v_bypass = 'true' THEN
    RETURN COALESCE(NEW, OLD);
  END IF;
  
  -- Block direct mutations
  RAISE EXCEPTION 'Direct % on % blocked. Use state_write() function.', TG_OP, TG_TABLE_NAME;
END;
$$;


--
-- Name: enforce_state_write_wo(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.enforce_state_write_wo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_bypass TEXT;
BEGIN
  v_bypass := current_setting('app.state_write_bypass', true);
  
  IF v_bypass = 'true' THEN
    RETURN COALESCE(NEW, OLD);
  END IF;
  
  -- Allow INSERT (creating new work orders) but block UPDATE/DELETE without state_write
  IF TG_OP = 'INSERT' THEN
    RETURN NEW;
  END IF;
  
  RAISE EXCEPTION 'Direct % on work_orders blocked. Use state_write() function.', TG_OP;
END;
$$;


--
-- Name: enforce_wo_state_changes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.enforce_wo_state_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_bypass text;
  v_result jsonb;
  v_caller text;
BEGIN
  -- K002: Nonce-based authorization (replaces wo_enforce_bypass flag)
  -- wo_transition() sets this nonce per-transaction; all code in the same
  -- transaction (including outbox effect handlers) inherits authorization.
  IF COALESCE(current_setting('app.wo_transition_nonce', true), '') != '' THEN
    RETURN NEW;
  END IF;

  -- LEGACY: Keep old bypass for backward compat with work-order-executor
  v_bypass := current_setting('app.wo_executor_bypass', true);
  IF v_bypass = 'true' THEN
    IF COALESCE(current_setting('app.wo_trigger_context', true), '') != 'true' THEN
      v_caller := COALESCE(current_setting('app.wo_executor_agent_name', true), 'unknown');
      RAISE EXCEPTION 'Bypass rejected: no trigger context. Caller: %. (WO-0399)', v_caller;
    END IF;

    v_result := validate_wo_transition(OLD.status, NEW.status, NEW);
    IF NOT (v_result->>'valid')::boolean THEN
      RAISE EXCEPTION 'Transition rejected even with bypass: %', v_result->>'errors';
    END IF;

    v_caller := COALESCE(current_setting('app.wo_executor_agent_name', true), 'trigger');
    IF v_caller NOT IN ('wo-agent', 'work-order-executor', 'auto-qa', 'health-check', 'trigger', 'unknown') THEN
      INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload, previous_state, new_state)
      VALUES ('bypass_used_by_non_executor', 'agent', v_caller, 'work_order', NEW.id,
        format('%s -> %s (bypass by %s)', OLD.status, NEW.status, v_caller),
        jsonb_build_object('caller', v_caller, 'wo_slug', NEW.slug),
        jsonb_build_object('status', OLD.status::text),
        jsonb_build_object('status', NEW.status::text));
    END IF;

    RETURN NEW;
  END IF;

  IF TG_OP = 'UPDATE' THEN
    IF (OLD.status IS DISTINCT FROM NEW.status) OR
       (OLD.approved_at IS DISTINCT FROM NEW.approved_at) OR
       (OLD.approved_by IS DISTINCT FROM NEW.approved_by) OR
       (OLD.started_at IS DISTINCT FROM NEW.started_at) OR
       (OLD.completed_at IS DISTINCT FROM NEW.completed_at) THEN
      RAISE EXCEPTION 'Direct work order state changes blocked. Use wo_transition() or METIS Portal.';
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: enforcer_verify_work_order(text, uuid, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.enforcer_verify_work_order(p_wo_id text, p_run_id uuid, p_verified boolean) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Verify caller is enforcer
  IF current_setting('request.jwt.claims', true)::json->>'sub' != 'enforcer-service' THEN
    RAISE EXCEPTION 'Unauthorized: only enforcer service can verify work orders';
  END IF;
  
  UPDATE work_orders
  SET 
    enforcer_verified = p_verified,
    enforcer_verified_at = CASE WHEN p_verified THEN NOW() ELSE NULL END,
    enforcer_run_id = p_run_id,
    updated_at = NOW()
  WHERE wo_id = p_wo_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Work order % not found', p_wo_id;
  END IF;
END;
$$;


--
-- Name: FUNCTION enforcer_verify_work_order(p_wo_id text, p_run_id uuid, p_verified boolean); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.enforcer_verify_work_order(p_wo_id text, p_run_id uuid, p_verified boolean) IS 'Enforcer-only function to mark work orders as verified';


--
-- Name: escalate_parent_on_all_children_failed(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.escalate_parent_on_all_children_failed() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  DECLARE
    v_parent_id uuid;
    v_parent_slug text;
    v_failed_sibling_count int;
    v_total_children int;
    v_parent_status text;
  BEGIN
    IF NEW.status != 'failed' OR OLD.status = 'failed' THEN
      RETURN NEW;
    END IF;
    
    IF NEW.parent_id IS NULL THEN
      RETURN NEW;
    END IF;
    
    SELECT id, slug, status INTO v_parent_id, v_parent_slug, v_parent_status
    FROM work_orders
    WHERE id = NEW.parent_id;
    
    IF v_parent_id IS NULL THEN
      RETURN NEW;
    END IF;
    
    IF v_parent_status IN ('done', 'cancelled', 'failed') THEN
      RETURN NEW;
    END IF;
    
    SELECT COUNT(*) INTO v_total_children
    FROM work_orders
    WHERE parent_id = v_parent_id;
    
    SELECT COUNT(*) INTO v_failed_sibling_count
    FROM work_orders
    WHERE parent_id = v_parent_id
      AND status = 'failed';
    
    IF v_failed_sibling_count = v_total_children 
       AND v_total_children > 0 THEN
      
      UPDATE work_orders
      SET status = 'failed',
          summary = 'All child work orders failed. Parent auto-failed via escalation.'
      WHERE id = v_parent_id;
      
      INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
      VALUES (v_parent_id, 'stream', 'system',
        jsonb_build_object(
          'event_type', 'escalation_failure_cascade',
          'content', format('Parent %s auto-failed: all %s children failed', v_parent_slug, v_failed_sibling_count),
          'failed_children', v_failed_sibling_count,
          'total_children', v_total_children
        )
      );
    END IF;
    
    RETURN NEW;
  END;
END;
$$;


--
-- Name: FUNCTION escalate_parent_on_all_children_failed(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.escalate_parent_on_all_children_failed() IS 'WO-0455 AC#3: Escalate parent to failed when all children reach failed state';


--
-- Name: estimate_cost(text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.estimate_cost(p_model_id text, p_input_tokens integer, p_output_tokens integer) RETURNS numeric
    LANGUAGE sql STABLE
    AS $$
  select 
    round(
      (p_input_tokens::numeric / 1000000 * mp.input_price_per_m) +
      (p_output_tokens::numeric / 1000000 * mp.output_price_per_m),
      6
    )
  from public.model_pricing mp
  where mp.model_id = p_model_id
  order by mp.effective_date desc
  limit 1;
$$;


--
-- Name: evaluate_auto_approval(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.evaluate_auto_approval(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo work_orders%ROWTYPE;
  v_risk JSONB;
  v_risk_score NUMERIC;
  v_denial_reasons TEXT[] := '{}';
  v_decision TEXT;
  v_tags TEXT[];
  v_daily_count INT;
  v_last_auto TIMESTAMPTZ;
  v_failed_recent BOOLEAN;
  v_consecutive_auto INT;
  v_max_daily INT;
  v_cooldown_minutes INT;
  v_max_consecutive INT;
  v_circuit_breaker BOOLEAN;
  v_enabled BOOLEAN;
  v_dry_run BOOLEAN;
  v_fast_path BOOLEAN := false;
BEGIN
  -- Fetch WO
  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  IF NOT FOUND THEN
    RETURN jsonb_build_object('error', 'Work order not found');
  END IF;

  v_tags := COALESCE(v_wo.tags, ARRAY[]::TEXT[]);

  -- Check if auto-approval is enabled
  SELECT COALESCE((value)::boolean, false) INTO v_enabled
  FROM user_preferences WHERE user_id = 'default' AND key = 'auto_approval_enabled';
  v_enabled := COALESCE(v_enabled, false);

  SELECT COALESCE((value)::boolean, true) INTO v_dry_run
  FROM user_preferences WHERE user_id = 'default' AND key = 'auto_approval_dry_run';
  v_dry_run := COALESCE(v_dry_run, true);

  -- Load safety rail settings
  SELECT COALESCE((value)::int, 10) INTO v_max_daily
  FROM user_preferences WHERE user_id = 'default' AND key = 'auto_approval_max_daily';
  v_max_daily := COALESCE(v_max_daily, 10);

  SELECT COALESCE((value)::int, 5) INTO v_cooldown_minutes
  FROM user_preferences WHERE user_id = 'default' AND key = 'auto_approval_cooldown_minutes';
  v_cooldown_minutes := COALESCE(v_cooldown_minutes, 5);

  SELECT COALESCE((value)::int, 5) INTO v_max_consecutive
  FROM user_preferences WHERE user_id = 'default' AND key = 'auto_approval_max_consecutive';
  v_max_consecutive := COALESCE(v_max_consecutive, 5);

  SELECT COALESCE((value)::boolean, false) INTO v_circuit_breaker
  FROM user_preferences WHERE user_id = 'default' AND key = 'auto_approval_circuit_breaker';
  v_circuit_breaker := COALESCE(v_circuit_breaker, false);

  -- Score risk
  v_risk := score_work_order_risk(p_work_order_id);
  v_risk_score := (v_risk->>'risk_score')::NUMERIC;

  -- ════════════════════════════════════════
  -- FAST PATH FOR TRIVIAL/SMALL WOs
  -- ════════════════════════════════════════
  -- Allow trivial/small/null complexity + p2_medium/p3_low + trusted sources
  IF COALESCE(v_wo.complexity::text, 'small') IN ('trivial', 'small') 
     AND v_wo.priority::text IN ('p2_medium', 'p3_low')
     AND v_wo.source IN ('cli', 'portal', 'direct', 'daemon', 'api', 'lesson_promoter', 'auto_approval')
     AND v_wo.project_brief_id IS NULL
     AND NOT ('security' = ANY(v_tags) OR 'manual-only' = ANY(v_tags))
     AND v_risk_score <= 50
  THEN
    v_fast_path := true;
  END IF;

  -- ════════════════════════════════════════
  -- HARD BLOCKERS (any one → deny, unless fast-path)
  -- ════════════════════════════════════════
  IF NOT v_fast_path THEN
    IF v_wo.priority::text = 'p0_critical' THEN
      v_denial_reasons := array_append(v_denial_reasons, 'Priority too high: ' || v_wo.priority::text);
    END IF;

    IF 'security' = ANY(v_tags) OR 'manual-only' = ANY(v_tags) THEN
      v_denial_reasons := array_append(v_denial_reasons, 'Blocked tag: ' || array_to_string(v_tags, ', '));
    END IF;

    IF v_wo.objective ~* '(drop |rls|row level|auth change|grant|revoke)' THEN
      v_denial_reasons := array_append(v_denial_reasons, 'High-risk keywords in objective');
    END IF;

    IF v_wo.project_brief_id IS NOT NULL THEN
      v_denial_reasons := array_append(v_denial_reasons, 'Project-scoped work requires human review');
    END IF;
  END IF;

  -- ════════════════════════════════════════
  -- SOFT QUALIFIERS (must pass ALL if no hard blockers)
  -- ════════════════════════════════════════
  IF array_length(v_denial_reasons, 1) IS NULL OR array_length(v_denial_reasons, 1) = 0 THEN
    -- Risk score check: 50 for fast-path, 40 for standard
    IF v_fast_path THEN
      IF v_risk_score > 50 THEN
        v_denial_reasons := array_append(v_denial_reasons, 'Risk score too high for fast-path: ' || v_risk_score::text);
      END IF;
    ELSE
      IF v_risk_score > 40 THEN
        v_denial_reasons := array_append(v_denial_reasons, 'Risk score too high: ' || v_risk_score::text);
      END IF;
    END IF;

    -- Priority check (P1 now allowed in standard path)
    IF NOT v_fast_path AND v_wo.priority::text NOT IN ('p1_high', 'p2_medium', 'p3_low') THEN
      v_denial_reasons := array_append(v_denial_reasons, 'Priority not eligible');
    END IF;

    -- Source/tag check: expanded allowlist
    IF NOT v_fast_path AND NOT (
      v_wo.source IN ('cli', 'portal', 'direct', 'daemon', 'api', 'lesson_promoter', 'auto_approval') OR
      'self-update' = ANY(v_tags) OR 'qa' = ANY(v_tags) OR 'minor-fix' = ANY(v_tags) OR
      'performance' = ANY(v_tags) OR 'monitoring' = ANY(v_tags) OR
      'error-handling' = ANY(v_tags) OR 'schema' = ANY(v_tags) OR
      'observability' = ANY(v_tags) OR 'remediation' = ANY(v_tags) OR
      'phase1' = ANY(v_tags) OR 'phase2' = ANY(v_tags) OR 'phase-6' = ANY(v_tags) OR
      'core-tighten' = ANY(v_tags) OR 'auto-qa-loop' = ANY(v_tags)
    ) THEN
      v_denial_reasons := array_append(v_denial_reasons, 'Source/tags not in auto-approval allowlist');
    END IF;

    -- Daily limit
    SELECT COUNT(*) INTO v_daily_count
    FROM auto_approval_log
    WHERE decision IN ('approved', 'dry_run')
      AND created_at >= now() - interval '24 hours';
    IF v_daily_count >= v_max_daily THEN
      v_denial_reasons := array_append(v_denial_reasons, 'Daily auto-approval limit reached: ' || v_daily_count::text);
    END IF;

    -- Cooldown
    SELECT MAX(created_at) INTO v_last_auto
    FROM auto_approval_log
    WHERE decision IN ('approved', 'dry_run');
    IF v_last_auto IS NOT NULL AND v_last_auto > now() - (v_cooldown_minutes || ' minutes')::interval THEN
      v_denial_reasons := array_append(v_denial_reasons, 'Cooldown period not elapsed');
    END IF;

    -- Circuit breaker
    IF v_circuit_breaker THEN
      v_denial_reasons := array_append(v_denial_reasons, 'Circuit breaker is active');
    END IF;

    -- Failed auto-approved WO in last 24h
    SELECT EXISTS(
      SELECT 1 FROM auto_approval_log al
      JOIN work_orders wo ON wo.id = al.work_order_id
      WHERE al.decision = 'approved'
        AND al.created_at >= now() - interval '24 hours'
        AND wo.status = 'failed'
    ) INTO v_failed_recent;
    IF v_failed_recent THEN
      v_denial_reasons := array_append(v_denial_reasons, 'Recent auto-approved WO failed (24h pause)');
    END IF;

    -- Max consecutive without human WO
    SELECT COUNT(*) INTO v_consecutive_auto
    FROM (
      SELECT id, source,
        ROW_NUMBER() OVER (ORDER BY completed_at DESC) as rn
      FROM work_orders
      WHERE status = 'done' AND completed_at IS NOT NULL
      ORDER BY completed_at DESC
      LIMIT 10
    ) recent
    WHERE recent.source IN ('lesson_promoter', 'auto_approval')
      AND recent.rn <= v_max_consecutive;
    IF v_consecutive_auto >= v_max_consecutive THEN
      v_denial_reasons := array_append(v_denial_reasons, 'Max consecutive auto WOs reached');
    END IF;
  END IF;

  -- ════════════════════════════════════════
  -- DECISION
  -- ════════════════════════════════════════
  IF array_length(v_denial_reasons, 1) > 0 THEN
    v_decision := 'denied';
  ELSIF NOT v_enabled THEN
    v_decision := 'denied';
    v_denial_reasons := array_append(v_denial_reasons, 'Auto-approval not enabled');
  ELSIF v_dry_run THEN
    v_decision := 'dry_run';
  ELSE
    v_decision := 'approved';
  END IF;

  -- Log the decision
  INSERT INTO auto_approval_log (work_order_id, risk_score, risk_dimensions, decision, denial_reasons)
  VALUES (p_work_order_id, v_risk_score, v_risk->'dimensions', v_decision, NULLIF(v_denial_reasons, '{}'));

  -- If approved (not dry_run), actually start the WO
  IF v_decision = 'approved' THEN
    PERFORM start_work_order(p_work_order_id);

    INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
    VALUES (
      'auto_approval', 'system', 'evaluate_auto_approval',
      'work_order', p_work_order_id,
      'auto_approved',
      jsonb_build_object(
        'risk_score', v_risk_score,
        'wo_slug', v_wo.slug,
        'source', v_wo.source,
        'tags', to_jsonb(v_tags),
        'fast_path', v_fast_path
      )
    );
  END IF;

  RETURN jsonb_build_object(
    'decision', v_decision,
    'risk_score', v_risk_score,
    'risk_dimensions', v_risk->'dimensions',
    'denial_reasons', COALESCE(to_jsonb(v_denial_reasons), '[]'::jsonb),
    'work_order_id', p_work_order_id,
    'enabled', v_enabled,
    'dry_run_mode', v_dry_run,
    'fast_path_eligible', v_fast_path
  );
END;
$$;


--
-- Name: evaluate_circuit_breaker_progress(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.evaluate_circuit_breaker_progress(p_wo_id uuid, p_checkpoint_count integer, p_previous_mutation_count integer DEFAULT NULL::integer) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_current_mutations INTEGER;
  v_mutation_delta INTEGER;
  v_decision TEXT;
  v_reason TEXT;
BEGIN
  -- Query current mutation count from wo_mutation_summary
  SELECT COALESCE(total_mutations, 0)
  INTO v_current_mutations
  FROM wo_mutation_summary
  WHERE work_order_id = p_wo_id;

  -- Calculate delta
  IF p_previous_mutation_count IS NULL THEN
    -- First checkpoint - no previous data to compare
    v_mutation_delta := v_current_mutations;
    v_decision := 'continue';
    v_reason := 'First checkpoint, no previous mutation count to compare';
  ELSE
    v_mutation_delta := v_current_mutations - p_previous_mutation_count;
    
    -- Stuck detection: zero delta across consecutive checkpoints
    IF v_mutation_delta = 0 AND p_checkpoint_count >= 2 THEN
      v_decision := 'stuck';
      v_reason := format('No progress: 0 new mutations across 2 consecutive checkpoints (current: %s, previous: %s)',
                        v_current_mutations, p_previous_mutation_count);
    ELSE
      v_decision := 'continue';
      v_reason := format('%s new mutations detected (previous: %s -> current: %s)',
                        v_mutation_delta, p_previous_mutation_count, v_current_mutations);
    END IF;
  END IF;

  -- Hard cap check
  IF p_checkpoint_count >= 8 THEN
    v_decision := 'hard_cap';
    v_reason := format('Hard circuit breaker limit: %s checkpoints reached', p_checkpoint_count);
  END IF;

  RETURN jsonb_build_object(
    'decision', v_decision,
    'reason', v_reason,
    'mutation_count_current', v_current_mutations,
    'mutation_count_previous', p_previous_mutation_count,
    'mutation_delta', v_mutation_delta,
    'checkpoint_count', p_checkpoint_count
  );
END;
$$;


--
-- Name: FUNCTION evaluate_circuit_breaker_progress(p_wo_id uuid, p_checkpoint_count integer, p_previous_mutation_count integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.evaluate_circuit_breaker_progress(p_wo_id uuid, p_checkpoint_count integer, p_previous_mutation_count integer) IS 'WO-0499: Progress-based circuit breaker. Returns decision (continue/stuck/hard_cap) based on mutation delta across checkpoints.';


--
-- Name: evaluate_harden_phase(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.evaluate_harden_phase(p_red_wo_id uuid, p_blue_wo_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_red_findings JSONB;
  v_blue_fixes JSONB;
  v_unaddressed JSONB := '[]'::JSONB;
  v_red_findings_count INT;
  v_blue_fixes_count INT;
  v_addressed_count INT;
  v_result JSONB;
  r_record RECORD;
BEGIN
  -- Fix #2: Validate NULL inputs - return error verdict when both are NULL
  IF p_red_wo_id IS NULL AND p_blue_wo_id IS NULL THEN
    RETURN jsonb_build_object(
      'verdict', 'error',
      'error', 'Both red_wo_id and blue_wo_id are NULL - cannot evaluate',
      'red_findings_count', 0,
      'blue_fixes_count', 0
    );
  END IF;

  IF p_red_wo_id IS NULL THEN
    RETURN jsonb_build_object(
      'verdict', 'error',
      'error', 'red_wo_id is NULL - cannot evaluate red-team findings',
      'blue_fixes_count', 0
    );
  END IF;

  -- Get red-team findings (failed mutations from red WO)
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'object_id', object_id,
      'action', action,
      'error_detail', error_detail
    )
  ), '[]'::JSONB)
  INTO v_red_findings
  FROM wo_mutations
  WHERE work_order_id = p_red_wo_id AND success = false;

  -- Get blue-team fixes (successful mutations from blue WO)
  IF p_blue_wo_id IS NOT NULL THEN
    SELECT COALESCE(jsonb_agg(
      jsonb_build_object(
        'object_id', object_id,
        'action', action
      )
    ), '[]'::JSONB)
    INTO v_blue_fixes
    FROM wo_mutations
    WHERE work_order_id = p_blue_wo_id AND success = true;
  ELSE
    v_blue_fixes := '[]'::JSONB;
  END IF;

  v_red_findings_count := jsonb_array_length(COALESCE(v_red_findings, '[]'::JSONB));
  v_blue_fixes_count := jsonb_array_length(COALESCE(v_blue_fixes, '[]'::JSONB));

  -- Check each red finding against blue fixes
  v_unaddressed := '[]'::JSONB;
  v_addressed_count := 0;

  IF v_red_findings IS NOT NULL THEN
    FOR r_record IN SELECT * FROM jsonb_array_elements(v_red_findings) AS finding
    LOOP
      IF NOT EXISTS (
        SELECT 1 FROM jsonb_array_elements(v_blue_fixes) AS fix
        WHERE fix->>'object_id' = r_record.finding->>'object_id'
          AND fix->>'action' = r_record.finding->>'action'
      ) THEN
        v_unaddressed := v_unaddressed || r_record.finding;
      ELSE
        v_addressed_count := v_addressed_count + 1;
      END IF;
    END LOOP;
  END IF;

  -- Build result
  v_result := jsonb_build_object(
    'verdict', CASE WHEN jsonb_array_length(v_unaddressed) = 0 THEN 'pass' ELSE 'fail' END,
    'red_findings_count', v_red_findings_count,
    'blue_fixes_count', v_blue_fixes_count,
    'unaddressed', v_unaddressed,
    'addressed_count', v_addressed_count
  );

  RETURN v_result;
END;
$$;


--
-- Name: evaluate_invariants(jsonb, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.evaluate_invariants(p_wo jsonb, p_invariant_names text[]) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $_$
DECLARE
  v_invariants jsonb;
  v_invariant jsonb;
  v_name text;
  v_type text;
  v_passed boolean;
  v_all_passed boolean := true;
  v_results jsonb := '[]'::jsonb;
  v_field text;
  v_expected text;
  v_left_val numeric;
  v_right_val numeric;
  v_op text;
  v_func_name text;
  v_query_result boolean;
  v_message text;
  v_sub_names text[];
  v_sub_result jsonb;
BEGIN
  -- Load current spec invariants
  SELECT spec->'invariants' INTO v_invariants FROM kernel_spec ORDER BY id DESC LIMIT 1;

  IF v_invariants IS NULL OR v_invariants = '{}'::jsonb THEN
    RETURN jsonb_build_object('passed', true, 'results', '[]'::jsonb);
  END IF;

  IF p_invariant_names IS NULL OR array_length(p_invariant_names, 1) IS NULL THEN
    RETURN jsonb_build_object('passed', true, 'results', '[]'::jsonb);
  END IF;

  FOREACH v_name IN ARRAY p_invariant_names
  LOOP
    v_invariant := v_invariants->v_name;
    v_message := NULL;

    IF v_invariant IS NULL THEN
      v_results := v_results || jsonb_build_object(
        'name', v_name, 'passed', false,
        'message', 'Invariant not defined: ' || v_name,
        'evidence', '{}'::jsonb
      );
      v_all_passed := false;
      CONTINUE;
    END IF;

    v_type := v_invariant->>'type';
    v_message := v_invariant->>'message';
    v_passed := false;

    CASE v_type
      WHEN 'field_present' THEN
        v_field := v_invariant->>'field';
        v_passed := (p_wo->>v_field IS NOT NULL AND p_wo->>v_field != '');
        IF NOT v_passed THEN
          v_message := COALESCE(v_message, 'Field ' || v_field || ' must be present and non-empty');
        END IF;

      WHEN 'field_equals' THEN
        v_field := v_invariant->>'field';
        v_expected := v_invariant->>'expected';
        v_passed := (p_wo->>v_field = v_expected);
        IF NOT v_passed THEN
          v_message := COALESCE(v_message, 'Field ' || v_field || ' must equal ' || v_expected || ', got: ' || COALESCE(p_wo->>v_field, 'NULL'));
        END IF;

      WHEN 'expression' THEN
        v_field := v_invariant->>'left_field';
        v_op := v_invariant->>'operator';
        v_left_val := COALESCE((p_wo->>v_field)::numeric, 0);
        v_right_val := COALESCE(
          (p_wo->>(v_invariant->>'right_field'))::numeric,
          (v_invariant->>'right_value')::numeric,
          0
        );
        CASE v_op
          WHEN '<' THEN v_passed := v_left_val < v_right_val;
          WHEN '<=' THEN v_passed := v_left_val <= v_right_val;
          WHEN '>' THEN v_passed := v_left_val > v_right_val;
          WHEN '>=' THEN v_passed := v_left_val >= v_right_val;
          WHEN '=' THEN v_passed := v_left_val = v_right_val;
          WHEN '!=' THEN v_passed := v_left_val != v_right_val;
          ELSE v_passed := false; v_message := 'Unknown operator: ' || v_op;
        END CASE;
        IF NOT v_passed AND v_message IS NULL THEN
          v_message := v_field || '(' || v_left_val || ') ' || v_op || ' ' ||
            COALESCE(v_invariant->>'right_field', v_invariant->>'right_value') || '(' || v_right_val || ') failed';
        END IF;

      WHEN 'query' THEN
        v_func_name := v_invariant->>'function';
        BEGIN
          EXECUTE format('SELECT %I($1)', v_func_name) INTO v_query_result USING p_wo;
          v_passed := COALESCE(v_query_result, false);
        EXCEPTION WHEN OTHERS THEN
          v_passed := false;
          v_message := 'Query invariant error: ' || SQLERRM;
        END;

      WHEN 'composite_and' THEN
        SELECT array_agg(elem::text) INTO v_sub_names
        FROM jsonb_array_elements_text(v_invariant->'invariants') AS elem;
        v_sub_result := evaluate_invariants(p_wo, v_sub_names);
        v_passed := (v_sub_result->>'passed')::boolean;
        IF NOT v_passed THEN
          v_message := COALESCE(v_message, 'Composite AND: sub-invariant(s) failed');
        END IF;

      WHEN 'composite_or' THEN
        SELECT array_agg(elem::text) INTO v_sub_names
        FROM jsonb_array_elements_text(v_invariant->'invariants') AS elem;
        v_sub_result := evaluate_invariants(p_wo, v_sub_names);
        v_passed := EXISTS (
          SELECT 1 FROM jsonb_array_elements(v_sub_result->'results') AS r
          WHERE (r->>'passed')::boolean = true
        );
        IF NOT v_passed THEN
          v_message := COALESCE(v_message, 'Composite OR: all sub-invariants failed');
        END IF;

      ELSE
        v_passed := false;
        v_message := 'Unknown invariant type: ' || v_type;
    END CASE;

    v_results := v_results || jsonb_build_object(
      'name', v_name,
      'passed', v_passed,
      'message', CASE WHEN v_passed THEN NULL ELSE v_message END,
      'evidence', jsonb_build_object('type', v_type, 'evaluated_at', now()::text)
    );

    IF NOT v_passed THEN
      v_all_passed := false;
    END IF;
  END LOOP;

  RETURN jsonb_build_object('passed', v_all_passed, 'results', v_results);
END;
$_$;


--
-- Name: evaluate_transition(public.work_order_status, text, jsonb, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.evaluate_transition(p_current_status public.work_order_status, p_event text, p_payload jsonb DEFAULT '{}'::jsonb, p_depth integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_transition record;
  v_guard_result jsonb;
  v_max_depth int := 5;
BEGIN
  IF p_depth >= v_max_depth THEN
    RETURN jsonb_build_object('ok', false, 'new_status', NULL, 'effects', '[]', 'error', 'Max recursion depth exceeded');
  END IF;

  IF p_event = 'cancel' THEN
    RETURN jsonb_build_object('ok', true, 'new_status', 'cancelled', 'effects', '[]'::jsonb, 'error', NULL);
  END IF;

  SELECT * INTO v_transition FROM wo_state_machine
  WHERE from_status = p_current_status AND event = p_event AND enabled = true;

  IF v_transition.id IS NULL THEN
    RETURN jsonb_build_object('ok', false, 'new_status', NULL, 'effects', '[]', 
      'error', p_event || ' not valid from ' || p_current_status::text || ' status');
  END IF;

  -- Execute guard function if specified
  IF v_transition.guard_function IS NOT NULL THEN
    CASE v_transition.guard_function
      WHEN 'guard_start_work' THEN
        v_guard_result := guard_start_work(p_payload);
      WHEN 'guard_retry_limit' THEN
        v_guard_result := guard_retry_limit(p_payload);
        v_guard_result := jsonb_build_object(
          'ok', COALESCE((v_guard_result->>'allowed')::boolean, (v_guard_result->>'ok')::boolean, false),
          'error', v_guard_result->>'reason'
        );
      WHEN 'guard_remediation_qa_tools' THEN
        -- K001: Replaced trg_enforce_remediation_qa_tools trigger
        DECLARE v_wo_id_guard uuid;
        BEGIN
          v_wo_id_guard := (p_payload->>'work_order_id')::uuid;
          IF v_wo_id_guard IS NOT NULL AND NOT guard_remediation_qa_tools(v_wo_id_guard) THEN
            v_guard_result := jsonb_build_object('ok', false, 
              'error', 'Remediation WO has unresolved findings but QA tools were not called');
          ELSE
            v_guard_result := jsonb_build_object('ok', true);
          END IF;
        END;
      ELSE
        RETURN jsonb_build_object('ok', false, 'new_status', NULL, 'effects', '[]', 
          'error', 'Unknown guard: ' || v_transition.guard_function);
    END CASE;

    IF NOT COALESCE((v_guard_result->>'ok')::boolean, false) THEN
      RETURN jsonb_build_object('ok', false, 'new_status', NULL, 'effects', '[]', 
        'error', COALESCE(v_guard_result->>'error', 'Guard rejected'));
    END IF;
  END IF;

  RETURN jsonb_build_object('ok', true, 'new_status', v_transition.to_status, 'effects', v_transition.effects, 'error', NULL);

EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('ok', false, 'new_status', NULL, 'effects', '[]', 'error', 'evaluate_transition error: ' || SQLERRM);
END;
$$;


--
-- Name: evaluate_wo_context(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.evaluate_wo_context(p_wo_id uuid, p_proposed_action text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_wo RECORD;
  v_parent_status TEXT := NULL;
  v_parent_slug TEXT := NULL;
  v_remediation_depth INT := 0;
  v_children_active INT := 0;
  v_children_done INT := 0;
  v_dependency_status TEXT := 'all_satisfied';
  v_is_moot BOOLEAN := false;
  v_actor_type TEXT := 'system';
  v_verdict TEXT := 'proceed';
  v_reason TEXT := '';
  v_dep_id UUID;
  v_dep_status TEXT;
  v_current_id UUID;
  v_chain_depth INT := 0;
BEGIN
  -- Get the work order details
  SELECT * INTO v_wo FROM work_orders WHERE id = p_wo_id;
  
  IF v_wo IS NULL THEN
    RETURN jsonb_build_object(
      'verdict', 'skip',
      'reason', 'Work order not found',
      'parent_status', NULL,
      'remediation_depth', 0,
      'children_active', 0,
      'children_done', 0,
      'dependency_status', 'unknown',
      'is_moot', false,
      'actor_type', 'system'
    );
  END IF;

  -- Calculate remediation depth by walking up parent_id chain
  v_current_id := v_wo.parent_id;
  WHILE v_current_id IS NOT NULL AND v_chain_depth < 10 LOOP
    v_chain_depth := v_chain_depth + 1;
    
    DECLARE
      v_temp_tags TEXT[];
      v_temp_parent_id UUID;
    BEGIN
      SELECT parent_id, tags INTO v_temp_parent_id, v_temp_tags
      FROM work_orders 
      WHERE id = v_current_id;
      
      IF v_temp_parent_id IS NULL AND v_temp_tags IS NULL THEN
        EXIT;
      END IF;
      
      -- Count if this parent is also a remediation
      IF 'remediation' = ANY(COALESCE(v_temp_tags, ARRAY[]::TEXT[])) THEN
        v_remediation_depth := v_remediation_depth + 1;
      END IF;
      
      v_current_id := v_temp_parent_id;
    END;
  END LOOP;

  -- Get parent status if exists (store in separate variables, not RECORD)
  IF v_wo.parent_id IS NOT NULL THEN
    SELECT status, slug INTO v_parent_status, v_parent_slug 
    FROM work_orders 
    WHERE id = v_wo.parent_id;
  END IF;

  -- Check if this is a moot remediation (parent done/cancelled and this is a remediation)
  IF 'remediation' = ANY(COALESCE(v_wo.tags, ARRAY[]::TEXT[])) 
     AND v_parent_status IS NOT NULL
     AND v_parent_status IN ('done', 'cancelled') THEN
    v_is_moot := true;
  END IF;

  -- Count active and done children
  SELECT 
    COALESCE(COUNT(*) FILTER (WHERE status IN ('draft', 'ready', 'pending_approval', 'in_progress', 'review', 'blocked')), 0) AS active,
    COALESCE(COUNT(*) FILTER (WHERE status IN ('done', 'cancelled')), 0) AS done
  INTO v_children_active, v_children_done
  FROM work_orders
  WHERE parent_id = p_wo_id;

  -- Check dependency status
  IF v_wo.depends_on IS NOT NULL AND array_length(v_wo.depends_on, 1) > 0 THEN
    DECLARE
      v_satisfied_count INT := 0;
      v_total_deps INT := array_length(v_wo.depends_on, 1);
    BEGIN
      FOR v_dep_id IN SELECT unnest(v_wo.depends_on) LOOP
        SELECT status INTO v_dep_status FROM work_orders WHERE id = v_dep_id;
        
        IF v_dep_status = 'done' THEN
          v_satisfied_count := v_satisfied_count + 1;
        ELSIF v_dep_status IN ('cancelled', 'failed') THEN
          v_dependency_status := 'blocked';
        END IF;
      END LOOP;
      
      IF v_dependency_status != 'blocked' THEN
        IF v_satisfied_count = v_total_deps THEN
          v_dependency_status := 'all_satisfied';
        ELSIF v_satisfied_count > 0 THEN
          v_dependency_status := 'partially_satisfied';
        ELSE
          v_dependency_status := 'blocked';
        END IF;
      END IF;
    END;
  END IF;

  -- Determine actor_type from most recent state_mutation or source field
  SELECT COALESCE(actor_type, 'system') INTO v_actor_type
  FROM (
    SELECT 
      CASE 
        WHEN sm.id IS NOT NULL THEN 
          CASE 
            WHEN a.name IN ('ilmarinen', 'you') THEN 'human'
            ELSE 'agent'
          END
        ELSE 'system'
      END AS actor_type
    FROM work_orders wo
    LEFT JOIN state_mutations sm ON sm.work_order_id = wo.id
    LEFT JOIN agents a ON sm.agent_id = a.id
    WHERE wo.id = p_wo_id
    ORDER BY sm.created_at DESC NULLS LAST
    LIMIT 1
  ) actor;
  
  -- If no state_mutations, check source field
  IF v_actor_type = 'system' AND v_wo.source IN ('portal', 'cli') THEN
    v_actor_type := 'human';
  END IF;

  -- Evaluate based on proposed action
  CASE p_proposed_action
    WHEN 'create_remediation' THEN
      -- Check if parent is already done
      IF v_parent_status IS NOT NULL AND v_parent_status IN ('done', 'cancelled') THEN
        v_verdict := 'skip';
        v_reason := format('Parent %s already %s, remediation not needed', v_parent_slug, v_parent_status);
      
      -- Check remediation depth (max 2 as per WO-0363)
      ELSIF v_remediation_depth >= 2 THEN
        v_verdict := 'escalate';
        v_reason := format('Remediation depth limit reached (%s/2), escalate to human', v_remediation_depth);
      
      -- All checks pass
      ELSE
        v_verdict := 'proceed';
        v_reason := 'Remediation creation allowed';
      END IF;

    WHEN 'start_execution' THEN
      -- Check if moot (remediation with done/cancelled parent)
      IF v_is_moot THEN
        v_verdict := 'cancel';
        v_reason := format('Parent %s already %s, execution unnecessary', v_parent_slug, v_parent_status);
      
      -- Check dependencies
      ELSIF v_dependency_status = 'blocked' THEN
        v_verdict := 'skip';
        v_reason := 'Dependencies not satisfied, execution blocked';
      
      -- All checks pass
      ELSE
        v_verdict := 'proceed';
        v_reason := 'Execution allowed';
      END IF;

    WHEN 'transition_to_failed' THEN
      -- Check if human-initiated (should NOT auto-create remediation)
      IF v_actor_type = 'human' THEN
        v_verdict := 'skip';
        v_reason := 'Human-initiated failure, skip auto-remediation';
      
      -- System-initiated, allow cascade
      ELSE
        v_verdict := 'proceed';
        v_reason := 'System failure, auto-remediation allowed';
      END IF;

    WHEN 'create_child' THEN
      -- Check remediation depth to prevent deep nesting
      IF v_remediation_depth >= 3 THEN
        v_verdict := 'escalate';
        v_reason := format('Chain depth %s exceeds safe limit for child creation', v_remediation_depth);
      ELSE
        v_verdict := 'proceed';
        v_reason := 'Child creation allowed';
      END IF;

    WHEN 'close_parent' THEN
      -- Check if all children are terminal
      IF v_children_active > 0 THEN
        v_verdict := 'skip';
        v_reason := format('%s active children remain, cannot close parent yet', v_children_active);
      ELSE
        v_verdict := 'proceed';
        v_reason := 'All children terminal, parent can be closed';
      END IF;

    ELSE
      -- Unknown action, default to proceed with warning
      v_verdict := 'proceed';
      v_reason := format('Unknown action %s, defaulting to proceed', p_proposed_action);
  END CASE;

  -- Return comprehensive verdict (now using separate variables instead of v_parent.field)
  RETURN jsonb_build_object(
    'verdict', v_verdict,
    'reason', v_reason,
    'parent_status', v_parent_status,
    'remediation_depth', v_remediation_depth,
    'children_active', v_children_active,
    'children_done', v_children_done,
    'dependency_status', v_dependency_status,
    'is_moot', v_is_moot,
    'actor_type', v_actor_type,
    'wo_status', v_wo.status,
    'wo_slug', v_wo.slug
  );
END;
$$;


--
-- Name: FUNCTION evaluate_wo_context(p_wo_id uuid, p_proposed_action text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.evaluate_wo_context(p_wo_id uuid, p_proposed_action text) IS 'WO-0367: Central lifecycle decision-maker. Returns verdict (proceed/skip/cancel/escalate) for proposed actions (create_remediation, start_execution, transition_to_failed, create_child, close_parent)';


--
-- Name: evaluate_wo_lifecycle(uuid, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.evaluate_wo_lifecycle(p_wo_id uuid, p_event_type text, p_event_context jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo RECORD;
  v_context JSONB;
  v_verdict TEXT;
  v_reason TEXT;
  v_details JSONB := '{}';
  
  -- Productive delta — TWO counts (FIX: WO-0388)
  v_total_tools INT := 0;
  v_recent_mutation_count INT := 0;      -- since last checkpoint (for continue decisions)
  v_cumulative_mutation_count INT := 0;  -- across ALL checkpoints (for circuit breaker)
  v_mutation_ratio NUMERIC := 0;
  v_has_productive_delta BOOLEAN := false;
  v_checkpoint_count INT := 0;
  v_continuation_count INT := 0;
  
  -- Constants
  MUTATION_TOOLS CONSTANT TEXT[] := ARRAY[
    'apply_migration', 'github_write_file', 'github_edit_file', 
    'deploy_edge_function', 'resolve_qa_findings', 'update_qa_checklist',
    'mark_complete', 'transition_state', 'github_create_branch', 
    'github_create_pr', 'delegate_subtask'
  ];
  MAX_REMEDIATION_DEPTH CONSTANT INT := 2;
  MAX_CONTINUATIONS CONSTANT INT := 5;
BEGIN
  -- 1. Get the work order
  SELECT * INTO v_wo FROM work_orders WHERE id = p_wo_id;
  IF v_wo IS NULL THEN
    RETURN jsonb_build_object(
      'verdict', 'skip',
      'reason', 'Work order not found',
      'event_type', p_event_type,
      'productive_delta', false
    );
  END IF;

  -- 2. Get tree-aware context from evaluate_wo_context
  v_context := evaluate_wo_context(
    p_wo_id,
    CASE p_event_type
      WHEN 'status_change' THEN COALESCE(p_event_context->>'proposed_action', 'start_execution')
      WHEN 'checkpoint'    THEN 'start_execution'
      WHEN 'continuation'  THEN 'start_execution'
      WHEN 'timeout'       THEN 'transition_to_failed'
      WHEN 'child_complete' THEN 'close_parent'
      WHEN 'qa_verdict'    THEN 'start_execution'
      WHEN 'human_action'  THEN COALESCE(p_event_context->>'proposed_action', 'start_execution')
      ELSE 'start_execution'
    END
  );

  -- 3a. RECENT delta: mutations since last checkpoint (for continue-vs-stuck decisions)
  SELECT 
    COUNT(*) FILTER (WHERE detail->>'tool_name' IS NOT NULL),
    COUNT(*) FILTER (
      WHERE detail->>'tool_name' = ANY(MUTATION_TOOLS)
      AND (detail->>'success' IS NULL OR (detail->>'success')::boolean = true)
    )
  INTO v_total_tools, v_recent_mutation_count
  FROM work_order_execution_log
  WHERE work_order_id = p_wo_id
    AND phase = 'stream'
    AND created_at > COALESCE(
      (SELECT MAX(created_at) FROM work_order_execution_log 
       WHERE work_order_id = p_wo_id AND phase = 'checkpoint'),
      (SELECT MAX(created_at) FROM work_order_execution_log 
       WHERE work_order_id = p_wo_id AND phase = 'execution_start'),
      '1970-01-01'::timestamptz
    );

  -- 3b. CUMULATIVE delta: mutations across ALL checkpoints (FIX: WO-0388)
  --     This is the count that matters for circuit breaker review-vs-fail
  SELECT COUNT(*)
  INTO v_cumulative_mutation_count
  FROM work_order_execution_log
  WHERE work_order_id = p_wo_id
    AND phase = 'stream'
    AND detail->>'tool_name' = ANY(MUTATION_TOOLS)
    AND (detail->>'success' IS NULL OR (detail->>'success')::boolean = true);

  IF v_total_tools > 0 THEN
    v_mutation_ratio := v_cumulative_mutation_count::NUMERIC / v_total_tools;
  END IF;
  -- Circuit breaker uses CUMULATIVE count
  v_has_productive_delta := v_cumulative_mutation_count > 0;

  -- Count checkpoints and continuations
  SELECT 
    COUNT(*) FILTER (WHERE phase = 'checkpoint'),
    COUNT(*) FILTER (WHERE phase = 'continuation')
  INTO v_checkpoint_count, v_continuation_count
  FROM work_order_execution_log
  WHERE work_order_id = p_wo_id;

  -- Build delta details
  v_details := jsonb_build_object(
    'total_tools', v_total_tools,
    'recent_mutation_count', v_recent_mutation_count,
    'cumulative_mutation_count', v_cumulative_mutation_count,
    'mutation_count', v_cumulative_mutation_count,  -- backward compat
    'mutation_ratio', round(v_mutation_ratio, 3),
    'has_productive_delta', v_has_productive_delta,
    'checkpoint_count', v_checkpoint_count,
    'continuation_count', v_continuation_count
  );

  -- 4. Event-specific decision logic
  CASE p_event_type
  
    WHEN 'status_change' THEN
      DECLARE
        v_new_status TEXT := p_event_context->>'new_status';
        v_old_status TEXT := p_event_context->>'old_status';
      BEGIN
        IF v_new_status IN ('ready', 'in_progress') AND (v_context->>'is_moot')::boolean THEN
          v_verdict := 'cancel';
          v_reason := format('Moot: parent %s already %s', 
            v_context->>'wo_slug', v_context->>'parent_status');
            
        ELSIF v_new_status = 'failed' THEN
          IF (v_context->>'actor_type') = 'human' THEN
            v_verdict := 'fail';
            v_reason := 'Human-initiated failure, skip auto-remediation';
          ELSIF v_has_productive_delta THEN
            v_verdict := 'review';
            v_reason := format('Agent made %s mutations before failure, submitting for QA review', v_cumulative_mutation_count);
          ELSE
            v_verdict := 'fail';
            v_reason := 'System failure with no productive delta, allow remediation';
          END IF;
          
        ELSIF v_new_status = 'draft' AND p_event_context->>'proposed_action' = 'create_remediation' THEN
          v_verdict := v_context->>'verdict';
          v_reason := v_context->>'reason';
          
        ELSE
          v_verdict := 'proceed';
          v_reason := format('Status change %s → %s allowed', v_old_status, v_new_status);
        END IF;
      END;
      
    WHEN 'checkpoint' THEN
      IF (v_context->>'is_moot')::boolean THEN
        v_verdict := 'cancel';
        v_reason := format('Parent %s completed during execution, cancelling', v_context->>'wo_slug');
        
      ELSIF v_checkpoint_count >= MAX_CONTINUATIONS THEN
        -- Circuit breaker: uses CUMULATIVE count (not just recent)
        IF v_has_productive_delta THEN
          v_verdict := 'review';
          v_reason := format('Continuation limit (%s/%s) with %s cumulative mutations — submitting for QA', 
            v_checkpoint_count, MAX_CONTINUATIONS, v_cumulative_mutation_count);
        ELSE
          v_verdict := 'fail';
          v_reason := format('Continuation limit (%s/%s) with 0 mutations — truly stuck', 
            v_checkpoint_count, MAX_CONTINUATIONS);
        END IF;
        
      -- Under limit: use RECENT count to detect per-checkpoint progress
      ELSIF v_recent_mutation_count > 0 THEN
        v_verdict := 'continue';
        v_reason := format('Checkpoint %s/%s, %s recent mutations — continuing', 
          v_checkpoint_count, MAX_CONTINUATIONS, v_recent_mutation_count);
      ELSIF v_checkpoint_count >= 2 AND NOT v_has_productive_delta THEN
        -- Two checkpoints with no mutations EVER = stuck
        v_verdict := 'fail';
        v_reason := format('No mutations after %s checkpoints — agent stuck', v_checkpoint_count);
      ELSE
        v_verdict := 'continue';
        v_reason := format('Checkpoint %s/%s, no recent mutations but %s cumulative — within grace period', 
          v_checkpoint_count, MAX_CONTINUATIONS, v_cumulative_mutation_count);
      END IF;
      
    WHEN 'continuation' THEN
      IF (v_context->>'is_moot')::boolean THEN
        v_verdict := 'cancel';
        v_reason := 'Parent completed during execution, skip continuation';
      ELSE
        v_verdict := 'continue';
        v_reason := format('Continuation %s allowed', v_continuation_count);
      END IF;
      
    WHEN 'timeout' THEN
      IF (v_context->>'is_moot')::boolean THEN
        v_verdict := 'cancel';
        v_reason := 'Moot WO timed out, cancelling';
      ELSIF v_has_productive_delta THEN
        v_verdict := 'review';
        v_reason := format('Timeout with %s mutations — submitting for QA review', v_cumulative_mutation_count);
      ELSE
        v_verdict := 'fail';
        v_reason := 'Timeout with no productive delta';
      END IF;
      
    WHEN 'child_complete' THEN
      DECLARE
        v_child_status TEXT := p_event_context->>'child_status';
        v_active INT := (v_context->>'children_active')::int;
        v_done INT := (v_context->>'children_done')::int;
      BEGIN
        IF v_active = 0 AND v_done > 0 THEN
          v_verdict := 'complete';
          v_reason := format('All %s children complete, parent can close', v_done);
        ELSIF v_active > 0 THEN
          v_verdict := 'continue';
          v_reason := format('%s children still active, waiting', v_active);
        ELSE
          v_verdict := 'proceed';
          v_reason := 'No children found';
        END IF;
      END;
      
    WHEN 'qa_verdict' THEN
      DECLARE
        v_qa_result TEXT := COALESCE(p_event_context->>'result', 'unknown');
      BEGIN
        IF v_qa_result = 'pass' THEN
          v_verdict := 'complete';
          v_reason := 'QA passed, completing WO';
        ELSIF v_qa_result = 'fail' THEN
          IF (v_context->>'remediation_depth')::int >= MAX_REMEDIATION_DEPTH THEN
            v_verdict := 'escalate_human';
            v_reason := format('QA failed at remediation depth %s, escalating to human', 
              v_context->>'remediation_depth');
          ELSIF (v_context->>'is_moot')::boolean THEN
            v_verdict := 'cancel';
            v_reason := 'QA failed but WO is moot, cancelling instead of remediating';
          ELSE
            v_verdict := 'fail';
            v_reason := 'QA failed, remediation appropriate';
          END IF;
        ELSE
          v_verdict := 'proceed';
          v_reason := format('QA result %s, no action needed', v_qa_result);
        END IF;
      END;
      
    WHEN 'human_action' THEN
      v_verdict := 'proceed';
      v_reason := 'Human action respected, no auto-intervention';
      
    ELSE
      v_verdict := 'proceed';
      v_reason := format('Unknown event type %s, defaulting to proceed', p_event_type);
  END CASE;

  -- 5. Return comprehensive result
  RETURN jsonb_build_object(
    'verdict', v_verdict,
    'reason', v_reason,
    'event_type', p_event_type,
    'wo_slug', v_wo.slug,
    'wo_status', v_wo.status,
    'context', v_context,
    'delta', v_details,
    'event_context', p_event_context
  );
END;
$$;


--
-- Name: FUNCTION evaluate_wo_lifecycle(p_wo_id uuid, p_event_type text, p_event_context jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.evaluate_wo_lifecycle(p_wo_id uuid, p_event_type text, p_event_context jsonb) IS 'Central control plane for all WO lifecycle decisions. Called by triggers, health-check, circuit breaker, auto-QA pipeline. Returns verdict (continue/complete/cancel/review/fail/escalate_human/escalate_master/proceed/skip) with reasoning and productive delta metrics.';


--
-- Name: exec_sql(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.exec_sql(query text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  EXECUTE query;
  RETURN jsonb_build_object('success', true, 'query', query, 'executed_at', now());
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM, 'query', query);
END;
$$;


--
-- Name: execute_pending_migration(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.execute_pending_migration(p_slug text, p_executed_by text DEFAULT 'claude_code'::text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_migration pending_migrations;
  v_dep TEXT;
  v_dep_status TEXT;
  v_result JSONB;
BEGIN
  -- Get the migration
  SELECT * INTO v_migration FROM pending_migrations WHERE slug = p_slug;
  
  IF v_migration.id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Migration not found: ' || p_slug);
  END IF;
  
  IF v_migration.status != 'pending' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Migration not pending: ' || v_migration.status);
  END IF;
  
  -- Check dependencies
  IF v_migration.dependencies IS NOT NULL THEN
    FOREACH v_dep IN ARRAY v_migration.dependencies
    LOOP
      SELECT status INTO v_dep_status FROM pending_migrations WHERE slug = v_dep;
      IF v_dep_status IS NULL OR v_dep_status != 'completed' THEN
        RETURN jsonb_build_object('success', false, 'error', 'Dependency not completed: ' || v_dep);
      END IF;
    END LOOP;
  END IF;
  
  -- Mark as in progress
  UPDATE pending_migrations SET status = 'in_progress', updated_at = now() WHERE slug = p_slug;
  
  -- Execute the SQL
  BEGIN
    EXECUTE v_migration.sql_up;
    
    -- Mark as completed
    UPDATE pending_migrations SET 
      status = 'completed',
      executed_at = now(),
      executed_by = p_executed_by,
      updated_at = now()
    WHERE slug = p_slug;
    
    RETURN jsonb_build_object(
      'success', true, 
      'slug', p_slug, 
      'name', v_migration.name,
      'executed_at', now()
    );
    
  EXCEPTION WHEN OTHERS THEN
    -- Mark as failed
    UPDATE pending_migrations SET 
      status = 'failed',
      error_message = SQLERRM,
      updated_at = now()
    WHERE slug = p_slug;
    
    RETURN jsonb_build_object(
      'success', false, 
      'slug', p_slug,
      'error', SQLERRM
    );
  END;
END;
$$;


--
-- Name: export_project_docs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.export_project_docs(p_project_id uuid) RETURNS TABLE(filename text, content text)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    UPPER(pd.doc_type) || '.md' AS filename,
    '# ' || pd.title || E'\n\n' ||
    '> Project: ' || pb.name || E'\n' ||
    '> Version: ' || pd.version || E'\n' ||
    '> Updated: ' || pd.updated_at || E'\n\n---\n\n' ||
    pd.content AS content
  FROM project_documents pd
  JOIN project_briefs pb ON pd.project_id = pb.id
  WHERE pd.project_id = p_project_id AND pd.status != 'superseded'
  ORDER BY CASE pd.doc_type
    WHEN 'prd' THEN 1 WHEN 'app_flow' THEN 2 WHEN 'tech_stack' THEN 3
    WHEN 'frontend_guidelines' THEN 4 WHEN 'backend_structure' THEN 5
    WHEN 'implementation_plan' THEN 6
  END;
END;
$$;


--
-- Name: generate_claude_md(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.generate_claude_md(p_project_code text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_content TEXT := '';
  v_directive RECORD;
  v_project project_briefs;
BEGIN
  v_content := '# METIS System Rules' || E'\n\n';
  v_content := v_content || '**Generated:** ' || now() || E'\n';
  v_content := v_content || '**Source:** system_directives table' || E'\n\n---\n\n';
  
  IF p_project_code IS NOT NULL THEN
    SELECT * INTO v_project FROM project_briefs WHERE code = p_project_code;
    IF v_project.id IS NOT NULL THEN
      v_content := v_content || '## Project: ' || v_project.name || E'\n\n';
      v_content := v_content || COALESCE(v_project.summary, '') || E'\n\n---\n\n';
    END IF;
  END IF;
  
  v_content := v_content || '## Hard Constraints' || E'\n\n';
  FOR v_directive IN 
    SELECT name, content FROM system_directives 
    WHERE scope = 'global' AND active = true AND enforcement = 'hard'
    ORDER BY priority DESC
  LOOP
    v_content := v_content || '### ' || v_directive.name || E'\n';
    v_content := v_content || v_directive.content || E'\n\n';
  END LOOP;
  
  v_content := v_content || '## Rules' || E'\n\n';
  FOR v_directive IN 
    SELECT name, content FROM system_directives 
    WHERE scope = 'global' AND active = true AND enforcement = 'soft'
    ORDER BY priority DESC
  LOOP
    v_content := v_content || '### ' || v_directive.name || E'\n';
    v_content := v_content || v_directive.content || E'\n\n';
  END LOOP;
  
  v_content := v_content || '## Tool Policies' || E'\n\n';
  FOR v_directive IN 
    SELECT name, content FROM system_directives 
    WHERE scope = 'global' AND active = true AND directive_type = 'tool_policy'
    ORDER BY priority DESC
  LOOP
    v_content := v_content || '### ' || v_directive.name || E'\n';
    v_content := v_content || v_directive.content || E'\n\n';
  END LOOP;
  
  v_content := v_content || '## Capabilities' || E'\n\n';
  v_content := v_content || '| Type | Name | Status |' || E'\n';
  v_content := v_content || '|------|------|--------|' || E'\n';
  FOR v_directive IN 
    SELECT capability_type, name, status FROM metis_capabilities WHERE status = 'active' ORDER BY capability_type, name
  LOOP
    v_content := v_content || '| ' || v_directive.capability_type || ' | ' || v_directive.name || ' | ' || v_directive.status || ' |' || E'\n';
  END LOOP;
  
  RETURN v_content;
END;
$$;


--
-- Name: generate_cli_claude_md(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.generate_cli_claude_md(p_project_code text DEFAULT 'METIS-001'::text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_output text := '';
  v_project RECORD;
  v_agent RECORD;
  v_wo RECORD;
  v_directive RECORD;
  v_lesson_count integer;
  v_unpromoted_lesson_count integer;
  v_completed_week_count integer;
  v_blocked_count integer;
  v_daemon RECORD;
BEGIN
  -- Get project brief
  SELECT * INTO v_project FROM project_briefs WHERE code = p_project_code LIMIT 1;
  
  -- Header
  v_output := '# METIS Context - Auto-Generated' || E'\n';
  v_output := v_output || '**Session Start**: ' || to_char(NOW(), 'YYYY-MM-DD"T"HH24:MI:SS.US') || E'\n';
  v_output := v_output || '**Project**: ' || COALESCE(v_project.code, 'METIS-001') || E'\n\n';
  
  -- Phase Status
  v_output := v_output || '## Phase Status' || E'\n';
  v_output := v_output || '- **Current Phase**: ' || COALESCE(v_project.current_phase::text, '6') || E'\n';
  v_output := v_output || '- **Completion**: ' || COALESCE(v_project.completion_pct::text, '95') || '%' || E'\n';
  
  -- Daemon status
  SELECT * INTO v_daemon FROM system_status WHERE component = 'daemon' LIMIT 1;
  v_output := v_output || '- **Daemon**: ' || 
    COALESCE(UPPER(v_daemon.status), 'UNKNOWN') || 
    COALESCE(' (last heartbeat: ' || v_daemon.last_heartbeat::text || ')', '') || E'\n\n';
  
  -- Critical constraints from directives
  v_output := v_output || '## ⛔ CRITICAL CONSTRAINTS' || E'\n';
  FOR v_directive IN 
    SELECT name, content, priority 
    FROM system_directives 
    WHERE active = true 
      AND enforcement_mode IN ('context_only', 'pre_check', 'post_check')
    ORDER BY priority DESC
    LIMIT 10
  LOOP
    v_output := v_output || '- **' || v_directive.name || '**: ' || 
      LEFT(REPLACE(v_directive.content, E'\n', ' '), 200) || E'\n';
  END LOOP;
  v_output := v_output || E'\n';
  
  -- Team (agents)
  v_output := v_output || '## Team (' || (SELECT COUNT(*)::text FROM agents WHERE status = 'active') || ' agents)' || E'\n';
  FOR v_agent IN 
    SELECT name, agent_type, description 
    FROM agents 
    WHERE status = 'active' 
    ORDER BY 
      CASE agent_type 
        WHEN 'leader' THEN 1 
        WHEN 'executor' THEN 2 
        WHEN 'specialist' THEN 3 
        WHEN 'reviewer' THEN 4 
        ELSE 5 
      END, name
  LOOP
    v_output := v_output || '- ' || v_agent.name || ' (' || v_agent.agent_type || ')' || E'\n';
  END LOOP;
  v_output := v_output || E'\n';
  
  -- Agent Hierarchy (NEW SECTION for WO-0124)
  v_output := v_output || '## Agent Hierarchy' || E'\n';
  v_output := v_output || E'\n';
  v_output := v_output || '**Execution Flow**: User → METIS → Work Orders → Daemon (scheduler) → Worker Agents (gated) → Auto-QA' || E'\n\n';
  v_output := v_output || '### Roles' || E'\n\n';
  v_output := v_output || '1. **User**: Interacts via Portal or CLI, creates requests' || E'\n';
  v_output := v_output || '2. **METIS (metis agent)**: Orchestrator - receives intent, creates work orders, routes tasks' || E'\n';
  v_output := v_output || '3. **Work Orders**: Task units that flow through the state machine (draft → ready → approved → in_progress → review → done)' || E'\n';
  v_output := v_output || '4. **Daemon Scheduler**: Polls for approved WOs, claims them atomically, spawns worker agents with full context injection' || E'\n';
  v_output := v_output || '5. **Worker Agent Pool**: Ephemeral execution agents (worker-WO-XXX-{uuid}) that execute individual WOs under strict guardrails' || E'\n';
  v_output := v_output || '   - Restricted permissions: cannot bypass state machine, must use TodoWrite, must log all actions' || E'\n';
  v_output := v_output || '   - Write access only via state_write() RPC, must use CLI for large deployments (>100 lines)' || E'\n';
  v_output := v_output || '   - Each worker has unique identity and operates in isolated subprocess' || E'\n';
  v_output := v_output || '6. **Auto-QA**: Automated quality assurance that validates WO completion against acceptance criteria' || E'\n';
  v_output := v_output || '7. **Ilmarinen (super admin)**: On-demand supervisor with unrestricted access, invoked by user for manual intervention, architecture decisions, or emergency fixes' || E'\n';
  v_output := v_output || E'\n';
  
  -- Active Work Orders
  v_output := v_output || '## Active Work Orders' || E'\n';
  FOR v_wo IN 
    SELECT slug, name, status, LEFT(objective, 60) as short_obj
    FROM work_orders 
    WHERE status IN ('ready', 'in_progress', 'blocked', 'review')
    ORDER BY 
      CASE status 
        WHEN 'in_progress' THEN 1 
        WHEN 'ready' THEN 2 
        WHEN 'blocked' THEN 3 
        WHEN 'review' THEN 4 
      END, created_at DESC
    LIMIT 10
  LOOP
    v_output := v_output || '- `' || v_wo.slug || '` [' || v_wo.status || ']: ' || 
      v_wo.name || ' — ' || v_wo.short_obj || E'\n';
  END LOOP;
  v_output := v_output || E'\n';
  
  -- Recent Completions
  SELECT COUNT(*) INTO v_completed_week_count 
  FROM work_orders 
  WHERE status = 'done' AND completed_at >= NOW() - INTERVAL '7 days';
  
  v_output := v_output || '## Recent Completions (7d)' || E'\n';
  FOR v_wo IN 
    SELECT slug, LEFT(name, 50) as short_name, LEFT(objective, 60) as short_obj
    FROM work_orders 
    WHERE status = 'done' AND completed_at >= NOW() - INTERVAL '7 days'
    ORDER BY completed_at DESC
    LIMIT 10
  LOOP
    v_output := v_output || '- `' || v_wo.slug || '`: ' || v_wo.short_name || ' — ' || v_wo.short_obj || E'\n';
  END LOOP;
  v_output := v_output || E'\n';
  
  -- System Health
  SELECT COUNT(*) INTO v_lesson_count FROM lessons;
  SELECT COUNT(*) INTO v_unpromoted_lesson_count FROM lessons WHERE promoted_at IS NULL;
  SELECT COUNT(*) INTO v_blocked_count FROM work_orders WHERE status = 'blocked';
  
  v_output := v_output || '## System Health' || E'\n';
  v_output := v_output || '- **Lessons**: ' || v_lesson_count || ' total, ' || v_unpromoted_lesson_count || ' unpromoted' || E'\n';
  v_output := v_output || '- **Directives**: ' || (SELECT COUNT(*)::text FROM system_directives WHERE active = true) || ' active' || E'\n';
  v_output := v_output || '- **Completed this week**: ' || v_completed_week_count || E'\n';
  v_output := v_output || '- **Blocked WOs**: ' || v_blocked_count || E'\n\n';
  
  -- Architecture Rules
  v_output := v_output || '## Architecture Rules' || E'\n';
  v_output := v_output || '1. Build tasks require approved work orders' || E'\n';
  v_output := v_output || '2. All mutations logged to Supabase' || E'\n';
  v_output := v_output || '3. You are ILMARINEN (builder agent)' || E'\n';
  v_output := v_output || '4. METIS (orchestrator) handles routing' || E'\n\n';
  
  v_output := v_output || '---' || E'\n';
  v_output := v_output || '*Auto-generated by METIS hooks v2*' || E'\n';
  
  RETURN v_output;
END;
$$;


--
-- Name: generate_manifest_from_template(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.generate_manifest_from_template(p_work_order_id uuid, p_steps jsonb) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_step jsonb;
  v_count int := 0;
  v_ac_number int;
  v_step_order int;
  v_expected_tool text;
  v_expected_action text;
  v_expected_object_type text;
  v_expected_object_id text;
  v_required boolean;
BEGIN
  -- Verify work_order_id exists
  IF NOT EXISTS (SELECT 1 FROM work_orders WHERE id = p_work_order_id) THEN
    RAISE EXCEPTION 'Work order with id % does not exist', p_work_order_id;
  END IF;

  -- Process each step in the array
  FOR v_step IN SELECT * FROM jsonb_array_elements(p_steps)
  LOOP
    v_ac_number := (v_step->>'ac_number')::int;
    v_step_order := (v_step->>'step_order')::int;
    v_expected_tool := v_step->>'expected_tool';
    v_expected_action := v_step->>'expected_action';
    v_expected_object_type := v_step->>'expected_object_type';
    v_expected_object_id := v_step->>'expected_object_id';
    v_required := COALESCE((v_step->>'required')::boolean, true);

    INSERT INTO wo_execution_manifest (
      work_order_id,
      ac_number,
      step_order,
      expected_tool,
      expected_action,
      expected_object_type,
      expected_object_id,
      required,
      discovered
    ) VALUES (
      p_work_order_id,
      v_ac_number,
      v_step_order,
      v_expected_tool,
      v_expected_action,
      v_expected_object_type,
      v_expected_object_id,
      v_required,
      false  -- discovered defaults to false for template steps
    );

    v_count := v_count + 1;
  END LOOP;

  RETURN v_count;
END;
$$;


--
-- Name: generate_project_documents(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.generate_project_documents() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO project_documents (project_id, doc_type, title, content, version, status, created_by)
  VALUES 
    (NEW.id, 'prd', 'Product Requirements Document', 
     '# ' || COALESCE(NEW.name, 'Untitled Project') || E'\n\n## Overview\n' || COALESCE(NEW.summary, 'TBD') || E'\n\n## Objectives\nTBD\n\n## User Stories\nTBD\n\n## Success Criteria\nTBD', 
     1, 'draft', 'system'),
    
    (NEW.id, 'app_flow', 'Application Flow', 
     E'# Application Flow\n\n## User Journeys\nTBD\n\n## State Machine\nTBD\n\n## Data Flow\nTBD\n\n## API Contracts\nTBD', 
     1, 'draft', 'system'),
    
    (NEW.id, 'tech_stack', 'Technology Stack', 
     E'# Technology Stack\n\n## Languages & Frameworks\nTBD\n\n## Infrastructure\nTBD\n\n## Dependencies\nTBD\n\n## Security\nTBD', 
     1, 'draft', 'system'),
    
    (NEW.id, 'frontend_guidelines', 'Frontend Guidelines', 
     E'# Frontend Guidelines\n\n## Component Architecture\nTBD\n\n## Styling Conventions\nTBD\n\n## State Management\nTBD\n\n## Accessibility\nTBD', 
     1, 'draft', 'system'),
    
    (NEW.id, 'backend_structure', 'Backend Structure', 
     E'# Backend Structure\n\n## API Design\nTBD\n\n## Database Schema\nTBD\n\n## Services & Functions\nTBD\n\n## Error Handling\nTBD', 
     1, 'draft', 'system'),
    
    (NEW.id, 'implementation_plan', 'Implementation Plan', 
     E'# Implementation Plan\n\n## Phase 1\nTBD\n\n## Phase 2\nTBD\n\n## Milestones\nTBD\n\n## Risk Mitigation\nTBD', 
     1, 'draft', 'system'),

    (NEW.id, 'security_model', 'Security Model', 
     E'# Security Model\n\n## Threat Model\nTBD\n\n## Authentication & Authorization\nTBD\n\n## RLS Policies\nTBD\n\n## Secrets Management\nTBD\n\n## Audit & Compliance\nTBD', 
     1, 'draft', 'system'),

    (NEW.id, 'testing_strategy', 'Testing Strategy', 
     E'# Testing Strategy\n\n## Unit Tests\nTBD\n\n## Integration Tests\nTBD\n\n## E2E Tests\nTBD\n\n## Regression & Smoke Tests\nTBD\n\n## Acceptance Criteria Verification\nTBD', 
     1, 'draft', 'system');

  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION generate_project_documents(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.generate_project_documents() IS 'Auto-generates 6 standard project documents (prd, app_flow, tech_stack, frontend_guidelines, backend_structure, implementation_plan) when a new project_briefs row is created. Part of pseudosystem Phase 3 integration.';


--
-- Name: generate_request_signature(text, timestamp with time zone, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.generate_request_signature(p_request_id text, p_timestamp timestamp with time zone, p_payload_hash text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_secret TEXT;
  v_message TEXT;
BEGIN
  -- Get signing secret from secrets table
  SELECT value INTO v_secret FROM secrets WHERE key = 'REQUEST_SIGNING_KEY';
  
  IF v_secret IS NULL THEN
    RAISE EXCEPTION 'REQUEST_SIGNING_KEY not configured';
  END IF;
  
  -- Create message to sign: request_id|timestamp|payload_hash
  v_message := p_request_id || '|' || p_timestamp::TEXT || '|' || p_payload_hash;
  
  -- Return HMAC-SHA256 signature
  RETURN encode(
    extensions.hmac(v_message::bytea, v_secret::bytea, 'sha256'),
    'hex'
  );
END;
$$;


--
-- Name: generate_wo_scorecard(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.generate_wo_scorecard(p_work_order_id uuid) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_scorecard_id UUID;
  v_wo_record RECORD;
  
  -- Raw metrics
  v_total_iterations INTEGER;
  v_total_mutations INTEGER;
  v_execution_duration_minutes NUMERIC;
  v_qa_checklist_items INTEGER;
  v_qa_passed_items INTEGER;
  v_qa_findings_total INTEGER;
  v_qa_findings_resolved INTEGER;
  v_evidence_log_count INTEGER;
  v_checkpoint_count INTEGER;
  v_violations_count INTEGER;
  
  -- Calculated scores
  v_policy_score INTEGER;
  v_cost_score INTEGER;
  v_time_score INTEGER;
  v_qa_score INTEGER;
  v_evidence_score INTEGER;
  v_overall_score INTEGER;
  
  -- Scoring details
  v_metrics JSONB;
  v_scoring_details JSONB;
BEGIN
  -- Get work order record
  SELECT * INTO v_wo_record
  FROM work_orders
  WHERE id = p_work_order_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Work order % not found', p_work_order_id;
  END IF;
  
  -- Only generate scorecard for completed WOs
  IF v_wo_record.status != 'done' THEN
    RAISE EXCEPTION 'Work order % is not in done status', p_work_order_id;
  END IF;
  
  -- Collect raw metrics
  
  -- Iteration count from execution log
  SELECT COALESCE(MAX(iteration), 0) INTO v_total_iterations
  FROM work_order_execution_log
  WHERE work_order_id = p_work_order_id;
  
  -- Mutation count from state_mutations
  SELECT COUNT(*) INTO v_total_mutations
  FROM state_mutations
  WHERE work_order_id = p_work_order_id;
  
  -- Execution duration in minutes
  v_execution_duration_minutes := COALESCE(
    EXTRACT(EPOCH FROM (v_wo_record.completed_at - v_wo_record.started_at)) / 60.0,
    0
  );
  
  -- QA checklist metrics
  SELECT 
    COALESCE(jsonb_array_length(v_wo_record.qa_checklist), 0),
    COUNT(*) FILTER (WHERE item->>'status' = 'pass')
  INTO v_qa_checklist_items, v_qa_passed_items
  FROM jsonb_array_elements(COALESCE(v_wo_record.qa_checklist, '[]'::jsonb)) AS item;
  
  -- QA findings metrics
  SELECT 
    COUNT(*),
    COUNT(*) FILTER (WHERE resolved_at IS NOT NULL)
  INTO v_qa_findings_total, v_qa_findings_resolved
  FROM qa_findings
  WHERE work_order_id = p_work_order_id;
  
  -- Evidence completeness metrics
  SELECT COUNT(*) INTO v_evidence_log_count
  FROM work_order_execution_log
  WHERE work_order_id = p_work_order_id
  AND phase IN ('stream', 'checkpoint', 'execution_complete');
  
  SELECT COUNT(*) INTO v_checkpoint_count
  FROM work_order_execution_log
  WHERE work_order_id = p_work_order_id
  AND phase = 'checkpoint';
  
  -- Policy violations (lessons learned during execution)
  SELECT COALESCE(v_wo_record.lesson_count, 0) INTO v_violations_count;
  
  -- CALCULATE SCORES (0-100 scale)
  
  -- 1. Policy Adherence Score (higher is better)
  -- Based on: no violations, proper logging, checkpoint usage
  v_policy_score := LEAST(100, GREATEST(0,
    100 
    - (v_violations_count * 20)  -- -20 points per violation
    + (CASE WHEN v_checkpoint_count > 0 THEN 10 ELSE 0 END)  -- +10 for using checkpoints
    + (CASE WHEN v_evidence_log_count >= 10 THEN 10 ELSE (v_evidence_log_count) END)  -- up to +10 for logging
  ));
  
  -- 2. Cost Efficiency Score (lower iterations/mutations is better)
  -- Baseline: <10 iterations = 100, >50 iterations = 0
  v_cost_score := LEAST(100, GREATEST(0,
    100 - ((v_total_iterations - 5) * 2)  -- -2 points per iteration over 5
    + (CASE WHEN v_total_mutations BETWEEN 1 AND 10 THEN 10 ELSE 0 END)  -- +10 for reasonable mutation count
  ));
  
  -- 3. Time Efficiency Score (faster completion is better)
  -- Baseline: <15min = 100, >120min = 0
  v_time_score := LEAST(100, GREATEST(0,
    100 - (v_execution_duration_minutes * 0.8)  -- -0.8 points per minute
    + (CASE WHEN v_execution_duration_minutes < 15 THEN 20 ELSE 0 END)  -- +20 bonus for <15min
  ));
  
  -- 4. QA Pass Rate Score
  -- Based on checklist pass rate and findings resolution
  IF v_qa_checklist_items > 0 THEN
    v_qa_score := (v_qa_passed_items * 100 / v_qa_checklist_items);
  ELSE
    v_qa_score := 50;  -- Neutral score if no checklist
  END IF;
  
  -- Penalty for unresolved findings
  IF v_qa_findings_total > 0 AND v_qa_findings_resolved < v_qa_findings_total THEN
    v_qa_score := GREATEST(0, v_qa_score - ((v_qa_findings_total - v_qa_findings_resolved) * 25));
  END IF;
  
  -- 5. Evidence Completeness Score
  -- Based on execution log quality
  v_evidence_score := LEAST(100, GREATEST(0,
    (v_evidence_log_count * 2)  -- 2 points per log entry
    + (v_checkpoint_count * 10)  -- +10 per checkpoint
    + (CASE WHEN v_qa_passed_items > 0 THEN 20 ELSE 0 END)  -- +20 if QA has evidence
  ));
  
  -- Calculate weighted overall score
  -- Weights: Policy=25%, Cost=20%, Time=15%, QA=30%, Evidence=10%
  v_overall_score := (
    (v_policy_score * 25) +
    (v_cost_score * 20) +
    (v_time_score * 15) +
    (v_qa_score * 30) +
    (v_evidence_score * 10)
  ) / 100;
  
  -- Build metrics JSON
  v_metrics := jsonb_build_object(
    'iterations', v_total_iterations,
    'mutations', v_total_mutations,
    'duration_minutes', ROUND(v_execution_duration_minutes, 2),
    'qa_checklist_items', v_qa_checklist_items,
    'qa_passed_items', v_qa_passed_items,
    'qa_findings_total', v_qa_findings_total,
    'qa_findings_resolved', v_qa_findings_resolved,
    'evidence_log_count', v_evidence_log_count,
    'checkpoint_count', v_checkpoint_count,
    'violations_count', v_violations_count,
    'work_order_slug', v_wo_record.slug,
    'work_order_name', v_wo_record.name,
    'priority', v_wo_record.priority,
    'complexity', v_wo_record.complexity
  );
  
  -- Build scoring details JSON
  v_scoring_details := jsonb_build_object(
    'weights', jsonb_build_object(
      'policy_adherence', 25,
      'cost_efficiency', 20,
      'time_efficiency', 15,
      'qa_pass_rate', 30,
      'evidence_completeness', 10
    ),
    'scoring_notes', jsonb_build_object(
      'policy_adherence', format('Violations: %s, Checkpoints: %s, Logs: %s', 
        v_violations_count, v_checkpoint_count, v_evidence_log_count),
      'cost_efficiency', format('Iterations: %s, Mutations: %s', 
        v_total_iterations, v_total_mutations),
      'time_efficiency', format('Duration: %s minutes', 
        ROUND(v_execution_duration_minutes, 2)),
      'qa_pass_rate', format('Passed: %s/%s, Findings resolved: %s/%s', 
        v_qa_passed_items, v_qa_checklist_items, v_qa_findings_resolved, v_qa_findings_total),
      'evidence_completeness', format('Log entries: %s, Checkpoints: %s', 
        v_evidence_log_count, v_checkpoint_count)
    )
  );
  
  -- Insert or update scorecard
  INSERT INTO run_scorecards (
    work_order_id,
    policy_adherence_score,
    cost_efficiency_score,
    time_efficiency_score,
    qa_pass_rate_score,
    evidence_completeness_score,
    overall_score,
    metrics,
    scoring_details,
    scored_by
  ) VALUES (
    p_work_order_id,
    v_policy_score,
    v_cost_score,
    v_time_score,
    v_qa_score,
    v_evidence_score,
    v_overall_score,
    v_metrics,
    v_scoring_details,
    'auto-scorer'
  )
  ON CONFLICT (work_order_id) 
  DO UPDATE SET
    policy_adherence_score = EXCLUDED.policy_adherence_score,
    cost_efficiency_score = EXCLUDED.cost_efficiency_score,
    time_efficiency_score = EXCLUDED.time_efficiency_score,
    qa_pass_rate_score = EXCLUDED.qa_pass_rate_score,
    evidence_completeness_score = EXCLUDED.evidence_completeness_score,
    overall_score = EXCLUDED.overall_score,
    metrics = EXCLUDED.metrics,
    scoring_details = EXCLUDED.scoring_details,
    scored_at = now()
  RETURNING id INTO v_scorecard_id;
  
  RETURN v_scorecard_id;
END;
$$;


--
-- Name: FUNCTION generate_wo_scorecard(p_work_order_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.generate_wo_scorecard(p_work_order_id uuid) IS 'Generates quality scorecard for completed work order with 5 dimensions and overall weighted score';


--
-- Name: get_active_spec(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_active_spec() RETURNS jsonb
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
  SELECT jsonb_build_object('version', version, 'spec', spec, 'spec_hash', spec_hash, 'created_at', created_at)
  FROM kernel_spec ORDER BY id DESC LIMIT 1;
$$;


--
-- Name: get_agent_performance_summary(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_agent_performance_summary(p_days integer DEFAULT 7) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  result JSONB;
BEGIN
  SELECT jsonb_agg(
    jsonb_build_object(
      'agent_name', a.name,
      'wos_done', COALESCE(wo_stats.done_count, 0),
      'wos_failed', COALESCE(wo_stats.failed_count, 0),
      'avg_completion_minutes', ROUND(COALESCE(wo_stats.avg_minutes, 0)::numeric, 2),
      'mutation_success_rate', ROUND(COALESCE(mutation_stats.success_rate, 0)::numeric, 4),
      'qa_pass_rate', ROUND(COALESCE(qa_stats.pass_rate, 0)::numeric, 4)
    )
  )
  INTO result
  FROM agents a
  LEFT JOIN (
    SELECT 
      wo.assigned_to,
      COUNT(*) FILTER (WHERE wo.status = 'done') AS done_count,
      COUNT(*) FILTER (WHERE wo.status = 'failed') AS failed_count,
      AVG(EXTRACT(EPOCH FROM (wo.completed_at - wo.started_at))/60) AS avg_minutes
    FROM work_orders wo
    WHERE wo.started_at >= NOW() - (p_days || ' days')::interval
      AND wo.assigned_to IS NOT NULL
    GROUP BY wo.assigned_to
  ) wo_stats ON a.id = wo_stats.assigned_to
  LEFT JOIN (
    SELECT 
      agent_name,
      CASE WHEN COUNT(*) > 0 THEN COUNT(*) FILTER (WHERE success = true)::float / COUNT(*)::float ELSE 0 END AS success_rate
    FROM wo_mutations
    WHERE created_at >= NOW() - (p_days || ' days')::interval
    GROUP BY agent_name
  ) mutation_stats ON a.name = mutation_stats.agent_name
  LEFT JOIN (
    SELECT 
      wo.assigned_to AS agent_id,
      CASE WHEN COUNT(*) > 0 THEN COUNT(*) FILTER (WHERE qf.resolved_at IS NOT NULL)::float / COUNT(*)::float ELSE 0 END AS pass_rate
    FROM qa_findings qf
    JOIN work_orders wo ON qf.work_order_id = wo.id
    WHERE qf.created_at >= NOW() - (p_days || ' days')::interval
      AND wo.assigned_to IS NOT NULL
    GROUP BY wo.assigned_to
  ) qa_stats ON a.id = qa_stats.agent_id
  WHERE a.status = 'active';

  RETURN COALESCE(result, '[]'::jsonb);
END;
$$;


--
-- Name: get_batch_ready_wos(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_batch_ready_wos(p_batch_id uuid) RETURNS TABLE(work_order_id uuid, slug text, priority public.work_order_priority, execution_rank integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    wo.id,
    wo.slug,
    wo.priority,
    wo.execution_rank
  FROM work_orders wo
  WHERE wo.batch_id = p_batch_id
    AND wo.status IN ('draft', 'ready')
    -- Only include WOs where all dependencies are completed
    AND (
      wo.depends_on IS NULL 
      OR wo.depends_on = '{}'
      OR NOT EXISTS (
        SELECT 1 
        FROM unnest(wo.depends_on) dep_id
        JOIN work_orders dep ON dep.id = dep_id
        WHERE dep.status NOT IN ('done', 'cancelled')
      )
    )
  ORDER BY wo.execution_rank ASC, wo.priority ASC, wo.created_at ASC;
END;
$$;


--
-- Name: FUNCTION get_batch_ready_wos(p_batch_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_batch_ready_wos(p_batch_id uuid) IS 'Returns WOs from a batch that are ready to execute (dependencies satisfied)';


--
-- Name: get_build_children(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_build_children(p_pipeline_run_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_result jsonb;
    v_spec_wo_id uuid;
BEGIN
    SELECT spec_wo_id INTO v_spec_wo_id FROM pipeline_runs WHERE id = p_pipeline_run_id;
    IF NOT FOUND THEN
        RETURN '[]'::jsonb;
    END IF;
    
    SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
            'step_order', m.step_order,
            'build_plan', m.build_plan
        ) ORDER BY m.step_order
    ), '[]'::jsonb)
    INTO v_result
    FROM wo_execution_manifest m
    WHERE m.work_order_id = v_spec_wo_id
      AND m.build_plan IS NOT NULL;
    
    RETURN v_result;
END;
$$;


--
-- Name: get_cancellation_rate_summary(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_cancellation_rate_summary() RETURNS TABLE(period text, cancellation_rate_pct numeric, target_pct numeric, meeting_target boolean, total_wos bigint, cancelled_wos bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  WITH recent_data AS (
    SELECT 
      created_at,
      status,
      CASE 
        WHEN created_at >= CURRENT_DATE - INTERVAL '7 days' THEN '7_day'
        WHEN created_at >= CURRENT_DATE - INTERVAL '14 days' THEN '14_day'
        WHEN created_at >= CURRENT_DATE - INTERVAL '28 days' THEN '28_day'
        ELSE 'older'
      END as period_bucket
    FROM work_orders
    WHERE created_at >= CURRENT_DATE - INTERVAL '28 days'
  )
  SELECT 
    period_bucket::text as period,
    ROUND(
      100.0 * COUNT(*) FILTER (WHERE status = 'cancelled') / NULLIF(COUNT(*), 0),
      2
    ) as cancellation_rate_pct,
    CASE 
      WHEN period_bucket = '14_day' THEN 20.0
      WHEN period_bucket = '28_day' THEN 15.0
      ELSE NULL
    END as target_pct,
    CASE 
      WHEN period_bucket = '14_day' THEN 
        (100.0 * COUNT(*) FILTER (WHERE status = 'cancelled') / NULLIF(COUNT(*), 0)) < 20
      WHEN period_bucket = '28_day' THEN 
        (100.0 * COUNT(*) FILTER (WHERE status = 'cancelled') / NULLIF(COUNT(*), 0)) < 15
      ELSE NULL
    END as meeting_target,
    COUNT(*) as total_wos,
    COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_wos
  FROM recent_data
  WHERE period_bucket IN ('7_day', '14_day', '28_day')
  GROUP BY period_bucket
  ORDER BY 
    CASE period_bucket
      WHEN '7_day' THEN 1
      WHEN '14_day' THEN 2
      WHEN '28_day' THEN 3
    END;
END;
$$;


--
-- Name: FUNCTION get_cancellation_rate_summary(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_cancellation_rate_summary() IS 'Returns current cancellation rate vs targets (20% @ 2wk, 15% @ 4wk) for WO-0069';


--
-- Name: get_cli_bootstrap_context(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_cli_bootstrap_context(p_project_code text DEFAULT 'METIS-001'::text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_result JSONB;
  v_project project_briefs;
  v_context project_context;
BEGIN
  -- Get project brief
  SELECT * INTO v_project FROM project_briefs WHERE code = p_project_code;
  
  -- Get project context
  SELECT * INTO v_context FROM project_context WHERE project_name = p_project_code;
  
  v_result := jsonb_build_object(
    'generated_at', now(),
    'project', jsonb_build_object(
      'code', v_project.code,
      'name', v_project.name,
      'status', v_project.status,
      'current_phase', v_project.current_phase,
      'completion_pct', v_project.completion_pct,
      'summary', v_project.summary
    ),
    'architecture', v_context.architecture,
    'session_summary', v_context.last_session_summary,
    'active_directives', (
      SELECT jsonb_agg(jsonb_build_object(
        'name', name,
        'enforcement', enforcement,
        'content', content
      ) ORDER BY priority DESC)
      FROM system_directives 
      WHERE scope = 'global' AND active = true
    ),
    'capabilities', (
      SELECT jsonb_agg(jsonb_build_object(
        'type', capability_type,
        'name', name,
        'implementation', implementation
      ))
      FROM metis_capabilities 
      WHERE status = 'active'
    ),
    'mcp_connectors', (
      SELECT jsonb_agg(jsonb_build_object(
        'name', sm.name,
        'url', sm.config->>'url',
        'tools', sm.config->'tools',
        'status', sm.status
      ))
      FROM system_manifest sm
      WHERE sm.component_type = 'mcp_connector' AND sm.status = 'active'
    ),
    'pending_work', (
      SELECT jsonb_agg(jsonb_build_object(
        'slug', slug,
        'name', name,
        'status', status,
        'priority', priority
      ) ORDER BY 
        CASE priority WHEN 'p0_critical' THEN 0 WHEN 'p1_high' THEN 1 WHEN 'p2_medium' THEN 2 ELSE 3 END,
        created_at DESC
      )
      FROM work_orders 
      WHERE status IN ('pending_approval', 'in_progress', 'blocked')
    ),
    'recent_decisions', (
      SELECT jsonb_agg(jsonb_build_object(
        'subject', subject,
        'choice', choice,
        'made_at', made_at
      ) ORDER BY made_at DESC)
      FROM decisions 
      WHERE status = 'active'
      LIMIT 10
    ),
    'unreviewed_lessons', (
      SELECT jsonb_agg(jsonb_build_object(
        'id', id,
        'pattern', pattern,
        'rule', rule,
        'severity', severity
      ))
      FROM lessons 
      WHERE reviewed = false
    )
  );
  
  RETURN v_result;
END;
$$;


--
-- Name: get_dead_tables_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_dead_tables_count() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)::integer
    FROM pg_stat_user_tables
    WHERE n_dead_tup > 1000
  );
END;
$$;


--
-- Name: get_default_qa_checklist(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_default_qa_checklist() RETURNS jsonb
    LANGUAGE sql IMMUTABLE
    AS $$
  SELECT jsonb_build_array(
    jsonb_build_object(
      'id', 'mobile_usability',
      'name', 'Mobile Usability',
      'description', 'Test on mobile devices and different screen sizes',
      'status', 'pending',
      'notes', '',
      'tested_by', NULL,
      'tested_at', NULL
    ),
    jsonb_build_object(
      'id', 'cross_browser',
      'name', 'Cross-Browser Compatibility',
      'description', 'Test in Chrome, Firefox, Safari, Edge',
      'status', 'pending',
      'notes', '',
      'tested_by', NULL,
      'tested_at', NULL
    ),
    jsonb_build_object(
      'id', 'empty_states',
      'name', 'Empty States',
      'description', 'Verify UI handles no data gracefully',
      'status', 'pending',
      'notes', '',
      'tested_by', NULL,
      'tested_at', NULL
    ),
    jsonb_build_object(
      'id', 'error_states',
      'name', 'Error States',
      'description', 'Test error handling and error messages',
      'status', 'pending',
      'notes', '',
      'tested_by', NULL,
      'tested_at', NULL
    ),
    jsonb_build_object(
      'id', 'loading_states',
      'name', 'Loading States',
      'description', 'Verify loading indicators and async behavior',
      'status', 'pending',
      'notes', '',
      'tested_by', NULL,
      'tested_at', NULL
    ),
    jsonb_build_object(
      'id', 'slow_network',
      'name', 'Slow Network Conditions',
      'description', 'Test with throttled network (3G/slow 4G)',
      'status', 'pending',
      'notes', '',
      'tested_by', NULL,
      'tested_at', NULL
    ),
    jsonb_build_object(
      'id', 'secrets_audit',
      'name', 'Secrets Audit',
      'description', 'Check for exposed secrets, API keys, credentials',
      'status', 'pending',
      'notes', '',
      'tested_by', NULL,
      'tested_at', NULL
    ),
    jsonb_build_object(
      'id', 'main_flow_e2e',
      'name', 'Main Flow E2E',
      'description', 'Complete end-to-end test of primary user flow',
      'status', 'pending',
      'notes', '',
      'tested_by', NULL,
      'tested_at', NULL
    )
  );
$$;


--
-- Name: get_dependency_health(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_dependency_health(p_wo_id uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_result jsonb;
  v_wo record;
  v_blocked_count int;
  v_circular bool;
  v_chain_status text;
BEGIN
  -- Get WO details
  SELECT id, slug, status, depends_on INTO v_wo
  FROM work_orders
  WHERE id = p_wo_id;
  
  IF v_wo.id IS NULL THEN
    RETURN jsonb_build_object('error', 'Work order not found');
  END IF;
  
  -- Count blocked dependents
  SELECT COUNT(*) INTO v_blocked_count
  FROM walk_dependency_chain(p_wo_id)
  WHERE is_blocked = true;
  
  -- Check for circular dependencies
  SELECT EXISTS(
    SELECT 1 FROM detect_circular_dependencies(p_wo_id)
  ) INTO v_circular;
  
  -- Determine chain status
  IF v_circular THEN
    v_chain_status := 'circular_deadlock';
  ELSIF v_wo.status = 'failed' AND v_blocked_count > 0 THEN
    v_chain_status := 'cascade_blocked';
  ELSIF v_wo.status IN ('done', 'cancelled') THEN
    v_chain_status := 'healthy';
  ELSIF v_blocked_count > 0 THEN
    v_chain_status := 'has_blocked_dependents';
  ELSE
    v_chain_status := 'healthy';
  END IF;
  
  -- Build result
  v_result := jsonb_build_object(
    'wo_id', v_wo.id,
    'wo_slug', v_wo.slug,
    'wo_status', v_wo.status,
    'chain_status', v_chain_status,
    'blocked_count', v_blocked_count,
    'has_circular_deps', v_circular,
    'dependents', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', wo_id,
          'slug', wo_slug,
          'status', wo_status,
          'depth', depth,
          'is_blocked', is_blocked,
          'blocking_dep_count', array_length(blocking_deps, 1)
        )
      )
      FROM walk_dependency_chain(p_wo_id)
    )
  );
  
  RETURN v_result;
END;
$$;


--
-- Name: get_dynamic_schema_context(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_dynamic_schema_context(p_work_order_id uuid) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
    v_result TEXT;
    v_wo_text TEXT;
    v_keywords TEXT[];
    v_scored_tables TEXT[];
    v_scored_rpcs TEXT[];
    v_scored_enums TEXT[];
    v_rec RECORD;
    v_has_keywords BOOLEAN;
BEGIN
    -- Get WO text for keyword extraction
    SELECT COALESCE(objective, '') || ' ' || COALESCE(acceptance_criteria, '')
    INTO v_wo_text
    FROM work_orders WHERE id = p_work_order_id;
    
    IF v_wo_text IS NULL THEN
        RETURN '# SCHEMA CONTEXT' || chr(10) || 'Work order not found.';
    END IF;
    
    -- Extract keywords (3+ char lowercase words, deduplicated)
    SELECT array_agg(DISTINCT lower(m[1]))
    INTO v_keywords
    FROM regexp_matches(v_wo_text, '\m([a-z_]{3,})\M', 'gi') AS m;
    
    v_has_keywords := (v_keywords IS NOT NULL AND array_length(v_keywords, 1) > 0);
    
    IF v_has_keywords THEN
        -- Score tables: direct name match (10) + column name match (8)
        -- Include all with combined score >= 4
        WITH direct_matches AS (
            SELECT table_name, 10 as score
            FROM information_schema.tables
            WHERE table_schema = 'public' AND table_type = 'BASE TABLE'
              AND table_name = ANY(v_keywords)
        ),
        column_matches AS (
            SELECT DISTINCT table_name, 8 as score
            FROM information_schema.columns
            WHERE table_schema = 'public' AND column_name = ANY(v_keywords)
        ),
        scored AS (
            SELECT table_name, sum(score) as total_score
            FROM (
                SELECT * FROM direct_matches
                UNION ALL
                SELECT * FROM column_matches
            ) combined
            GROUP BY table_name
            HAVING sum(score) >= 4
        )
        SELECT array_agg(table_name)
        INTO v_scored_tables
        FROM scored;
        
        -- Add 1-hop FK tables (score = 5, meets >= 4 threshold)
        IF v_scored_tables IS NOT NULL THEN
            WITH fk_targets AS (
                -- Tables our matched tables FK to
                SELECT DISTINCT ccu.table_name
                FROM information_schema.referential_constraints rc
                JOIN information_schema.key_column_usage kcu 
                    ON kcu.constraint_name = rc.constraint_name AND kcu.constraint_schema = rc.constraint_schema
                JOIN information_schema.constraint_column_usage ccu 
                    ON ccu.constraint_name = rc.unique_constraint_name AND ccu.constraint_schema = rc.unique_constraint_schema
                WHERE kcu.table_schema = 'public' AND kcu.table_name = ANY(v_scored_tables)
                  AND NOT (ccu.table_name = ANY(v_scored_tables))
                UNION
                -- Tables that FK to our matched tables
                SELECT DISTINCT kcu.table_name
                FROM information_schema.referential_constraints rc
                JOIN information_schema.key_column_usage kcu 
                    ON kcu.constraint_name = rc.constraint_name AND kcu.constraint_schema = rc.constraint_schema
                JOIN information_schema.constraint_column_usage ccu 
                    ON ccu.constraint_name = rc.unique_constraint_name AND ccu.constraint_schema = rc.unique_constraint_schema
                WHERE ccu.table_schema = 'public' AND ccu.table_name = ANY(v_scored_tables)
                  AND NOT (kcu.table_name = ANY(v_scored_tables))
            )
            SELECT array_cat(v_scored_tables, COALESCE(array_agg(table_name), '{}'))
            INTO v_scored_tables
            FROM fk_targets;
        END IF;
    END IF;
    
    -- Fallback: top-15 most-referenced tables from wo_mutations
    IF v_scored_tables IS NULL OR array_length(v_scored_tables, 1) IS NULL THEN
        SELECT array_agg(object_type ORDER BY cnt DESC)
        INTO v_scored_tables
        FROM (
            SELECT object_type, count(*) as cnt
            FROM wo_mutations
            WHERE success = true AND object_type IS NOT NULL AND object_type != ''
            GROUP BY object_type
            ORDER BY count(*) DESC
            LIMIT 15
        ) t;
    END IF;
    
    -- Ultimate fallback: core system tables
    IF v_scored_tables IS NULL OR array_length(v_scored_tables, 1) IS NULL THEN
        v_scored_tables := ARRAY[
            'work_orders', 'audit_log', 'lessons', 'agents', 
            'system_directives', 'wo_mutations', 'pipeline_runs', 
            'execution_log', 'wo_events', 'wo_effects'
        ];
    END IF;
    
    -- Find matching RPCs (name match = 6, or references scored table = 6)
    IF v_has_keywords THEN
        SELECT array_agg(DISTINCT proname)
        INTO v_scored_rpcs
        FROM pg_proc p
        JOIN pg_namespace n ON n.oid = p.pronamespace
        WHERE n.nspname = 'public'
          AND (
            p.proname = ANY(v_keywords)
            OR (v_scored_tables IS NOT NULL AND EXISTS (
                SELECT 1 FROM unnest(v_scored_tables) t(tname)
                WHERE length(tname) >= 4 AND p.prosrc ILIKE '%' || tname || '%'
            ))
          );
    END IF;
    
    IF v_scored_rpcs IS NULL THEN v_scored_rpcs := '{}'; END IF;
    
    -- Find enums used by scored table columns (score = 4)
    SELECT array_agg(DISTINCT t.typname)
    INTO v_scored_enums
    FROM information_schema.columns c
    JOIN pg_type t ON t.typname = c.udt_name
    WHERE c.table_schema = 'public'
      AND c.table_name = ANY(v_scored_tables)
      AND EXISTS (SELECT 1 FROM pg_enum e WHERE e.enumtypid = t.oid);
    
    IF v_scored_enums IS NULL THEN v_scored_enums := '{}'; END IF;
    
    -- Build markdown output
    v_result := E'# DATABASE SCHEMA CONTEXT\n\n';
    v_result := v_result || E'**CRITICAL**: Only use column names, enum values, and RPC signatures listed here.\n';
    v_result := v_result || E'DO NOT guess or invent column names — refer to this schema.\n\n';
    
    -- Tables section
    v_result := v_result || E'## Tables and Columns\n';
    FOR v_rec IN
        SELECT c.table_name,
               string_agg(
                 '- `' || c.column_name || '`: ' || c.udt_name ||
                 CASE WHEN c.is_nullable = 'NO' THEN ' (NOT NULL)' ELSE '' END,
                 E'\n' ORDER BY c.ordinal_position
               ) as cols
        FROM information_schema.columns c
        WHERE c.table_schema = 'public' AND c.table_name = ANY(v_scored_tables)
        GROUP BY c.table_name
        ORDER BY c.table_name
    LOOP
        v_result := v_result || E'### ' || v_rec.table_name || E'\n' || v_rec.cols || E'\n\n';
    END LOOP;
    
    -- Enums section
    IF array_length(v_scored_enums, 1) > 0 THEN
        v_result := v_result || E'## Enum Types\n';
        FOR v_rec IN
            SELECT t.typname,
                   string_agg('''' || e.enumlabel || '''', ', ' ORDER BY e.enumsortorder) as vals
            FROM pg_type t
            JOIN pg_enum e ON e.enumtypid = t.oid
            WHERE t.typname = ANY(v_scored_enums)
            GROUP BY t.typname
            ORDER BY t.typname
        LOOP
            v_result := v_result || E'### ' || v_rec.typname || E'\n';
            v_result := v_result || 'Valid values: ' || v_rec.vals || E'\n\n';
        END LOOP;
    END IF;
    
    -- RPCs section
    IF array_length(v_scored_rpcs, 1) > 0 THEN
        v_result := v_result || E'## RPC Functions\n';
        FOR v_rec IN
            SELECT DISTINCT ON (p.proname) p.proname,
                   pg_get_function_arguments(p.oid) as args,
                   pg_get_function_result(p.oid) as returns
            FROM pg_proc p
            JOIN pg_namespace n ON n.oid = p.pronamespace
            WHERE n.nspname = 'public' AND p.proname = ANY(v_scored_rpcs)
            ORDER BY p.proname
        LOOP
            v_result := v_result || E'### ' || v_rec.proname || E'\n';
            v_result := v_result || 'Parameters: ' || COALESCE(v_rec.args, 'none') || E'\n';
            v_result := v_result || 'Returns: ' || COALESCE(v_rec.returns, 'void') || E'\n\n';
        END LOOP;
    END IF;
    
    RETURN v_result;
END;
$$;


--
-- Name: get_error_rates(text, integer, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_error_rates(p_source_function text DEFAULT NULL::text, p_time_window_hours integer DEFAULT 24, p_min_severity text DEFAULT NULL::text) RETURNS TABLE(source_function text, error_code text, severity text, count bigint, first_seen timestamp with time zone, last_seen timestamp with time zone, error_rate_per_hour numeric)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ee.source_function,
    ee.error_code,
    ee.severity,
    COUNT(*) as count,
    MIN(ee.created_at) as first_seen,
    MAX(ee.created_at) as last_seen,
    ROUND((COUNT(*)::NUMERIC / p_time_window_hours), 2) as error_rate_per_hour
  FROM error_events ee
  WHERE 
    ee.created_at >= now() - (p_time_window_hours || ' hours')::interval
    AND (p_source_function IS NULL OR ee.source_function = p_source_function)
    AND (p_min_severity IS NULL OR 
         CASE ee.severity
           WHEN 'critical' THEN 4
           WHEN 'error' THEN 3
           WHEN 'warning' THEN 2
           WHEN 'info' THEN 1
         END >= 
         CASE p_min_severity
           WHEN 'critical' THEN 4
           WHEN 'error' THEN 3
           WHEN 'warning' THEN 2
           WHEN 'info' THEN 1
         END)
  GROUP BY ee.source_function, ee.error_code, ee.severity
  ORDER BY count DESC, last_seen DESC;
END;
$$;


--
-- Name: FUNCTION get_error_rates(p_source_function text, p_time_window_hours integer, p_min_severity text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_error_rates(p_source_function text, p_time_window_hours integer, p_min_severity text) IS 'Get error rates by source and time window for trend analysis';


--
-- Name: get_error_spikes(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_error_spikes(p_time_window_minutes integer DEFAULT 10, p_threshold integer DEFAULT 5) RETURNS TABLE(error_code text, source_function text, severity text, error_count bigint, sample_message text)
    LANGUAGE sql STABLE
    AS $$
  SELECT 
    error_code,
    source_function,
    severity,
    COUNT(*) as error_count,
    MAX(message) as sample_message
  FROM error_events
  WHERE created_at >= NOW() - (p_time_window_minutes || ' minutes')::INTERVAL
  GROUP BY error_code, source_function, severity
  HAVING COUNT(*) >= p_threshold
  ORDER BY error_count DESC, severity DESC;
$$;


--
-- Name: FUNCTION get_error_spikes(p_time_window_minutes integer, p_threshold integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_error_spikes(p_time_window_minutes integer, p_threshold integer) IS 'WO-0266: Detect error spikes by grouping errors in time window';


--
-- Name: get_evidence_bundle(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_evidence_bundle(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_bundle jsonb;
BEGIN
  SELECT 
    jsonb_build_object(
      'id', eb.id,
      'work_order_id', eb.work_order_id,
      'work_order_slug', wo.slug,
      'work_order_name', wo.name,
      'generated_at', eb.generated_at,
      'bundle_version', eb.bundle_version,
      'execution_summary', eb.execution_summary,
      'qa_results', eb.qa_results,
      'verification_log', eb.verification_log,
      'enforcer_result', eb.enforcer_result,
      'cost_metrics', eb.cost_metrics,
      'tool_calls', eb.tool_calls,
      'code_changes', eb.code_changes,
      'created_at', eb.created_at,
      'updated_at', eb.updated_at
    )
  INTO v_bundle
  FROM evidence_bundles eb
  JOIN work_orders wo ON wo.id = eb.work_order_id
  WHERE eb.work_order_id = p_work_order_id;
  
  IF v_bundle IS NULL THEN
    RETURN jsonb_build_object(
      'error', 'evidence_bundle_not_found',
      'message', 'No evidence bundle found for work order ' || p_work_order_id::text
    );
  END IF;
  
  RETURN v_bundle;
END;
$$;


--
-- Name: FUNCTION get_evidence_bundle(p_work_order_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_evidence_bundle(p_work_order_id uuid) IS 'Retrieve comprehensive evidence bundle for a completed work order. Returns consolidated proof-of-work artifact.';


--
-- Name: get_evidence_bundle(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_evidence_bundle(p_work_order_id uuid DEFAULT NULL::uuid, p_work_order_slug text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_wo_id UUID;
    v_bundle_record RECORD;
BEGIN
    -- Resolve work order ID from slug if provided
    IF p_work_order_slug IS NOT NULL THEN
        SELECT id INTO v_wo_id
        FROM work_orders
        WHERE slug = p_work_order_slug;
        
        IF NOT FOUND THEN
            RETURN jsonb_build_object(
                'error', 'Work order not found',
                'slug', p_work_order_slug
            );
        END IF;
    ELSIF p_work_order_id IS NOT NULL THEN
        v_wo_id := p_work_order_id;
    ELSE
        RETURN jsonb_build_object(
            'error', 'Must provide either work_order_id or work_order_slug'
        );
    END IF;
    
    -- Check if work order is done
    IF NOT EXISTS (
        SELECT 1 FROM work_orders 
        WHERE id = v_wo_id AND status = 'done'
    ) THEN
        RETURN jsonb_build_object(
            'error', 'Evidence bundle only available for completed work orders',
            'work_order_id', v_wo_id
        );
    END IF;
    
    -- Get evidence bundle
    SELECT 
        bundle,
        total_duration_seconds,
        total_tokens,
        total_cost_usd,
        qa_passed,
        enforcer_passed,
        verification_passed,
        created_at as bundle_created_at
    INTO v_bundle_record
    FROM evidence_bundles
    WHERE work_order_id = v_wo_id;
    
    -- If bundle doesn't exist yet, try to generate it
    IF NOT FOUND THEN
        -- Generate bundle on-demand
        INSERT INTO evidence_bundles (
            work_order_id,
            bundle,
            total_duration_seconds,
            total_tokens,
            total_cost_usd,
            qa_passed,
            enforcer_passed,
            verification_passed
        )
        SELECT
            v_wo_id,
            assemble_evidence_bundle(v_wo_id),
            EXTRACT(EPOCH FROM (completed_at - started_at)),
            0, -- tokens placeholder
            0, -- cost placeholder
            NULL,
            enforcer_verified,
            NULL
        FROM work_orders
        WHERE id = v_wo_id
        RETURNING 
            bundle,
            total_duration_seconds,
            total_tokens,
            total_cost_usd,
            qa_passed,
            enforcer_passed,
            verification_passed,
            created_at
        INTO v_bundle_record;
    END IF;
    
    -- Return enriched bundle with metadata
    RETURN jsonb_build_object(
        'bundle', v_bundle_record.bundle,
        'metadata', jsonb_build_object(
            'total_duration_seconds', v_bundle_record.total_duration_seconds,
            'total_tokens', v_bundle_record.total_tokens,
            'total_cost_usd', v_bundle_record.total_cost_usd,
            'qa_passed', v_bundle_record.qa_passed,
            'enforcer_passed', v_bundle_record.enforcer_passed,
            'verification_passed', v_bundle_record.verification_passed,
            'bundle_created_at', v_bundle_record.bundle_created_at
        )
    );
END;
$$;


--
-- Name: get_evidence_bundle_by_slug(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_evidence_bundle_by_slug(p_slug text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN get_evidence_bundle(
    (SELECT id FROM work_orders WHERE slug = p_slug)
  );
END;
$$;


--
-- Name: FUNCTION get_evidence_bundle_by_slug(p_slug text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_evidence_bundle_by_slug(p_slug text) IS 'Retrieve evidence bundle by work order slug';


--
-- Name: get_interrogation_status(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_interrogation_status(p_session_id uuid) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_session interrogation_sessions;
  v_next_questions JSONB;
  v_all_domains TEXT[];
  v_remaining TEXT[];
BEGIN
  SELECT * INTO v_session FROM interrogation_sessions WHERE id = p_session_id;
  
  IF v_session.id IS NULL THEN
    RETURN jsonb_build_object('error', 'Session not found');
  END IF;

  -- Get all unique domains
  SELECT ARRAY(
    SELECT DISTINCT q->>'domain' 
    FROM jsonb_array_elements(v_session.questions_asked) q
  ) INTO v_all_domains;

  -- Compute remaining domains
  SELECT ARRAY(
    SELECT unnest(v_all_domains) 
    EXCEPT 
    SELECT unnest(COALESCE(v_session.domains_completed, ARRAY[]::TEXT[]))
  ) INTO v_remaining;

  -- Get questions for the next remaining domain
  IF array_length(v_remaining, 1) > 0 THEN
    SELECT jsonb_agg(q) INTO v_next_questions
    FROM jsonb_array_elements(v_session.questions_asked) q
    WHERE q->>'domain' = v_remaining[1];
  ELSE
    v_next_questions := '[]'::jsonb;
  END IF;

  RETURN jsonb_build_object(
    'session_id', v_session.id,
    'status', v_session.status,
    'project_id', v_session.project_id,
    'trigger_type', v_session.trigger_type,
    'all_domains', v_all_domains,
    'domains_completed', COALESCE(v_session.domains_completed, ARRAY[]::TEXT[]),
    'domains_remaining', v_remaining,
    'next_domain', CASE WHEN array_length(v_remaining, 1) > 0 THEN v_remaining[1] ELSE NULL END,
    'next_questions', v_next_questions,
    'answers_received', v_session.answers_received,
    'progress_pct', CASE 
      WHEN array_length(v_all_domains, 1) > 0 
      THEN ROUND(100.0 * COALESCE(array_length(v_session.domains_completed, 1), 0) / array_length(v_all_domains, 1))
      ELSE 0 
    END,
    'summary', v_session.summary,
    'started_at', v_session.started_at,
    'completed_at', v_session.completed_at
  );
END;
$$;


--
-- Name: get_lesson_category_counts(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_lesson_category_counts() RETURNS TABLE(category text, severity text, count bigint, promoted bigint)
    LANGUAGE sql STABLE
    AS $$
  SELECT 
    COALESCE(category, 'uncategorized') as category,
    COALESCE(severity, 'unknown') as severity,
    COUNT(*) as count,
    COUNT(*) FILTER (WHERE applied_to_directives = true) as promoted
  FROM lessons
  GROUP BY category, severity
  ORDER BY count DESC;
$$;


--
-- Name: get_manifest(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_manifest(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN COALESCE(
    (
      SELECT jsonb_agg(row_to_json(m) ORDER BY m.ac_number, m.step_order)
      FROM wo_execution_manifest m
      WHERE m.work_order_id = p_work_order_id
    ),
    '[]'::jsonb
  );
END;
$$;


--
-- Name: get_manifold_dashboard(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_manifold_dashboard() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  result JSONB;
BEGIN
  result := JSONB_BUILD_OBJECT(
    'pipeline_runs',
    COALESCE(
      (SELECT JSONB_AGG(row_to_json(pr)) FROM (
        SELECT id, spec_wo_id, status, current_phase, 
               phase_history, config, created_at, updated_at,
               slug, display_name
        FROM pipeline_runs
        ORDER BY created_at DESC LIMIT 50
      ) pr),
      '[]'::JSONB
    ),
    
    'ontology_summary',
    COALESCE(
      (SELECT JSONB_BUILD_OBJECT(
        'total_objects', (SELECT COUNT(*) FROM object_registry),
        'objects_with_properties', (SELECT COUNT(*) FROM object_registry WHERE properties IS NOT NULL AND properties != '{}'::JSONB),
        'total_links', (SELECT COUNT(*) FROM object_links),
        'by_type', COALESCE((SELECT JSONB_OBJECT_AGG(object_type, cnt) FROM (SELECT object_type, COUNT(*) as cnt FROM object_registry GROUP BY object_type) t), '{}'::JSONB),
        'by_link_type', COALESCE((SELECT JSONB_OBJECT_AGG(link_type, cnt) FROM (SELECT link_type, COUNT(*) as cnt FROM object_links GROUP BY link_type) t), '{}'::JSONB)
      )),
      JSONB_BUILD_OBJECT('total_objects', 0, 'objects_with_properties', 0, 'total_links', 0, 'by_type', '{}'::JSONB, 'by_link_type', '{}'::JSONB)
    ),
    
    'active_pipeline_wos',
    COALESCE(
      (SELECT JSONB_AGG(row_to_json(w)) FROM (
        SELECT id, slug, name, status, priority, pipeline_phase, pipeline_run_id, created_at, started_at
        FROM work_orders
        WHERE pipeline_run_id IS NOT NULL 
          AND status IN ('draft', 'ready', 'in_progress', 'review')
        ORDER BY created_at DESC
      ) w),
      '[]'::JSONB
    ),
    
    'tool_reliability',
    COALESCE(
      (SELECT JSONB_AGG(row_to_json(tsr)) FROM (
        SELECT tool_name, object_type, action, success_rate, total_attempts, successes
        FROM action_success_rates
        ORDER BY total_attempts DESC LIMIT 15
      ) tsr),
      '[]'::JSONB
    ),
    
    'recent_mutations',
    COALESCE(
      (SELECT JSONB_AGG(JSONB_BUILD_OBJECT(
        'hour', hour_bucket,
        'total', total_count,
        'successes', success_count,
        'failures', failure_count
      )) FROM (
        SELECT 
          date_trunc('hour', created_at) as hour_bucket,
          COUNT(*) as total_count,
          COUNT(*) FILTER (WHERE success = true) as success_count,
          COUNT(*) FILTER (WHERE success = false) as failure_count
        FROM wo_mutations
        WHERE created_at > now() - interval '24 hours'
        GROUP BY date_trunc('hour', created_at)
        ORDER BY hour_bucket DESC
      ) m),
      '[]'::JSONB
    ),
    
    'agent_status',
    COALESCE(
      (SELECT JSONB_AGG(row_to_json(a)) FROM (
        SELECT id, name, agent_type, status, role, execution_mode, model, tools_allowed
        FROM agents
        WHERE status = 'active'
        ORDER BY name
      ) a),
      '[]'::JSONB
    )
  );
  
  RETURN result;
END;
$$;


--
-- Name: get_model_price(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_model_price(p_model_id text) RETURNS TABLE(input_price numeric, output_price numeric, cached_price numeric)
    LANGUAGE sql STABLE
    AS $$
  select 
    input_price_per_m,
    output_price_per_m,
    cached_input_price_per_m
  from public.model_pricing
  where model_id = p_model_id
  order by effective_date desc
  limit 1;
$$;


--
-- Name: get_mutation_velocity(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_mutation_velocity(p_hours integer DEFAULT 24) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
BEGIN
  RETURN (
    WITH agg AS (
      SELECT 
        date_trunc('hour', created_at) AS hour_bucket,
        count(*) AS total,
        count(*) FILTER (WHERE success = true) AS success,
        count(*) FILTER (WHERE success = false) AS failure
      FROM wo_mutations
      WHERE created_at > now() - (p_hours || ' hours')::interval
      GROUP BY 1
    )
    SELECT COALESCE(
      jsonb_agg(
        jsonb_build_object(
          'hour', hour_bucket,
          'total', total,
          'success', COALESCE(success, 0),
          'failure', COALESCE(failure, 0),
          'by_tool', '{}'::jsonb
        ) ORDER BY hour_bucket
      ),
      '[]'::jsonb
    )
    FROM agg
  );
END;
$$;


--
-- Name: get_next_escalation_tier(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_next_escalation_tier(p_agent_name text, p_current_model text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_current_tier_order int;
    v_next RECORD;
    v_max_tier int;
BEGIN
    -- Find current tier
    SELECT tier_order INTO v_current_tier_order
    FROM agent_escalation_tiers
    WHERE agent_name = p_agent_name AND model = p_current_model
    ORDER BY tier_order
    LIMIT 1;
    
    -- If current model not found in tiers, treat as tier 0
    IF v_current_tier_order IS NULL THEN
        v_current_tier_order := 0;
    END IF;
    
    -- Get max tier for this agent
    SELECT MAX(tier_order) INTO v_max_tier
    FROM agent_escalation_tiers
    WHERE agent_name = p_agent_name;
    
    -- If already at max or no tiers exist
    IF v_max_tier IS NULL OR v_current_tier_order >= v_max_tier THEN
        RETURN jsonb_build_object(
            'next_model', p_current_model,
            'tier_order', COALESCE(v_current_tier_order, 0),
            'is_max_tier', true
        );
    END IF;
    
    -- Get next tier
    SELECT model, tier_order, description INTO v_next
    FROM agent_escalation_tiers
    WHERE agent_name = p_agent_name AND tier_order > v_current_tier_order
    ORDER BY tier_order
    LIMIT 1;
    
    RETURN jsonb_build_object(
        'next_model', v_next.model,
        'tier_order', v_next.tier_order,
        'is_max_tier', v_next.tier_order >= v_max_tier,
        'description', v_next.description
    );
END;
$$;


--
-- Name: get_next_migration(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_next_migration() RETURNS TABLE(slug text, name text, description text, sequence integer, dependencies text[], ready boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pm.slug,
    pm.name,
    pm.description,
    pm.sequence,
    pm.dependencies,
    NOT EXISTS (
      SELECT 1 FROM unnest(pm.dependencies) d
      JOIN pending_migrations dep ON dep.slug = d
      WHERE dep.status != 'completed'
    ) AS ready
  FROM pending_migrations pm
  WHERE pm.status = 'pending'
  ORDER BY pm.sequence
  LIMIT 1;
END;
$$;


--
-- Name: get_ontology_health(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_ontology_health() RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE result JSONB;
BEGIN
  result := jsonb_build_object(
    'total_objects', (SELECT COUNT(*) FROM object_registry),
    'total_links', (SELECT COUNT(*) FROM object_links),
    'stale_count', (SELECT COUNT(*) FROM object_registry WHERE created_at < now() - interval '7 days')
  );
  RETURN result;
END;
$$;


--
-- Name: get_pipeline_detail(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_pipeline_detail(p_pipeline_run_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_result JSONB := '{}'::jsonb;
  v_pipeline pipeline_runs%ROWTYPE;
  v_phase TEXT;
  v_wos JSONB;
  v_mutations JSONB;
BEGIN
  -- Get pipeline row
  SELECT * INTO v_pipeline FROM pipeline_runs WHERE id = p_pipeline_run_id;
  
  IF NOT FOUND THEN
    RETURN '{"error": "pipeline_run not found"}'::jsonb;
  END IF;

  v_result := jsonb_build_object('pipeline', jsonb_build_object(
    'id', v_pipeline.id,
    'spec_wo_id', v_pipeline.spec_wo_id,
    'current_phase', v_pipeline.current_phase,
    'status', v_pipeline.status,
    'target', v_pipeline.target,
    'description', v_pipeline.description,
    'phase_history', v_pipeline.phase_history,
    'created_at', v_pipeline.created_at
  ));

  -- Get spec wo with agent name
  IF v_pipeline.spec_wo_id IS NOT NULL THEN
    v_result := v_result || jsonb_build_object('spec_wo', 
      (SELECT jsonb_build_object('id', id, 'slug', slug, 'name', name, 'status', status, 'agent_name', 
        (SELECT name FROM agents WHERE id = work_orders.assigned_to))
       FROM work_orders WHERE id = v_pipeline.spec_wo_id));
  ELSE
    v_result := v_result || jsonb_build_object('spec_wo', NULL::jsonb);
  END IF;

  -- Phase WOs with agent names
  v_result := v_result || jsonb_build_object('phase_wos', '{}'::jsonb);
  
  FOR v_phase, v_wos IN
    SELECT wo.pipeline_phase, jsonb_agg(jsonb_build_object(
      'id', wo.id, 
      'slug', wo.slug, 
      'name', wo.name, 
      'status', wo.status, 
      'priority', wo.priority, 
      'assigned_to', wo.assigned_to,
      'agent_name', (SELECT name FROM agents WHERE id = wo.assigned_to),
      'duration_min', EXTRACT(EPOCH FROM (COALESCE(wo.completed_at, NOW()) - wo.created_at)) / 60
    ))
    FROM work_orders wo
    WHERE wo.pipeline_run_id = p_pipeline_run_id AND wo.pipeline_phase IS NOT NULL
    GROUP BY wo.pipeline_phase
  LOOP
    v_result := jsonb_set(v_result, ARRAY['phase_wos', v_phase], COALESCE(v_wos, '[]'::jsonb));
  END LOOP;

  -- Get HARDEN phase data
  v_result := v_result || jsonb_build_object('harden_data', 
    (SELECT jsonb_build_object(
      'red_team_count', (SELECT COUNT(*)::int FROM work_orders WHERE pipeline_run_id = p_pipeline_run_id AND pipeline_phase = 'harden' AND name ILIKE '%red%'),
      'blue_team_count', (SELECT COUNT(*)::int FROM work_orders WHERE pipeline_run_id = p_pipeline_run_id AND pipeline_phase = 'harden' AND name ILIKE '%blue%')
    ))
  );

  -- Get mutations - use subquery to avoid GROUP BY issues
  SELECT COALESCE(jsonb_agg(m.* ORDER BY m.created_at DESC), '[]'::jsonb)
  INTO v_mutations
  FROM (
    SELECT m.id, m.work_order_id, m.tool_name, m.action, m.success, m.created_at, m.agent_name
    FROM wo_mutations m
    JOIN work_orders wo ON m.work_order_id = wo.id
    WHERE wo.pipeline_run_id = p_pipeline_run_id
    ORDER BY m.created_at DESC
    LIMIT 500
  ) m;
  
  v_result := v_result || jsonb_build_object('mutations', v_mutations);

  -- Empty contracts/manifest for backward compat
  v_result := v_result || '{"contracts": [], "manifest_steps": []}'::jsonb;

  RETURN v_result;
END;
$$;


--
-- Name: get_promoted_lessons_for_role(text, text[], integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_promoted_lessons_for_role(p_role text DEFAULT 'builder'::text, p_wo_tags text[] DEFAULT '{}'::text[], p_limit integer DEFAULT 10) RETURNS TABLE(id uuid, pattern text, rule text, category text, severity text, promoted_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_categories TEXT[];
BEGIN
  -- Role-to-category mapping (AC#3)
  -- Builder gets schema, deployment, RPC, migration lessons
  -- QA-gate gets QA, testing, acceptance criteria lessons
  -- Ops gets operational, monitoring, failure archetype lessons
  -- Security gets security, enforcement lessons
  v_categories := CASE p_role
    WHEN 'builder' THEN ARRAY['state_machine', 'execution', 'scope_creep', 'hallucination', 'tool_misuse', 'format_violation', 'context_loss', 'incorrect_assumption', 'performance', 'general']
    WHEN 'qa-gate' THEN ARRAY['execution', 'scope_creep', 'format_violation', 'general']
    WHEN 'ops' THEN ARRAY['execution', 'state_machine', 'general']
    WHEN 'security' THEN ARRAY['security', 'authorization', 'general']
    ELSE ARRAY['execution', 'general'] -- default fallback
  END;

  RETURN QUERY
  SELECT 
    l.id,
    l.pattern,
    l.rule,
    l.category::TEXT,
    l.severity::TEXT,
    l.promoted_at
  FROM lessons l
  WHERE l.promoted_at IS NOT NULL
    AND (
      l.category::TEXT = ANY(v_categories)
      OR (array_length(p_wo_tags, 1) > 0 AND l.pattern ILIKE ANY(
        SELECT '%' || unnest(p_wo_tags) || '%'
      ))
    )
  ORDER BY 
    CASE l.severity 
      WHEN 'critical' THEN 1 
      WHEN 'high' THEN 2 
      WHEN 'medium' THEN 3 
      WHEN 'low' THEN 4 
      ELSE 5 
    END,
    l.promoted_at DESC
  LIMIT p_limit;
END;
$$;


--
-- Name: get_regression_suite_dashboard(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_regression_suite_dashboard() RETURNS TABLE(suite_name text, canonical_wo_slug text, baseline_score numeric, latest_test_score numeric, latest_delta_pct numeric, latest_status text, total_runs integer, pass_rate numeric, last_run_at timestamp with time zone, active boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    sd.suite_name,
    sd.canonical_wo_slug,
    sd.baseline_score,
    latest.test_score AS latest_test_score,
    latest.score_delta_pct AS latest_delta_pct,
    latest.status AS latest_status,
    COALESCE(run_stats.total_runs, 0)::INT AS total_runs,
    COALESCE(run_stats.pass_rate, 0) AS pass_rate,
    latest.run_timestamp AS last_run_at,
    sd.active
  FROM regression_suite_definitions sd
  LEFT JOIN LATERAL (
    SELECT rsr.test_score, rsr.score_delta_pct, rsr.status, rsr.run_timestamp
    FROM regression_suite_runs rsr
    WHERE rsr.suite_definition_id = sd.id
    ORDER BY rsr.run_timestamp DESC
    LIMIT 1
  ) latest ON true
  LEFT JOIN LATERAL (
    SELECT 
      COUNT(*)::INT AS total_runs,
      ROUND((COUNT(*) FILTER (WHERE status = 'pass')::NUMERIC / NULLIF(COUNT(*), 0)) * 100, 2) AS pass_rate
    FROM regression_suite_runs rsr
    WHERE rsr.suite_definition_id = sd.id
  ) run_stats ON true
  ORDER BY sd.suite_name;
END;
$$;


--
-- Name: FUNCTION get_regression_suite_dashboard(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_regression_suite_dashboard() IS 'Get regression suite dashboard data with pass rates and latest results';


--
-- Name: get_relevant_lessons(uuid, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_relevant_lessons(p_work_order_id uuid, p_include_acknowledged boolean DEFAULT false) RETURNS TABLE(lesson_id uuid, pattern text, rule text, severity text, category text, match_reason text, already_acknowledged boolean, acknowledgment_decision text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_tags text[];
  v_objective text;
BEGIN
  -- Get WO tags and objective for matching
  SELECT tags, objective 
  INTO v_tags, v_objective
  FROM work_orders 
  WHERE id = p_work_order_id;

  RETURN QUERY
  SELECT 
    l.id as lesson_id,
    l.pattern,
    l.rule,
    l.severity,
    l.category,
    CASE 
      WHEN l.category = ANY(v_tags) THEN 'category_match: ' || l.category
      WHEN EXISTS (
        SELECT 1 FROM unnest(v_tags) t 
        WHERE l.context ILIKE '%' || t || '%'
      ) THEN 'context_keyword_match'
      ELSE 'high_severity'
    END as match_reason,
    (la.id IS NOT NULL) as already_acknowledged,
    la.decision as acknowledgment_decision
  FROM lessons l
  LEFT JOIN lesson_acknowledgments la 
    ON la.lesson_id = l.id AND la.work_order_id = p_work_order_id
  WHERE 
    -- Only unapplied lessons
    (l.applied_to_directives = false OR l.applied_to_directives IS NULL)
    -- Match by category/tag overlap, context keywords, or critical severity
    AND (
      l.category = ANY(v_tags)
      OR l.severity IN ('critical', 'high')
      OR EXISTS (
        SELECT 1 FROM unnest(v_tags) t 
        WHERE l.context ILIKE '%' || t || '%' OR l.rule ILIKE '%' || t || '%'
      )
    )
    -- Filter out already acknowledged unless requested
    AND (p_include_acknowledged OR la.id IS NULL)
  ORDER BY 
    CASE l.severity 
      WHEN 'critical' THEN 1
      WHEN 'high' THEN 2
      WHEN 'medium' THEN 3
      ELSE 4
    END,
    l.created_at DESC
  LIMIT 20;
END;
$$;


--
-- Name: FUNCTION get_relevant_lessons(p_work_order_id uuid, p_include_acknowledged boolean); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_relevant_lessons(p_work_order_id uuid, p_include_acknowledged boolean) IS 'Returns domain-relevant unapplied lessons for a WO based on tags and severity';


--
-- Name: get_routing_decision(text, text, text, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_routing_decision(p_intent text, p_domain text, p_risk_tier text, p_complexity double precision) RETURNS TABLE(rule_id uuid, target_model text, temperature double precision, max_tokens integer, rule_name text)
    LANGUAGE sql STABLE
    AS $$
  select 
    r.id,
    r.target_model,
    r.temperature,
    r.max_tokens,
    r.name
  from public.routing_rules r
  join public.model_capabilities mc on mc.model_id = r.target_model
  where r.enabled = true
    and mc.is_available = true
    and (r.intent is null or r.intent = p_intent)
    and (r.domain is null or r.domain = p_domain)
    and (r.risk_tier is null or r.risk_tier = p_risk_tier)
    and (r.complexity_min is null or p_complexity >= r.complexity_min)
    and (r.complexity_max is null or p_complexity <= r.complexity_max)
  order by r.priority asc
  limit 1;
$$;


--
-- Name: get_schema_context(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_schema_context() RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_result TEXT := '';
  v_rec RECORD;
BEGIN
  v_result := E'# DATABASE SCHEMA CONTEXT\n\n';
  v_result := v_result || E'**CRITICAL**: The following schema is the ACTUAL database structure.\n';
  v_result := v_result || E'Only use column names, enum values, and RPC signatures listed here.\n';
  v_result := v_result || E'DO NOT guess or invent column names — refer to this schema.\n\n';

  -- Key tables and their columns
  v_result := v_result || E'## Tables and Columns\n';
  FOR v_rec IN
    SELECT c.table_name,
           string_agg(
             '- `' || c.column_name || '`: ' || c.udt_name ||
             CASE WHEN c.is_nullable = 'NO' THEN ' (NOT NULL)' ELSE '' END,
             E'\n' ORDER BY c.ordinal_position
           ) as cols
    FROM information_schema.columns c
    WHERE c.table_schema = 'public'
      AND c.table_name IN (
        'work_orders', 'system_manifest', 'state_mutations', 'audit_log',
        'lessons', 'system_directives', 'project_briefs', 'qa_findings',
        'agents', 'decisions', 'schema_changes', 'work_order_execution_log',
        'enforcer_findings', 'conversation_threads', 'project_documents'
      )
    GROUP BY c.table_name
    ORDER BY c.table_name
  LOOP
    v_result := v_result || E'### ' || v_rec.table_name || E'\n' || v_rec.cols || E'\n\n';
  END LOOP;

  -- Enum types and valid values
  v_result := v_result || E'## Enum Types\n';
  FOR v_rec IN
    SELECT t.typname,
           string_agg('''' || e.enumlabel || '''', ', ' ORDER BY e.enumsortorder) as vals
    FROM pg_type t
    JOIN pg_enum e ON e.enumtypid = t.oid
    WHERE t.typname IN (
      'work_order_status', 'work_order_priority', 'agent_type',
      'audit_severity', 'error_severity', 'error_category',
      'decision_status', 'decision_type', 'entity_type'
    )
    GROUP BY t.typname
    ORDER BY t.typname
  LOOP
    v_result := v_result || E'### ' || v_rec.typname || E'\n';
    v_result := v_result || 'Valid values: ' || v_rec.vals || E'\n\n';
  END LOOP;

  -- Key RPC signatures
  v_result := v_result || E'## RPC Functions\n';
  FOR v_rec IN
    SELECT p.proname,
           pg_get_function_arguments(p.oid) as args,
           pg_get_function_result(p.oid) as returns
    FROM pg_proc p
    JOIN pg_namespace n ON n.oid = p.pronamespace
    WHERE n.nspname = 'public'
      AND p.proname IN (
        'update_work_order_state', 'create_draft_work_order', 'start_work_order',
        'state_write', 'validate_wo_freshness', 'validate_deployment_readiness',
        'initialize_qa_checklist', 'update_checklist_item', 'is_qa_checklist_complete',
        'auto_create_lesson', 'record_verification', 'check_allowed_action',
        'get_schema_context'
      )
    ORDER BY p.proname
  LOOP
    v_result := v_result || E'### ' || v_rec.proname || E'\n';
    v_result := v_result || 'Parameters: ' || COALESCE(v_rec.args, 'none') || E'\n';
    v_result := v_result || 'Returns: ' || COALESCE(v_rec.returns, 'void') || E'\n\n';
  END LOOP;

  RETURN v_result;
END;
$$;


--
-- Name: get_session_summary(text, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_session_summary(p_project_code text DEFAULT NULL::text, p_since timestamp with time zone DEFAULT (now() - '7 days'::interval)) RETURNS TABLE(category text, items jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- COMPLETED: Done work orders since p_since
  RETURN QUERY
  SELECT 
    'completed'::TEXT,
    COALESCE(jsonb_agg(jsonb_build_object(
      'slug', wo.slug,
      'name', wo.name,
      'completed_at', wo.completed_at
    ) ORDER BY wo.completed_at DESC), '[]'::jsonb)
  FROM work_orders wo
  LEFT JOIN project_briefs pb ON wo.project_brief_id = pb.id
  WHERE wo.status = 'done'
    AND wo.completed_at >= p_since
    AND (p_project_code IS NULL OR pb.code = p_project_code);
  
  -- IN_PROGRESS
  RETURN QUERY
  SELECT 
    'in_progress'::TEXT,
    COALESCE(jsonb_agg(jsonb_build_object(
      'slug', wo.slug,
      'name', wo.name,
      'started_at', wo.started_at,
      'assigned_to', a.name
    ) ORDER BY wo.started_at DESC), '[]'::jsonb)
  FROM work_orders wo
  LEFT JOIN project_briefs pb ON wo.project_brief_id = pb.id
  LEFT JOIN agents a ON wo.assigned_to = a.id
  WHERE wo.status = 'in_progress'
    AND (p_project_code IS NULL OR pb.code = p_project_code);
  
  -- BLOCKED
  RETURN QUERY
  SELECT 
    'blocked'::TEXT,
    COALESCE(jsonb_agg(jsonb_build_object(
      'slug', wo.slug,
      'name', wo.name,
      'reason', wo.escalation_conditions
    )), '[]'::jsonb)
  FROM work_orders wo
  LEFT JOIN project_briefs pb ON wo.project_brief_id = pb.id
  WHERE wo.status = 'blocked'
    AND (p_project_code IS NULL OR pb.code = p_project_code);
  
  -- PENDING_APPROVAL
  RETURN QUERY
  SELECT 
    'pending_approval'::TEXT,
    COALESCE(jsonb_agg(jsonb_build_object(
      'slug', wo.slug,
      'name', wo.name,
      'created_at', wo.created_at
    ) ORDER BY wo.created_at DESC), '[]'::jsonb)
  FROM work_orders wo
  LEFT JOIN project_briefs pb ON wo.project_brief_id = pb.id
  WHERE wo.status = 'pending_approval'
    AND (p_project_code IS NULL OR pb.code = p_project_code);
  
  -- BUGS
  RETURN QUERY
  SELECT 
    'bugs'::TEXT,
    COALESCE(jsonb_agg(jsonb_build_object(
      'id', qf.id,
      'category', qf.category,
      'description', qf.description,
      'work_order', wo.slug
    )), '[]'::jsonb)
  FROM qa_findings qf
  LEFT JOIN work_orders wo ON qf.work_order_id = wo.id
  WHERE qf.finding_type = 'fail'
    AND qf.resolved_at IS NULL;
  
  -- LESSONS: Counts + unreviewed (Fix 15)
  RETURN QUERY
  SELECT 
    'lessons'::TEXT,
    jsonb_build_object(
      'total_since', (SELECT COUNT(*) FROM lessons l1 WHERE l1.created_at >= p_since),
      'unreviewed', (SELECT COUNT(*) FROM lessons l2 WHERE l2.reviewed = false),
      'by_severity', (
        SELECT COALESCE(jsonb_object_agg(l3.severity, l3.cnt), '{}'::jsonb)
        FROM (
          SELECT ls.severity, COUNT(*) as cnt 
          FROM lessons ls
          WHERE ls.created_at >= p_since 
          GROUP BY ls.severity
        ) l3
      ),
      'by_category', (
        SELECT COALESCE(jsonb_object_agg(l4.cat, l4.cnt), '{}'::jsonb)
        FROM (
          SELECT lc.category as cat, COUNT(*) as cnt 
          FROM lessons lc
          WHERE lc.created_at >= p_since 
          GROUP BY lc.category
          ORDER BY cnt DESC
          LIMIT 5
        ) l4
      ),
      'recent', (
        SELECT COALESCE(jsonb_agg(jsonb_build_object(
          'id', lr.id, 'pattern', lr.pattern, 'severity', lr.severity, 'category', lr.category
        )), '[]'::jsonb)
        FROM (SELECT * FROM lessons lrr WHERE lrr.reviewed = false ORDER BY lrr.created_at DESC LIMIT 5) lr
      )
    );
  
  -- HARNESS_STATS: Observability + directives (Fix 15)
  RETURN QUERY
  SELECT 
    'harness_stats'::TEXT,
    jsonb_build_object(
      'traces_total', (SELECT COUNT(*) FROM traces t WHERE t.started_at >= p_since),
      'traces_completed', (SELECT COUNT(*) FROM traces t WHERE t.started_at >= p_since AND t.status = 'completed'),
      'traces_error', (SELECT COUNT(*) FROM traces t WHERE t.started_at >= p_since AND t.status = 'error'),
      'spans_total', (SELECT COUNT(*) FROM spans s WHERE s.started_at >= p_since),
      'spans_completed', (SELECT COUNT(*) FROM spans s WHERE s.started_at >= p_since AND s.status = 'completed'),
      'spans_running', (SELECT COUNT(*) FROM spans s WHERE s.started_at >= p_since AND s.status = 'running'),
      'spans_by_type', (
        SELECT COALESCE(jsonb_object_agg(st.span_type, st.cnt), '{}'::jsonb)
        FROM (
          SELECT s2.span_type, COUNT(*) as cnt 
          FROM spans s2
          WHERE s2.started_at >= p_since 
          GROUP BY s2.span_type
        ) st
      ),
      'total_cost_usd', (SELECT COALESCE(SUM(t.total_cost_usd), 0) FROM traces t WHERE t.started_at >= p_since),
      'total_tokens', (SELECT COALESCE(SUM(t.total_tokens), 0) FROM traces t WHERE t.started_at >= p_since),
      'avg_latency_ms', (
        SELECT COALESCE(AVG(s.latency_ms), 0)
        FROM spans s
        WHERE s.started_at >= p_since AND s.status = 'completed'
      ),
      'directives_active', (SELECT COUNT(*) FROM system_directives sd WHERE sd.active = true),
      'directives_hard', (SELECT COUNT(*) FROM system_directives sd WHERE sd.active = true AND sd.enforcement = 'hard')
    );
  
  -- MUTATIONS
  RETURN QUERY
  SELECT 
    'mutations'::TEXT,
    jsonb_build_object(
      'total', (SELECT COUNT(*) FROM state_mutations sm WHERE sm.created_at >= p_since),
      'by_table', (
        SELECT COALESCE(jsonb_object_agg(mt.target_table, mt.cnt), '{}'::jsonb)
        FROM (
          SELECT sm.target_table, COUNT(*) as cnt 
          FROM state_mutations sm
          WHERE sm.created_at >= p_since 
          GROUP BY sm.target_table
          ORDER BY cnt DESC
          LIMIT 10
        ) mt
      ),
      'by_type', (
        SELECT COALESCE(jsonb_object_agg(mm.mutation_type, mm.cnt), '{}'::jsonb)
        FROM (
          SELECT sm.mutation_type, COUNT(*) as cnt 
          FROM state_mutations sm
          WHERE sm.created_at >= p_since 
          GROUP BY sm.mutation_type
        ) mm
      )
    );

END;
$$;


--
-- Name: get_team_context(uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_team_context(p_work_order_id uuid, p_max_chars integer DEFAULT 10000) RETURNS TABLE(id uuid, context_type text, author_agent text, content text, metadata jsonb, source_wo_slug text, created_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_root_wo_id uuid;
  v_current_id uuid;
  v_parent_id uuid;
  v_depth int := 0;
BEGIN
  -- Walk up parent_id chain to find root WO
  v_current_id := p_work_order_id;
  LOOP
    SELECT wo.parent_id INTO v_parent_id FROM work_orders wo WHERE wo.id = v_current_id;
    IF v_parent_id IS NULL THEN
      v_root_wo_id := v_current_id;
      EXIT;
    END IF;
    v_current_id := v_parent_id;
    v_depth := v_depth + 1;
    IF v_depth > 20 THEN
      v_root_wo_id := v_current_id;
      EXIT;
    END IF;
  END LOOP;

  -- Return team context entries, prioritizing plan and decision types
  -- Uses a running char count to stay within limit
  RETURN QUERY
  WITH ranked AS (
    SELECT 
      tc.id,
      tc.context_type,
      tc.author_agent,
      tc.content,
      tc.metadata,
      wo.slug as source_wo_slug,
      tc.created_at,
      -- Prioritize: plan=1, decision=2, schema_change=3, finding=4, file_list=5
      CASE tc.context_type
        WHEN 'plan' THEN 1
        WHEN 'decision' THEN 2
        WHEN 'schema_change' THEN 3
        WHEN 'finding' THEN 4
        WHEN 'file_list' THEN 5
      END as type_priority,
      SUM(length(tc.content)) OVER (
        ORDER BY 
          CASE tc.context_type
            WHEN 'plan' THEN 1
            WHEN 'decision' THEN 2
            WHEN 'schema_change' THEN 3
            WHEN 'finding' THEN 4
            WHEN 'file_list' THEN 5
          END,
          tc.created_at DESC
      ) as running_chars
    FROM team_context tc
    LEFT JOIN work_orders wo ON wo.id = tc.source_wo_id
    WHERE tc.root_wo_id = v_root_wo_id
  )
  SELECT 
    ranked.id,
    ranked.context_type,
    ranked.author_agent,
    ranked.content,
    ranked.metadata,
    ranked.source_wo_slug,
    ranked.created_at
  FROM ranked
  WHERE ranked.running_chars <= p_max_chars
  ORDER BY ranked.type_priority, ranked.created_at DESC;
END;
$$;


--
-- Name: FUNCTION get_team_context(p_work_order_id uuid, p_max_chars integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_team_context(p_work_order_id uuid, p_max_chars integer) IS 'Load team context for a WO tree. Walks to root, returns entries prioritized by type, capped at max_chars.';


--
-- Name: get_transition_path(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_transition_path(p_from_status text, p_to_status text) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_valid_next text[];
  v_path text[];
  v_is_direct boolean := false;
BEGIN
  -- Cast text to work_order_status enum and call the enum version
  RETURN get_transition_path(p_from_status::work_order_status, p_to_status::work_order_status);
END;
$$;


--
-- Name: get_transition_path(public.work_order_status, public.work_order_status); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_transition_path(p_from_status public.work_order_status, p_to_status public.work_order_status) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_valid_next text[];
  v_path text[];
  v_is_direct boolean := false;
BEGIN
  -- Check if direct transition is valid
  v_valid_next := get_valid_next_states(p_from_status);
  v_is_direct := (p_to_status::text = ANY(v_valid_next));
  
  IF v_is_direct THEN
    RETURN jsonb_build_object(
      'valid', true,
      'direct', true,
      'path', ARRAY[p_from_status::text, p_to_status::text],
      'steps', 1
    );
  END IF;
  
  -- Provide suggested paths for common invalid transitions
  v_path := CASE
    -- From 'done' - can only go to 'cancelled', then to 'draft' if needed
    WHEN p_from_status = 'done' AND p_to_status = 'failed' THEN
      ARRAY[p_from_status::text, 'cancelled', 'draft', 'ready', 'in_progress', 'failed']
    WHEN p_from_status = 'done' AND p_to_status IN ('in_progress', 'review') THEN
      ARRAY[p_from_status::text, 'cancelled', 'draft', 'ready', 'in_progress']
    WHEN p_from_status = 'done' AND p_to_status = 'draft' THEN
      ARRAY[p_from_status::text, 'cancelled', 'draft']
      
    -- From 'failed' - must go to 'draft' or 'in_progress' first
    WHEN p_from_status = 'failed' AND p_to_status = 'review' THEN
      ARRAY[p_from_status::text, 'in_progress', 'review']
    WHEN p_from_status = 'failed' AND p_to_status = 'done' THEN
      ARRAY[p_from_status::text, 'in_progress', 'review', 'done']
    WHEN p_from_status = 'failed' AND p_to_status = 'ready' THEN
      ARRAY[p_from_status::text, 'draft', 'ready']
      
    -- From 'ready' - must go to 'in_progress' first before 'failed'
    WHEN p_from_status = 'ready' AND p_to_status = 'failed' THEN
      ARRAY[p_from_status::text, 'in_progress', 'failed']
    WHEN p_from_status = 'ready' AND p_to_status = 'review' THEN
      ARRAY[p_from_status::text, 'in_progress', 'review']
    WHEN p_from_status = 'ready' AND p_to_status = 'done' THEN
      ARRAY[p_from_status::text, 'in_progress', 'review', 'done']
      
    -- From 'review' - can only go back to 'in_progress' or forward to 'done'/'failed'
    WHEN p_from_status = 'review' AND p_to_status = 'ready' THEN
      ARRAY[p_from_status::text, 'in_progress', 'blocked', 'draft', 'ready']
      
    ELSE
      ARRAY[]::text[]
  END;
  
  IF array_length(v_path, 1) > 0 THEN
    RETURN jsonb_build_object(
      'valid', false,
      'direct', false,
      'from', p_from_status::text,
      'to', p_to_status::text,
      'suggested_path', v_path,
      'steps', array_length(v_path, 1) - 1,
      'message', format('Invalid direct transition from %s to %s. Suggested path: %s', 
        p_from_status, p_to_status, array_to_string(v_path, ' → '))
    );
  END IF;
  
  -- No known path
  RETURN jsonb_build_object(
    'valid', false,
    'direct', false,
    'from', p_from_status::text,
    'to', p_to_status::text,
    'message', format('No valid transition path from %s to %s. Valid next states from %s: %s',
      p_from_status, p_to_status, p_from_status, array_to_string(v_valid_next, ', '))
  );
END;
$$;


--
-- Name: FUNCTION get_transition_path(p_from_status public.work_order_status, p_to_status public.work_order_status); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_transition_path(p_from_status public.work_order_status, p_to_status public.work_order_status) IS 'Returns suggested transition path between two states, or error if invalid';


--
-- Name: get_unacknowledged_regression_alerts(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_unacknowledged_regression_alerts() RETURNS TABLE(alert_id uuid, suite_name text, canonical_wo_slug text, alert_type text, severity text, message text, baseline_score numeric, test_score numeric, delta_pct numeric, created_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ra.id AS alert_id,
    sd.suite_name,
    sd.canonical_wo_slug,
    ra.alert_type,
    ra.severity,
    ra.message,
    rsr.baseline_score,
    rsr.test_score,
    rsr.score_delta_pct AS delta_pct,
    ra.created_at
  FROM regression_alerts ra
  JOIN regression_suite_runs rsr ON rsr.id = ra.suite_run_id
  JOIN regression_suite_definitions sd ON sd.id = rsr.suite_definition_id
  WHERE ra.acknowledged = false
  ORDER BY ra.severity DESC, ra.created_at DESC;
END;
$$;


--
-- Name: FUNCTION get_unacknowledged_regression_alerts(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_unacknowledged_regression_alerts() IS 'Get all unacknowledged regression alerts for dashboard';


--
-- Name: get_valid_next_states(public.work_order_status); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_valid_next_states(p_current_status public.work_order_status) RETURNS text[]
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN CASE p_current_status
    WHEN 'draft'            THEN ARRAY['ready', 'pending_approval', 'cancelled']
    WHEN 'ready'            THEN ARRAY['in_progress', 'blocked', 'cancelled']
    WHEN 'pending_approval' THEN ARRAY['ready', 'cancelled']
    WHEN 'in_progress'      THEN ARRAY['review', 'done', 'blocked', 'blocked_on_input', 'cancelled', 'failed']
    WHEN 'blocked'          THEN ARRAY['in_progress', 'draft', 'cancelled']
    WHEN 'blocked_on_input' THEN ARRAY['in_progress', 'failed', 'cancelled']
    WHEN 'review'           THEN ARRAY['done', 'in_progress', 'cancelled', 'failed']
    WHEN 'done'             THEN ARRAY['cancelled']
    WHEN 'cancelled'        THEN ARRAY['draft']
    WHEN 'failed'           THEN ARRAY['draft', 'cancelled', 'done']
    ELSE ARRAY[]::text[]
  END;
END;
$$;


--
-- Name: FUNCTION get_valid_next_states(p_current_status public.work_order_status); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_valid_next_states(p_current_status public.work_order_status) IS 'Returns array of valid next states for a given work order status';


--
-- Name: get_wo_enforcer_status(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_wo_enforcer_status(p_wo_id text) RETURNS TABLE(verified boolean, last_check timestamp with time zone, critical_findings integer, total_findings integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    wo.enforcer_verified,
    er.run_timestamp,
    COUNT(*) FILTER (WHERE ef.severity = 'critical')::INTEGER,
    COUNT(*)::INTEGER
  FROM work_orders wo
  LEFT JOIN enforcer_runs er ON wo.enforcer_run_id = er.id
  LEFT JOIN enforcer_findings ef ON ef.enforcer_run_id = er.id AND ef.work_order_id = wo.wo_id
  WHERE wo.wo_id = p_wo_id
  GROUP BY wo.enforcer_verified, er.run_timestamp;
END;
$$;


--
-- Name: get_wo_lesson_stats(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_wo_lesson_stats(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_result jsonb;
BEGIN
  SELECT jsonb_build_object(
    'total_relevant_lessons', COUNT(*),
    'acknowledged', COUNT(*) FILTER (WHERE la.id IS NOT NULL),
    'accepted', COUNT(*) FILTER (WHERE la.decision = 'accepted'),
    'deferred', COUNT(*) FILTER (WHERE la.decision = 'deferred'),
    'rejected', COUNT(*) FILTER (WHERE la.decision = 'rejected'),
    'pending', COUNT(*) FILTER (WHERE la.id IS NULL),
    'lessons', jsonb_agg(
      jsonb_build_object(
        'lesson_id', l.id,
        'pattern', l.pattern,
        'severity', l.severity,
        'acknowledged', (la.id IS NOT NULL),
        'decision', la.decision,
        'rationale', la.rationale
      ) ORDER BY 
        CASE WHEN la.id IS NULL THEN 0 ELSE 1 END,
        CASE l.severity WHEN 'critical' THEN 1 WHEN 'high' THEN 2 ELSE 3 END
    )
  )
  INTO v_result
  FROM get_relevant_lessons(p_work_order_id, true) rl
  JOIN lessons l ON l.id = rl.lesson_id
  LEFT JOIN lesson_acknowledgments la ON la.lesson_id = l.id AND la.work_order_id = p_work_order_id;
  
  RETURN COALESCE(v_result, '{}'::jsonb);
END;
$$;


--
-- Name: FUNCTION get_wo_lesson_stats(p_work_order_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.get_wo_lesson_stats(p_work_order_id uuid) IS 'Returns lesson acknowledgment stats for a specific work order';


--
-- Name: guard_remediation_qa_tools(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.guard_remediation_qa_tools(p_wo_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_tags TEXT[];
  v_has_unresolved_findings BOOLEAN;
  v_has_resolve_call BOOLEAN;
  v_has_update_call BOOLEAN;
BEGIN
  SELECT tags INTO v_tags FROM work_orders WHERE id = p_wo_id;
  
  -- Only enforce for remediation WOs
  IF NOT ('remediation' = ANY(COALESCE(v_tags, ARRAY[]::TEXT[]))) THEN
    RETURN true;
  END IF;

  -- Check for unresolved QA findings
  SELECT EXISTS(
    SELECT 1 FROM qa_findings WHERE work_order_id = p_wo_id AND resolved_at IS NULL
  ) INTO v_has_unresolved_findings;

  IF NOT v_has_unresolved_findings THEN
    RETURN true;
  END IF;

  -- Check if resolve_qa_findings was called
  SELECT EXISTS(
    SELECT 1 FROM work_order_execution_log
    WHERE work_order_id = p_wo_id AND phase = 'stream'
    AND detail->>'tool_name' = 'resolve_qa_findings' AND detail->>'event_type' = 'tool_result'
  ) INTO v_has_resolve_call;

  -- Check if update_qa_checklist was called
  SELECT EXISTS(
    SELECT 1 FROM work_order_execution_log
    WHERE work_order_id = p_wo_id AND phase = 'stream'
    AND detail->>'tool_name' = 'update_qa_checklist' AND detail->>'event_type' = 'tool_result'
  ) INTO v_has_update_call;

  RETURN v_has_resolve_call AND v_has_update_call;
END;
$$;


--
-- Name: guard_retry_limit(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.guard_retry_limit(p_payload jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_wo_id uuid;
  v_retry_count int;
  v_max_retries int;
BEGIN
  v_wo_id := (p_payload->>'work_order_id')::uuid;
  
  SELECT retry_count, COALESCE(max_retries, 3) 
  INTO v_retry_count, v_max_retries
  FROM work_orders WHERE id = v_wo_id;
  
  IF v_retry_count >= v_max_retries THEN
    RETURN jsonb_build_object(
      'allowed', false, 
      'reason', 'Max retries exhausted: ' || v_retry_count || '/' || v_max_retries
    );
  END IF;
  
  RETURN jsonb_build_object('allowed', true);
END;
$$;


--
-- Name: guard_start_work(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.guard_start_work(p_payload jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_objective text;
  v_acceptance_criteria text;
  v_complexity_threshold int;
  v_complexity_result jsonb;
  v_complexity_score int;
  v_wo_id uuid;
  v_gate_result jsonb;
  v_pre_exec_gate_enabled boolean;
BEGIN
  -- COMPLEXITY GATE
  v_objective := COALESCE(p_payload->>'objective', '');
  v_acceptance_criteria := COALESCE(p_payload->>'acceptance_criteria', '');
  
  IF v_objective != '' OR v_acceptance_criteria != '' THEN
    SELECT COALESCE((setting_value->>'value')::int, 5) INTO v_complexity_threshold
    FROM system_settings WHERE setting_key = 'complexity_gate_threshold';
    
    v_complexity_result := score_wo_complexity(v_objective, v_acceptance_criteria);
    v_complexity_score := (v_complexity_result->>'complexity_score')::int;
    
    IF v_complexity_score > COALESCE(v_complexity_threshold, 5) THEN
      RETURN jsonb_build_object(
        'ok', false,
        'error', 'WO too complex (score: ' || v_complexity_score || '). Decompose into smaller WOs.'
      );
    END IF;
  END IF;
  
  -- PRE-EXECUTION GATE
  v_pre_exec_gate_enabled := COALESCE(
    (SELECT (setting_value->>'value')::boolean FROM system_settings WHERE setting_key = 'pre_execution_gate_enabled'),
    true
  );
  
  IF v_pre_exec_gate_enabled AND p_payload->>'work_order_id' IS NOT NULL THEN
    v_wo_id := (p_payload->>'work_order_id')::uuid;
    v_gate_result := run_pre_execution_gate(v_wo_id);
    
    IF NOT (v_gate_result->>'passed')::boolean THEN
      RETURN jsonb_build_object(
        'ok', false,
        'error', 'Pre-execution gate failed: ' || COALESCE(
          array_to_string(ARRAY(SELECT jsonb_array_elements_text(COALESCE(v_gate_result->'rejection_reasons', '[]'::jsonb))), '; '),
          'unknown'
        )
      );
    END IF;
  END IF;
  
  RETURN jsonb_build_object('ok', true);
END;
$$;


--
-- Name: increment_retrieval_count(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.increment_retrieval_count(conversation_ids uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE conversations
  SET 
    retrieval_count = COALESCE(retrieval_count, 0) + 1,
    last_retrieved_at = NOW()
  WHERE id = ANY(conversation_ids);
END;
$$;


--
-- Name: initialize_qa_checklist(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.initialize_qa_checklist(wo_id uuid) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_wo RECORD;
  v_criteria_source TEXT;
  v_checklist jsonb := '[]'::jsonb;
BEGIN
  -- Get work order
  SELECT 
    acceptance_criteria, 
    objective 
  INTO v_wo
  FROM work_orders
  WHERE id = wo_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Work order not found: %', wo_id;
  END IF;

  -- Try acceptance_criteria first, fall back to objective
  v_criteria_source := COALESCE(
    NULLIF(trim(COALESCE(v_wo.acceptance_criteria, '')), ''),
    NULLIF(trim(COALESCE(v_wo.objective, '')), '')
  );

  -- Parse criteria if source exists and has items
  IF v_criteria_source IS NOT NULL 
     AND count_acceptance_criteria(v_criteria_source) > 0 THEN
    v_checklist := parse_criteria_to_checklist(v_criteria_source);
  END IF;

  -- Update work order only if checklist is currently empty
  UPDATE work_orders
  SET qa_checklist = v_checklist,
      updated_at = now()
  WHERE id = wo_id
  AND (qa_checklist IS NULL OR jsonb_array_length(qa_checklist) = 0);

  RETURN v_checklist;
END;
$$;


--
-- Name: FUNCTION initialize_qa_checklist(wo_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.initialize_qa_checklist(wo_id uuid) IS 'WO-0015: Initialize QA checklist from acceptance_criteria or objective. Returns empty if no criteria found (no generic defaults).';


--
-- Name: insert_auto_close_approval(uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_auto_close_approval(p_work_order_id uuid, p_checklist_items integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload, work_order_id)
  VALUES (
    'approval',
    'system',
    'auto_close_qa_pass',
    'work_order',
    p_work_order_id,
    'approve',
    jsonb_build_object('source', 'auto_qa_pass', 'checklist_verdict', 'pass', 'checklist_items', p_checklist_items),
    p_work_order_id
  );
END;
$$;


--
-- Name: insert_kb_entry(text, text, text, text[], text[], text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_kb_entry(p_category text, p_topic text, p_content text, p_applicable_roles text[] DEFAULT NULL::text[], p_applicable_tags text[] DEFAULT NULL::text[], p_severity text DEFAULT 'medium'::text, p_active boolean DEFAULT true) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_id uuid;
BEGIN
  INSERT INTO agent_knowledge_base (
    category, topic, content, applicable_roles, applicable_tags, severity, active
  )
  VALUES (
    p_category, p_topic, p_content, p_applicable_roles, p_applicable_tags, p_severity, p_active
  )
  RETURNING id INTO v_id;
  
  RETURN v_id;
END;
$$;


--
-- Name: insert_kb_patch_file(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_kb_patch_file() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO agent_knowledge_base (topic, content, category, applicable_roles, applicable_tags, severity, active)
  VALUES (
    'patch_file_preferred_over_github_push_files',
    'Use patch_file tool instead of github_push_files for modifying existing files. patch_file accepts old_string/new_string pairs which are more intuitive than search/replace arrays. Only use github_push_files for creating new files or complete rewrites.',
    'best_practice',
    ARRAY['builder'],
    ARRAY['github'],
    'important',
    true
  );
END;
$$;


--
-- Name: intent_extractor(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.intent_extractor(p_llm_response text) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  v_tool_calls JSONB := '[]'::jsonb;
  v_action_name TEXT;
  v_params JSONB;
  v_validated_calls JSONB := '[]'::jsonb;
  v_action RECORD;
  v_call JSONB;
  v_errors JSONB := '[]'::jsonb;
  v_i INT;
BEGIN
  -- Extract tool_use blocks from response (Anthropic format)
  -- Looking for patterns like: {"type": "tool_use", "name": "...", "input": {...}}
  
  -- Try to parse as JSON first
  BEGIN
    IF p_llm_response ~ '^\s*\[' THEN
      v_tool_calls := p_llm_response::jsonb;
    ELSIF p_llm_response ~ '^\s*\{' THEN
      v_tool_calls := jsonb_build_array(p_llm_response::jsonb);
    ELSE
      -- Try to extract JSON from text
      IF p_llm_response ~ '\{[^{}]*"type"\s*:\s*"tool_use"[^{}]*\}' THEN
        -- Basic extraction - in production would use proper parser
        RETURN jsonb_build_object(
          'status', 'parse_error',
          'message', 'Complex tool use extraction not implemented - pass structured JSON',
          'raw_length', length(p_llm_response)
        );
      END IF;
      RETURN jsonb_build_object('status', 'no_tools', 'calls', '[]'::jsonb);
    END IF;
  EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'status', 'parse_error',
      'message', SQLERRM,
      'raw_length', length(p_llm_response)
    );
  END;

  -- Validate each tool call against allowed_actions
  FOR v_i IN 0..jsonb_array_length(v_tool_calls) - 1 LOOP
    v_call := v_tool_calls->v_i;
    v_action_name := COALESCE(v_call->>'name', v_call->>'action');
    v_params := COALESCE(v_call->'input', v_call->'params', '{}'::jsonb);
    
    IF v_action_name IS NULL THEN
      v_errors := v_errors || jsonb_build_object('index', v_i, 'error', 'missing action name');
      CONTINUE;
    END IF;
    
    SELECT * INTO v_action FROM allowed_actions WHERE action_name = v_action_name AND enabled = true;
    
    IF NOT FOUND THEN
      v_errors := v_errors || jsonb_build_object('index', v_i, 'action', v_action_name, 'error', 'action not allowed');
      CONTINUE;
    END IF;
    
    -- Check required params
    IF v_action.required_params IS NOT NULL AND jsonb_array_length(v_action.required_params) > 0 THEN
      FOR v_i IN 0..jsonb_array_length(v_action.required_params) - 1 LOOP
        IF NOT v_params ? (v_action.required_params->>v_i) THEN
          v_errors := v_errors || jsonb_build_object(
            'action', v_action_name, 
            'error', format('missing required param: %s', v_action.required_params->>v_i)
          );
        END IF;
      END LOOP;
    END IF;
    
    v_validated_calls := v_validated_calls || jsonb_build_object(
      'action', v_action_name,
      'params', v_params,
      'requires_work_order', v_action.requires_work_order,
      'rate_limit', v_action.rate_limit_per_minute
    );
  END LOOP;

  RETURN jsonb_build_object(
    'status', CASE WHEN jsonb_array_length(v_errors) > 0 THEN 'partial' ELSE 'valid' END,
    'calls', v_validated_calls,
    'errors', v_errors,
    'total_extracted', jsonb_array_length(v_tool_calls)
  );
END;
$$;


--
-- Name: intervene_pipeline(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.intervene_pipeline(p_pipeline_run_id uuid, p_action text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_pipeline_run RECORD;
    v_phase_order TEXT[] := ARRAY['spec', 'plan', 'scaffold', 'build', 'verify', 'harden', 'integrate'];
    v_current_phase_idx INT;
    v_child_wo RECORD;
    v_phase_child_wo RECORD;
    v_spec_wo RECORD;
    v_new_wo JSONB;
    v_action_result JSONB;
    v_cancelled_count INT := 0;
    v_restarted_count INT := 0;
BEGIN
    -- Validate action
    IF p_action NOT IN ('pause', 'resume', 'skip_phase', 'restart_phase') THEN
        RETURN jsonb_build_object('success', false, 'error', 'Invalid action. Valid actions: pause, resume, skip_phase, restart_phase');
    END IF;

    -- Get pipeline run
    SELECT * INTO v_pipeline_run FROM pipeline_runs WHERE id = p_pipeline_run_id;
    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Pipeline run not found', 'pipeline_run_id', p_pipeline_run_id);
    END IF;

    -- Get spec WO for context
    SELECT id, slug, name INTO v_spec_wo FROM work_orders WHERE id = v_pipeline_run.spec_wo_id;

    -- PAUSE: set status = paused, cancel all in_progress child WOs
    IF p_action = 'pause' THEN
        UPDATE pipeline_runs SET status = 'paused', updated_at = NOW() WHERE id = p_pipeline_run_id;
        
        -- Cancel all in_progress child WOs for this pipeline
        FOR v_child_wo IN 
            SELECT id, slug, name FROM work_orders 
            WHERE pipeline_run_id = p_pipeline_run_id AND status = 'in_progress'
        LOOP
            UPDATE work_orders SET status = 'cancelled', cancellation_reason = 'Pipeline paused' WHERE id = v_child_wo.id;
            v_cancelled_count := v_cancelled_count + 1;
        END LOOP;
        
        RETURN jsonb_build_object(
            'success', true,
            'action', 'pause',
            'new_status', 'paused',
            'message', 'Pipeline paused, ' || v_cancelled_count || ' child WOs cancelled'
        );
    END IF;

    -- RESUME: set status = active, restart the current_phase WO
    IF p_action = 'resume' THEN
        IF v_pipeline_run.status != 'paused' THEN
            RETURN jsonb_build_object('success', false, 'error', 'Pipeline is not paused, cannot resume', 'current_status', v_pipeline_run.status);
        END IF;

        UPDATE pipeline_runs SET status = 'active', updated_at = NOW() WHERE id = p_pipeline_run_id;

        -- Find the current phase WO that was in progress when paused
        SELECT id, slug, name INTO v_child_wo FROM work_orders 
        WHERE pipeline_run_id = p_pipeline_run_id 
          AND pipeline_phase = v_pipeline_run.current_phase
          AND status = 'cancelled'
        ORDER BY created_at DESC
        LIMIT 1;

        IF FOUND THEN
            -- Restart the cancelled WO - set to ready for pickup
            UPDATE work_orders SET status = 'ready', pipeline_run_id = p_pipeline_run_id WHERE id = v_child_wo.id;
            v_restarted_count := 1;
        END IF;

        RETURN jsonb_build_object(
            'success', true,
            'action', 'resume',
            'new_status', 'active',
            'message', 'Pipeline resumed, ' || v_restarted_count || ' WOs restarted'
        );
    END IF;

    -- SKIP_PHASE: advance current_phase to next via advance_pipeline_phase(), mark current phase WOs as cancelled
    IF p_action = 'skip_phase' THEN
        -- Cancel all current phase WOs
        FOR v_phase_child_wo IN 
            SELECT id, slug, name FROM work_orders 
            WHERE pipeline_run_id = p_pipeline_run_id 
              AND pipeline_phase = v_pipeline_run.current_phase
              AND status IN ('in_progress', 'ready', 'draft')
        LOOP
            UPDATE work_orders SET status = 'cancelled', cancellation_reason = 'Phase skipped' WHERE id = v_phase_child_wo.id;
            v_cancelled_count := v_cancelled_count + 1;
        END LOOP;

        -- Advance to next phase
        v_action_result := advance_pipeline_phase(p_pipeline_run_id, NULL);
        
        RETURN jsonb_build_object(
            'success', true,
            'action', 'skip_phase',
            'message', 'Phase ' || v_pipeline_run.current_phase || ' skipped, ' || v_cancelled_count || ' WOs cancelled',
            'advance_result', v_action_result
        );
    END IF;

    -- RESTART_PHASE: cancel current phase WOs, create fresh WOs for current phase
    IF p_action = 'restart_phase' THEN
        -- Cancel all current phase WOs
        FOR v_phase_child_wo IN 
            SELECT id, slug, name FROM work_orders 
            WHERE pipeline_run_id = p_pipeline_run_id 
              AND pipeline_phase = v_pipeline_run.current_phase
              AND status IN ('in_progress', 'ready', 'draft', 'cancelled')
        LOOP
            UPDATE work_orders SET status = 'cancelled', cancellation_reason = 'Phase restarted' WHERE id = v_phase_child_wo.id;
            v_cancelled_count := v_cancelled_count + 1;
        END LOOP;

        -- Create fresh WO for current phase
        v_new_wo := create_draft_work_order(
            NULL,
            'Pipeline ' || COALESCE(v_spec_wo.slug, '?') || ': ' || UPPER(v_pipeline_run.current_phase) || ' restart',
            'Re-execute ' || v_pipeline_run.current_phase || ' phase for pipeline',
            'p2_medium'::work_order_priority,
            'manifold',
            ARRAY['manifold-v1', 'pipeline-phase', v_pipeline_run.current_phase, 'restart'],
            NULL,
            v_pipeline_run.spec_wo_id
        );

        UPDATE work_orders SET 
            pipeline_phase = v_pipeline_run.current_phase, 
            pipeline_run_id = p_pipeline_run_id,
            status = 'ready'
        WHERE id = (v_new_wo->>'id')::uuid;

        v_restarted_count := 1;

        RETURN jsonb_build_object(
            'success', true,
            'action', 'restart_phase',
            'new_phase', v_pipeline_run.current_phase,
            'message', 'Phase ' || v_pipeline_run.current_phase || ' restarted, ' || v_cancelled_count || ' old WOs cancelled, 1 new WO created',
            'new_wo_id', v_new_wo->>'id'
        );
    END IF;

    RETURN jsonb_build_object('success', false, 'error', 'Unhandled action');
END;
$$;


--
-- Name: invoke_audit_enforcer(text, uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.invoke_audit_enforcer(p_trigger_event text DEFAULT 'scheduled'::text, p_trigger_wo_id uuid DEFAULT NULL::uuid, p_run_type text DEFAULT 'scheduled'::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_result jsonb;
BEGIN
  -- Note: This requires http extension and app settings to be configured
  -- For now, return a placeholder that indicates the function is set up
  -- The actual HTTP call needs to be configured with proper credentials
  
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, action, payload)
  VALUES (
    'enforcer_invocation_requested',
    'system',
    'invoke_audit_enforcer',
    'enforcer_runs',
    'invoke_requested',
    jsonb_build_object(
      'trigger_event', p_trigger_event,
      'trigger_wo_id', p_trigger_wo_id,
      'run_type', p_run_type,
      'timestamp', now()
    )
  );

  RETURN jsonb_build_object(
    'success', true,
    'message', 'Enforcer invocation logged',
    'trigger_event', p_trigger_event,
    'trigger_wo_id', p_trigger_wo_id
  );
EXCEPTION
  WHEN OTHERS THEN
    INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, action, payload)
    VALUES (
      'enforcer_invocation_failed',
      'system',
      'invoke_audit_enforcer',
      'enforcer_runs',
      'invoke_failed',
      jsonb_build_object(
        'error', SQLERRM,
        'trigger_event', p_trigger_event,
        'trigger_wo_id', p_trigger_wo_id
      )
    );
    RETURN jsonb_build_object('error', SQLERRM, 'success', false);
END;
$$;


--
-- Name: FUNCTION invoke_audit_enforcer(p_trigger_event text, p_trigger_wo_id uuid, p_run_type text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.invoke_audit_enforcer(p_trigger_event text, p_trigger_wo_id uuid, p_run_type text) IS 'Invokes the audit enforcer edge function with specified trigger event';


--
-- Name: invoke_lesson_promoter(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.invoke_lesson_promoter() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  request_id bigint;
  v_auth_key TEXT;
BEGIN
  -- Get anon key from system_settings
  SELECT (setting_value#>>'{}')::text INTO v_auth_key
  FROM system_settings
  WHERE setting_key = 'supabase_anon_key';
  
  IF v_auth_key IS NULL THEN
    RAISE WARNING 'Anon key not found in system_settings';
    RETURN;
  END IF;
  
  SELECT net.http_post(
    url := 'https://phfblljwuvzqzlbzkzpr.supabase.co/functions/v1/lesson-promoter/run',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || v_auth_key,
      'apikey', v_auth_key
    ),
    body := jsonb_build_object('trigger', 'cron')
  ) INTO request_id;
  
  RAISE NOTICE 'Lesson promoter invoked, request_id: %', request_id;
END;
$$;


--
-- Name: is_qa_checklist_complete(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_qa_checklist_complete(wo_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  checklist jsonb;
  item jsonb;
  has_pending boolean := false;
BEGIN
  -- Get the checklist for this work order
  SELECT qa_checklist INTO checklist
  FROM work_orders
  WHERE id = wo_id;
  
  -- If no checklist, return true (no QA required)
  IF checklist IS NULL OR jsonb_array_length(checklist) = 0 THEN
    RETURN true;
  END IF;
  
  -- Check each item
  FOR item IN SELECT * FROM jsonb_array_elements(checklist)
  LOOP
    -- If any item is still pending, checklist is incomplete
    IF item->>'status' = 'pending' THEN
      has_pending := true;
      EXIT;
    END IF;
  END LOOP;
  
  RETURN NOT has_pending;
END;
$$;


--
-- Name: FUNCTION is_qa_checklist_complete(wo_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.is_qa_checklist_complete(wo_id uuid) IS 'Returns true if all QA checklist items have been marked pass/fail/na (none pending)';


--
-- Name: jaccard_similarity(text[], text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.jaccard_similarity(text[], text[]) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE i INTEGER; u INTEGER;
BEGIN
  IF array_length($1,1) IS NULL OR array_length($2,1) IS NULL THEN RETURN 0; END IF;
  i := (SELECT count(*) FROM unnest($1) x WHERE x = ANY($2));
  u := array_length(array_cat($1,$2),1);
  IF u = 0 THEN RETURN 0; END IF;
  RETURN i::NUMERIC / u::NUMERIC;
END
$_$;


--
-- Name: load_agent_knowledge(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.load_agent_knowledge(p_role text DEFAULT 'executor'::text, p_tags text[] DEFAULT ARRAY['server-side-agent'::text, 'supabase'::text]) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_entries jsonb;
BEGIN
  -- Load all active knowledge base entries that match role and tags
  SELECT jsonb_agg(
    jsonb_build_object(
      'category', category,
      'topic', topic,
      'content', content,
      'severity', severity,
      'updated_at', updated_at
    )
    ORDER BY 
      CASE severity
        WHEN 'critical' THEN 1
        WHEN 'important' THEN 2
        WHEN 'reference' THEN 3
        ELSE 4
      END,
      category,
      topic
  ) INTO v_entries
  FROM agent_knowledge_base
  WHERE active = true
    AND p_role = ANY(applicable_roles)
    AND p_tags && applicable_tags  -- Array overlap operator
  ;
  
  RETURN COALESCE(v_entries, '[]'::jsonb);
END;
$$;


--
-- Name: FUNCTION load_agent_knowledge(p_role text, p_tags text[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.load_agent_knowledge(p_role text, p_tags text[]) IS 'Loads active knowledge base entries for a given role and tag set. Used by builder agent on execution start to load project context, lessons, and operational patterns.';


--
-- Name: log_auto_close_deferred(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_auto_close_deferred() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
  VALUES (NEW.id, 'qa_validation', 'qa-gate',
    jsonb_build_object(
      'event_type', 'auto_close_deferred',
      'content', format('Auto-close deferred for %s: qa_review_verified_at is NULL (lie detector not yet complete)', NEW.slug)
    )
  );
  RETURN NEW;
END;
$$;


--
-- Name: log_blocked_transition(uuid, text, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_blocked_transition(p_work_order_id uuid, p_from_status text, p_to_status text, p_reason text, p_calling_agent text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
  VALUES (
    'transition_blocked',
    CASE WHEN p_calling_agent IN ('work-order-executor', 'wo-agent') THEN 'agent' ELSE 'system' END,
    p_calling_agent,
    'work_order',
    p_work_order_id,
    'Blocked unauthorized state transition',
    jsonb_build_object(
      'attempted_transition', format('%s → %s', p_from_status, p_to_status),
      'reason', p_reason,
      'calling_agent', p_calling_agent,
      'timestamp', NOW()
    )
  );
END;
$$;


--
-- Name: FUNCTION log_blocked_transition(p_work_order_id uuid, p_from_status text, p_to_status text, p_reason text, p_calling_agent text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.log_blocked_transition(p_work_order_id uuid, p_from_status text, p_to_status text, p_reason text, p_calling_agent text) IS 'Logs blocked transition attempts to audit_log for AC#5 compliance';


--
-- Name: log_bypass_attempt(text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_bypass_attempt(p_event_type text, p_severity text DEFAULT 'info'::text, p_details jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_id UUID;
BEGIN
  INSERT INTO bypass_log (event_type, severity, request_body)
  VALUES (p_event_type, p_severity, p_details)
  RETURNING id INTO v_id;
  
  -- Alert on critical bypasses
  IF p_severity = 'critical' THEN
    -- Could integrate with alerting system here
    RAISE NOTICE 'CRITICAL BYPASS DETECTED: % - %', p_event_type, p_details;
  END IF;
  
  RETURN v_id;
END;
$$;


--
-- Name: log_cli_action(uuid, text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_cli_action(p_work_order_id uuid, p_agent_name text, p_phase text, p_detail jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_id uuid;
BEGIN
  INSERT INTO work_order_execution_log (
    work_order_id,
    phase,
    agent_name,
    detail,
    created_at
  ) VALUES (
    p_work_order_id,
    p_phase,
    p_agent_name,
    p_detail,
    NOW()
  )
  RETURNING id INTO v_id;
  
  RETURN v_id;
END;
$$;


--
-- Name: log_complexity_routing(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_complexity_routing() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_state_mutation JSONB;
  v_complexity_result JSONB;
BEGIN
  -- Find the state_mutation for this WO's routing
  SELECT payload INTO v_state_mutation
  FROM state_mutations
  WHERE target_table = 'work_orders'
    AND target_id = NEW.id
    AND mutation_type = 'INSERT'
    AND payload->>'action' = 'auto_route_on_insert'
  ORDER BY created_at DESC
  LIMIT 1;

  -- If complexity scoring was used, log it to execution_log
  IF v_state_mutation IS NOT NULL AND v_state_mutation ? 'complexity_scoring' THEN
    v_complexity_result := v_state_mutation->'complexity_scoring';
    
    IF v_complexity_result IS NOT NULL THEN
      INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail, iteration)
      VALUES (
        NEW.id,
        'schema_validation',
        'auto_route_portal_insert',
        jsonb_build_object(
          'event', 'complexity_scoring',
          'complexity_result', v_complexity_result,
          'recommended_agent', v_complexity_result->>'recommended_agent',
          'routing_reason', v_state_mutation->>'routing_reason'
        ),
        0
      );
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: log_error_event(text, text, text, text, jsonb, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_error_event(p_severity text, p_source_function text, p_error_code text, p_message text, p_context jsonb DEFAULT '{}'::jsonb, p_work_order_id uuid DEFAULT NULL::uuid, p_agent_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_error_id UUID;
BEGIN
  INSERT INTO error_events (
    severity,
    source_function,
    error_code,
    message,
    context,
    work_order_id,
    agent_id
  ) VALUES (
    p_severity,
    p_source_function,
    p_error_code,
    p_message,
    p_context,
    p_work_order_id,
    p_agent_id
  )
  RETURNING id INTO v_error_id;
  
  RETURN v_error_id;
END;
$$;


--
-- Name: FUNCTION log_error_event(p_severity text, p_source_function text, p_error_code text, p_message text, p_context jsonb, p_work_order_id uuid, p_agent_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.log_error_event(p_severity text, p_source_function text, p_error_code text, p_message text, p_context jsonb, p_work_order_id uuid, p_agent_id uuid) IS 'Helper function to log error events from edge functions and RPC calls';


--
-- Name: log_harness_error_as_lesson(text, text, text, uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_harness_error_as_lesson(p_error_message text, p_context text DEFAULT NULL::text, p_category text DEFAULT 'general'::text, p_work_order_id uuid DEFAULT NULL::uuid, p_trace_id text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_lesson_id UUID;
  v_pattern TEXT;
  v_rule TEXT;
  v_severity TEXT;
BEGIN
  v_pattern := 'Harness error: ' || p_error_message;
  
  -- Smarter rule + severity derivation
  v_severity := CASE 
    WHEN p_error_message ILIKE '%security%' OR p_error_message ILIKE '%unauthorized%' THEN 'critical'
    WHEN p_error_message ILIKE '%data loss%' OR p_error_message ILIKE '%corrupt%' THEN 'critical'
    WHEN p_error_message ILIKE '%transition%rejected%' OR p_error_message ILIKE '%invalid transition%' THEN 'error'
    WHEN p_error_message ILIKE '%action%denied%' OR p_error_message ILIKE '%not allowed%' THEN 'error'
    WHEN p_error_message ILIKE '%gate%' OR p_error_message ILIKE '%approval%' THEN 'warning'
    ELSE 'warning'
  END;

  v_rule := CASE 
    WHEN p_error_message ILIKE '%work order required%' THEN 
      'Always provide work_order_id when mutating protected tables'
    WHEN p_error_message ILIKE '%requires id%' THEN
      'Always include id in payload for UPDATE and DELETE operations'
    WHEN p_error_message ILIKE '%not approved%' THEN
      'Ensure work order is approved before attempting execution'
    WHEN p_error_message ILIKE '%transition%rejected%' OR p_error_message ILIKE '%invalid transition%' THEN
      'Verify work order status allows the intended transition before attempting it. Check validate_wo_transition rules.'
    WHEN p_error_message ILIKE '%action%denied%' OR p_error_message ILIKE '%not allowed%' THEN
      'Verify agent is authorized for the action via check_allowed_action before attempting it.'
    WHEN p_error_message ILIKE '%gate%' OR p_error_message ILIKE '%approval required%' THEN
      'Check decision gates before executing. High-priority or high-cost work orders require approval.'
    WHEN p_error_message ILIKE '%intake%' OR p_error_message ILIKE '%incomplete%' THEN
      'Ensure project intake is complete before creating work orders. Run interrogation first.'
    ELSE
      'Review error context and harness constraints: ' || LEFT(p_error_message, 200)
  END;
  
  INSERT INTO lessons (
    pattern, context, rule, severity, category,
    work_order_id, trace_id, reported_by
  ) VALUES (
    v_pattern, p_context, v_rule, v_severity, p_category,
    p_work_order_id, p_trace_id, 'harness'
  ) RETURNING id INTO v_lesson_id;
  
  RETURN v_lesson_id;
EXCEPTION WHEN OTHERS THEN
  RAISE WARNING 'Failed to log lesson: %', SQLERRM;
  RETURN NULL;
END;
$$;


--
-- Name: log_harness_error_as_lesson(text, text, uuid, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_harness_error_as_lesson(p_error_message text, p_context text, p_work_order_id uuid DEFAULT NULL::uuid, p_trace_id text DEFAULT NULL::text, p_category text DEFAULT 'other'::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_lesson_id UUID;
  v_pattern TEXT;
  v_rule TEXT;
BEGIN
  -- Extract pattern from error
  v_pattern := 'Harness error: ' || p_error_message;
  
  -- Generate a rule suggestion
  v_rule := CASE 
    WHEN p_error_message ILIKE '%work order required%' THEN 
      'Always provide work_order_id when mutating protected tables (system_manifest, work_orders, decisions, schema_changes)'
    WHEN p_error_message ILIKE '%requires id%' THEN
      'Always include id in payload for UPDATE and DELETE operations'
    WHEN p_error_message ILIKE '%not approved%' THEN
      'Ensure work order is approved before attempting execution'
    ELSE
      'Review harness constraints before mutation: ' || p_error_message
  END;
  
  -- Insert lesson
  INSERT INTO lessons (
    pattern,
    context,
    rule,
    severity,
    category,
    work_order_id,
    trace_id,
    reported_by
  ) VALUES (
    v_pattern,
    p_context,
    v_rule,
    'warning',
    p_category,
    p_work_order_id,
    p_trace_id,
    'harness'
  ) RETURNING id INTO v_lesson_id;
  
  RETURN v_lesson_id;
EXCEPTION WHEN OTHERS THEN
  -- Don't fail if lesson logging fails
  RAISE WARNING 'Failed to log lesson: %', SQLERRM;
  RETURN NULL;
END;
$$;


--
-- Name: lookup_success_rate(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.lookup_success_rate(p_target_identifier text, p_tool_name text, p_action text) RETURNS TABLE(success_rate numeric, wilson_lower numeric, wilson_upper numeric, sample_size integer, tier text)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    -- Tier 1: Specific object match
    RETURN QUERY
    SELECT oar.success_rate, oar.wilson_lower, oar.wilson_upper, 
           oar.total_attempts::int, 'specific'::text
    FROM object_action_rates oar
    WHERE oar.target_identifier = p_target_identifier
      AND oar.tool_name = p_tool_name
      AND oar.action = p_action
    LIMIT 1;
    
    IF FOUND THEN RETURN; END IF;
    
    -- Tier 2: Tool + action type match (aggregated)
    RETURN QUERY
    SELECT atr.success_rate, atr.wilson_lower, atr.wilson_upper,
           atr.total_attempts::int, 'type'::text
    FROM action_type_rates atr
    WHERE atr.tool_name = p_tool_name
      AND atr.action = p_action
    LIMIT 1;
    
    IF FOUND THEN RETURN; END IF;
    
    -- Tier 3: Action-only fallback
    RETURN QUERY
    SELECT atr.success_rate, atr.wilson_lower, atr.wilson_upper,
           atr.total_attempts::int, 'global'::text
    FROM action_type_rates atr
    WHERE atr.action = p_action
    ORDER BY atr.total_attempts DESC
    LIMIT 1;
    
    IF FOUND THEN RETURN; END IF;
    
    -- No data: return uninformative prior (0.5 with wide CI)
    RETURN QUERY SELECT 0.5::numeric, 0.0::numeric, 1.0::numeric, 0::int, 'prior'::text;
END;
$$;


--
-- Name: manifest_guard(text, text, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.manifest_guard(p_name text, p_component_type text, p_work_order_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_existing RECORD;
  v_similar JSONB := '[]'::jsonb;
  v_similarity FLOAT;
BEGIN
  -- Check exact duplicate
  SELECT * INTO v_existing FROM system_manifest 
  WHERE name = p_name AND component_type = p_component_type;
  
  IF FOUND THEN
    RETURN jsonb_build_object(
      'allowed', false,
      'reason', 'exact_duplicate',
      'existing_id', v_existing.id,
      'existing_version', v_existing.version
    );
  END IF;
  
  -- Check similar names (fuzzy match)
  FOR v_existing IN 
    SELECT id, name, component_type, 
           similarity(name, p_name) as sim
    FROM system_manifest 
    WHERE component_type = p_component_type
    AND similarity(name, p_name) > 0.4
    ORDER BY sim DESC
    LIMIT 5
  LOOP
    v_similar := v_similar || jsonb_build_object(
      'id', v_existing.id,
      'name', v_existing.name,
      'similarity', round(v_existing.sim::numeric, 2)
    );
  END LOOP;
  
  -- Return result
  IF jsonb_array_length(v_similar) > 0 THEN
    RETURN jsonb_build_object(
      'allowed', true,
      'warning', 'similar_components_exist',
      'similar', v_similar,
      'recommendation', 'Review similar components before creating'
    );
  END IF;
  
  RETURN jsonb_build_object(
    'allowed', true,
    'message', 'No duplicates or similar components found'
  );
END;
$$;


--
-- Name: map_object_action_to_tool(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.map_object_action_to_tool(p_object_type text, p_action text) RETURNS TABLE(tool_name text, tool_action text)
    LANGUAGE sql IMMUTABLE
    AS $$
    SELECT 
        CASE 
            WHEN p_action IN ('ALTER', 'DROP', 'CREATE') THEN 'apply_migration'
            WHEN p_action = 'EXECUTE' THEN 'execute_sql'
            ELSE 'execute_sql'
        END as tool_name,
        CASE 
            WHEN p_action IN ('ALTER', 'DROP', 'CREATE') THEN 'DDL'
            ELSE p_action
        END as tool_action;
$$;


--
-- Name: match_lessons_to_failure(text, text, text[], integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.match_lessons_to_failure(p_failure_category text, p_error_message text DEFAULT NULL::text, p_wo_tags text[] DEFAULT NULL::text[], p_limit integer DEFAULT 5) RETURNS TABLE(id uuid, pattern text, rule text, context text, category text, severity text, occurred_at timestamp with time zone, match_score numeric)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    l.id,
    l.pattern,
    l.rule,
    l.context,
    l.category,
    l.severity,
    l.occurred_at,
    (
      CASE WHEN l.category = p_failure_category THEN 10 ELSE 0 END +
      CASE WHEN p_error_message IS NOT NULL AND (l.pattern ILIKE '%' || p_error_message || '%' OR l.rule ILIKE '%' || p_error_message || '%') THEN 5 ELSE 0 END +
      CASE WHEN p_wo_tags IS NOT NULL AND l.tags && p_wo_tags THEN 3 ELSE 0 END +
      CASE WHEN l.severity = 'critical' THEN 4 WHEN l.severity = 'high' THEN 3 WHEN l.severity = 'medium' THEN 2 ELSE 1 END
    )::numeric AS match_score
  FROM lessons l
  WHERE 
    l.review_status = 'promoted'
    AND (
      l.category = p_failure_category
      OR (p_error_message IS NOT NULL AND (l.pattern ILIKE '%' || p_error_message || '%' OR l.rule ILIKE '%' || p_error_message || '%'))
      OR (p_wo_tags IS NOT NULL AND l.tags && p_wo_tags)
    )
  ORDER BY match_score DESC, l.occurred_at DESC
  LIMIT p_limit;
END;
$$;


--
-- Name: mcts_plan_actions(uuid[], text, integer, integer, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.mcts_plan_actions(p_target_objects uuid[], p_goal text, p_num_simulations integer DEFAULT 1000, p_max_plans integer DEFAULT 5, p_action_filter text[] DEFAULT NULL::text[]) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    v_visited UUID[] := '{}'::UUID[];
    v_queue UUID[] := p_target_objects;
    v_current UUID;
    v_obj RECORD;
    v_dependent UUID[];
    
    v_all_objects JSONB := '[]'::jsonb;
    v_action_steps JSONB := '[]'::jsonb;
    v_step JSONB;
    v_obj_json JSONB;
    v_action TEXT;
    v_valid_actions TEXT[];
    v_rate_rec RECORD;
    v_tool_map RECORD;
    
    v_candidate_plans JSONB := '[]'::jsonb;
    v_plan JSONB;
    v_plan_actions JSONB;
    v_num_steps INT;
    v_perm INT[];
    v_step_indices INT[];
    
    v_sim INT;
    v_step_idx INT;
    v_path_success INT;
    v_total_sims INT;
    v_p_hat NUMERIC;
    v_step_p NUMERIC;
    v_plan_successes INT;
    
    v_wilson_lower NUMERIC;
    v_wilson_upper NUMERIC;
    v_z_score NUMERIC;
    v_p_value NUMERIC;
    v_best_rate NUMERIC;
    v_second_rate NUMERIC;
    v_best_n INT;
    v_second_n INT;
    v_se NUMERIC;
    
    v_results JSONB := '[]'::jsonb;
    v_sorted_results JSONB;
    v_best JSONB;
    v_second JSONB;
    
    v_plan_count INT := 0;
    v_i INT;
    v_j INT;
    v_temp INT;
BEGIN
    -- PHASE 1: BFS
    WHILE array_length(v_queue, 1) > 0 LOOP
        v_current := v_queue[1]; v_queue := v_queue[2:];
        IF v_current = ANY(v_visited) THEN CONTINUE; END IF;
        v_visited := array_append(v_visited, v_current);
        
        SELECT id, object_type, object_name, valid_actions INTO v_obj
        FROM object_registry WHERE id = v_current;
        
        IF v_obj.id IS NOT NULL THEN
            v_all_objects := v_all_objects || jsonb_build_array(jsonb_build_object(
                'id', v_obj.id, 'object_type', v_obj.object_type,
                'object_name', v_obj.object_name,
                'valid_actions', COALESCE(v_obj.valid_actions, ARRAY[]::TEXT[]),
                'is_target', v_current = ANY(p_target_objects)
            ));
            SELECT array_agg(DISTINCT ol.target_id) INTO v_dependent
            FROM object_links ol WHERE ol.source_id = v_current AND ol.target_id != ALL(v_visited);
            IF v_dependent IS NOT NULL THEN v_queue := array_cat(v_queue, v_dependent); END IF;
        END IF;
    END LOOP;
    
    IF jsonb_array_length(v_all_objects) = 0 THEN
        RETURN jsonb_build_object('error', 'No objects found', 'target_objects', p_target_objects);
    END IF;
    
    -- PHASE 2: Build action steps with CORRECT tool/action mapping
    FOR v_obj_json IN SELECT * FROM jsonb_array_elements(v_all_objects) LOOP
        IF (v_obj_json->>'is_target')::boolean THEN
            SELECT ARRAY(SELECT jsonb_array_elements_text(v_obj_json->'valid_actions')) INTO v_valid_actions;
            IF p_action_filter IS NOT NULL THEN
                v_valid_actions := ARRAY(SELECT unnest(v_valid_actions) INTERSECT SELECT unnest(p_action_filter));
            END IF;
            
            FOREACH v_action IN ARRAY v_valid_actions LOOP
                -- Map object action to correct tool_name + tool_action
                SELECT * INTO v_tool_map FROM map_object_action_to_tool(v_obj_json->>'object_type', v_action);
                
                SELECT * INTO v_rate_rec FROM lookup_success_rate(
                    v_obj_json->>'object_name',
                    v_tool_map.tool_name,
                    v_tool_map.tool_action
                );
                
                v_action_steps := v_action_steps || jsonb_build_array(jsonb_build_object(
                    'object_id', v_obj_json->>'id',
                    'object_name', v_obj_json->>'object_name',
                    'object_type', v_obj_json->>'object_type',
                    'action', v_action,
                    'mapped_tool', v_tool_map.tool_name,
                    'mapped_action', v_tool_map.tool_action,
                    'success_rate', v_rate_rec.success_rate,
                    'wilson_lower', v_rate_rec.wilson_lower,
                    'wilson_upper', v_rate_rec.wilson_upper,
                    'sample_size', v_rate_rec.sample_size,
                    'rate_tier', v_rate_rec.tier
                ));
            END LOOP;
        END IF;
    END LOOP;
    
    v_num_steps := jsonb_array_length(v_action_steps);
    IF v_num_steps = 0 THEN
        RETURN jsonb_build_object('error', 'No valid actions after filtering',
            'objects_found', jsonb_array_length(v_all_objects), 'action_filter', p_action_filter);
    END IF;
    
    -- PHASE 3: Generate candidate sequences
    v_step_indices := ARRAY(SELECT generate_series(0, v_num_steps - 1));
    
    -- Natural order
    v_plan_actions := '[]'::jsonb;
    FOR v_i IN 0..v_num_steps-1 LOOP v_plan_actions := v_plan_actions || jsonb_build_array(v_action_steps->v_i); END LOOP;
    v_candidate_plans := v_candidate_plans || jsonb_build_array(jsonb_build_object('plan_id', gen_random_uuid(), 'ordering', 'natural', 'actions', v_plan_actions));
    v_plan_count := 1;
    
    IF v_num_steps > 1 THEN
        -- Confidence-first
        v_plan_actions := '[]'::jsonb;
        FOR v_step IN SELECT * FROM jsonb_array_elements(v_action_steps) e ORDER BY (e->>'wilson_lower')::numeric DESC LOOP
            v_plan_actions := v_plan_actions || jsonb_build_array(v_step);
        END LOOP;
        v_candidate_plans := v_candidate_plans || jsonb_build_array(jsonb_build_object('plan_id', gen_random_uuid(), 'ordering', 'confidence_first', 'actions', v_plan_actions));
        
        -- Greedy rate
        v_plan_actions := '[]'::jsonb;
        FOR v_step IN SELECT * FROM jsonb_array_elements(v_action_steps) e ORDER BY (e->>'success_rate')::numeric DESC LOOP
            v_plan_actions := v_plan_actions || jsonb_build_array(v_step);
        END LOOP;
        v_candidate_plans := v_candidate_plans || jsonb_build_array(jsonb_build_object('plan_id', gen_random_uuid(), 'ordering', 'greedy_rate', 'actions', v_plan_actions));
        
        -- Worst-first
        v_plan_actions := '[]'::jsonb;
        FOR v_step IN SELECT * FROM jsonb_array_elements(v_action_steps) e ORDER BY (e->>'wilson_lower')::numeric ASC LOOP
            v_plan_actions := v_plan_actions || jsonb_build_array(v_step);
        END LOOP;
        v_candidate_plans := v_candidate_plans || jsonb_build_array(jsonb_build_object('plan_id', gen_random_uuid(), 'ordering', 'worst_first', 'actions', v_plan_actions));
        v_plan_count := 4;
        
        -- Random permutations
        WHILE v_plan_count < LEAST(p_max_plans * 3, 15) LOOP
            v_perm := v_step_indices;
            FOR v_i IN REVERSE v_num_steps-1..1 LOOP
                v_j := floor(random() * (v_i + 1))::int;
                v_temp := v_perm[v_i + 1]; v_perm[v_i + 1] := v_perm[v_j + 1]; v_perm[v_j + 1] := v_temp;
            END LOOP;
            v_plan_actions := '[]'::jsonb;
            FOREACH v_i IN ARRAY v_perm LOOP v_plan_actions := v_plan_actions || jsonb_build_array(v_action_steps->v_i); END LOOP;
            v_candidate_plans := v_candidate_plans || jsonb_build_array(jsonb_build_object('plan_id', gen_random_uuid(), 'ordering', 'random_' || v_plan_count, 'actions', v_plan_actions));
            v_plan_count := v_plan_count + 1;
        END LOOP;
    END IF;
    
    -- PHASE 4: Monte Carlo simulation
    FOR v_plan IN SELECT * FROM jsonb_array_elements(v_candidate_plans) LOOP
        v_plan_successes := 0;
        v_total_sims := p_num_simulations;
        v_plan_actions := v_plan->'actions';
        v_num_steps := jsonb_array_length(v_plan_actions);
        
        FOR v_sim IN 1..v_total_sims LOOP
            v_path_success := 1;
            FOR v_step_idx IN 0..v_num_steps-1 LOOP
                v_step := v_plan_actions->v_step_idx;
                -- Use wilson_lower as conservative probability, floor at 1%
                v_step_p := GREATEST((v_step->>'wilson_lower')::numeric, 0.01);
                IF random() >= v_step_p THEN v_path_success := 0; EXIT; END IF;
            END LOOP;
            v_plan_successes := v_plan_successes + v_path_success;
        END LOOP;
        
        v_p_hat := v_plan_successes::numeric / v_total_sims;
        v_wilson_lower := CASE WHEN v_total_sims > 0 THEN
            GREATEST((v_p_hat + 1.9208/(2*v_total_sims) - 1.96*sqrt((v_p_hat*(1-v_p_hat) + 0.9604/v_total_sims)/v_total_sims)) / (1 + 3.8416/v_total_sims), 0)
        ELSE 0 END;
        v_wilson_upper := CASE WHEN v_total_sims > 0 THEN
            LEAST((v_p_hat + 1.9208/(2*v_total_sims) + 1.96*sqrt((v_p_hat*(1-v_p_hat) + 0.9604/v_total_sims)/v_total_sims)) / (1 + 3.8416/v_total_sims), 1)
        ELSE 1 END;
        
        v_results := v_results || jsonb_build_array(jsonb_build_object(
            'plan_id', v_plan->>'plan_id', 'ordering', v_plan->>'ordering',
            'actions', v_plan_actions, 'num_steps', jsonb_array_length(v_plan_actions),
            'simulations', v_total_sims, 'successes', v_plan_successes,
            'mean_success_rate', round(v_p_hat, 4),
            'wilson_ci', jsonb_build_object('lower', round(v_wilson_lower, 4), 'upper', round(v_wilson_upper, 4),
                'width', round(v_wilson_upper - v_wilson_lower, 4), 'confidence', 0.95),
            'dependency_graph', jsonb_build_object('total_objects', jsonb_array_length(v_all_objects),
                'target_objects', array_length(p_target_objects, 1), 'reachable_objects', array_length(v_visited, 1))
        ));
    END LOOP;
    
    -- PHASE 5: Rank + significance test
    SELECT jsonb_agg(elem ORDER BY (elem->'wilson_ci'->>'lower')::numeric DESC) INTO v_sorted_results
    FROM jsonb_array_elements(v_results) elem;
    
    v_results := '[]'::jsonb;
    FOR v_i IN 0..LEAST(p_max_plans - 1, jsonb_array_length(v_sorted_results) - 1) LOOP
        v_results := v_results || jsonb_build_array(v_sorted_results->v_i || jsonb_build_object('rank', v_i + 1));
    END LOOP;
    
    IF jsonb_array_length(v_results) >= 2 THEN
        v_best := v_results->0; v_second := v_results->1;
        v_best_rate := (v_best->>'mean_success_rate')::numeric;
        v_second_rate := (v_second->>'mean_success_rate')::numeric;
        v_best_n := (v_best->>'simulations')::int;
        v_second_n := (v_second->>'simulations')::int;
        v_se := sqrt(v_best_rate*(1-v_best_rate)/v_best_n + v_second_rate*(1-v_second_rate)/v_second_n);
        IF v_se > 0 THEN
            v_z_score := (v_best_rate - v_second_rate) / v_se;
            v_p_value := GREATEST(2*(1 - (1/(1 + exp(-1.7155*v_z_score*(1+0.0348*v_z_score*v_z_score))))), 0.0001);
        ELSE v_z_score := 0; v_p_value := 1; END IF;
    ELSE v_z_score := NULL; v_p_value := NULL; END IF;
    
    RETURN jsonb_build_object(
        'plans', v_results,
        'metadata', jsonb_build_object(
            'total_candidates_evaluated', jsonb_array_length(v_sorted_results),
            'simulations_per_plan', p_num_simulations, 'plans_returned', jsonb_array_length(v_results),
            'goal', p_goal, 'target_objects', array_length(p_target_objects, 1),
            'dependency_graph_size', array_length(v_visited, 1), 'action_filter', p_action_filter),
        'significance_test', CASE WHEN v_z_score IS NOT NULL THEN jsonb_build_object(
            'test', 'two_proportion_z_test', 'comparing', 'rank_1 vs rank_2',
            'z_score', round(v_z_score, 4), 'p_value', round(v_p_value, 4),
            'significant_at_005', v_p_value < 0.05, 'significant_at_001', v_p_value < 0.01,
            'interpretation', CASE 
                WHEN v_p_value < 0.01 THEN 'Strong evidence top plan is better'
                WHEN v_p_value < 0.05 THEN 'Moderate evidence top plan is better'
                WHEN v_p_value < 0.10 THEN 'Weak evidence, plans may be equivalent'
                ELSE 'No significant difference between top plans'
            END)
        ELSE jsonb_build_object('test', 'not_applicable', 'reason', 'fewer than 2 plans') END
    );
END;
$$;


--
-- Name: notify_notion_sync(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_notion_sync() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  payload JSONB;
  edge_function_url TEXT;
  service_role_key TEXT;
BEGIN
  -- Get the edge function URL
  edge_function_url := 'https://phfblljwuvzqzlbzkzpr.supabase.co/functions/v1/notion-sync';
  
  -- Get service role key from secrets
  SELECT value INTO service_role_key FROM secrets WHERE key = 'SUPABASE_SERVICE_ROLE_KEY';
  
  -- Build payload
  payload := jsonb_build_object(
    'table', TG_TABLE_NAME,
    'type', TG_OP,
    'record', CASE 
      WHEN TG_OP = 'DELETE' THEN row_to_json(OLD)::jsonb
      ELSE row_to_json(NEW)::jsonb
    END
  );
  
  -- Call edge function asynchronously via pg_net
  PERFORM net.http_post(
    url := edge_function_url,
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || COALESCE(service_role_key, ''),
      'apikey', COALESCE(service_role_key, '')
    ),
    body := payload
  );
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


--
-- Name: notify_object_registry_change(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_object_registry_change() RETURNS event_trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- This will be called by table triggers to signal DDL changes
    PERFORM sync_object_registry_on_ddl();
END;
$$;


--
-- Name: notify_parent_on_child_completion(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_parent_on_child_completion() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_parent_id UUID;
  v_active_children INT;
  v_parent_status TEXT;
  v_anon_key TEXT;
  v_base_url TEXT;
BEGIN
  -- Only fire when child transitions TO a terminal state
  IF NEW.status NOT IN ('done', 'failed', 'cancelled') THEN
    RETURN NEW;
  END IF;
  IF OLD.status = NEW.status THEN
    RETURN NEW;
  END IF;

  -- Check if this WO has a parent
  v_parent_id := NEW.parent_id;
  IF v_parent_id IS NULL THEN
    RETURN NEW;
  END IF;

  -- Check parent status (only resume in_progress parents)
  SELECT status INTO v_parent_status
  FROM work_orders WHERE id = v_parent_id;

  IF v_parent_status != 'in_progress' THEN
    RETURN NEW;
  END IF;

  -- Count remaining active children
  SELECT count(*) INTO v_active_children
  FROM work_orders
  WHERE parent_id = v_parent_id
    AND id != NEW.id
    AND status IN ('in_progress', 'review', 'ready', 'draft');

  -- If no more active children, re-dispatch parent
  IF v_active_children = 0 THEN
    -- Get anon key for auth
    SELECT setting_value INTO v_anon_key
    FROM system_settings
    WHERE setting_key = 'supabase_anon_key';

    v_base_url := current_setting('app.settings.supabase_url', true);
    IF v_base_url IS NULL THEN
      v_base_url := 'https://phfblljwuvzqzlbzkzpr.supabase.co';
    END IF;

    -- Fire-and-forget POST to re-execute parent
    PERFORM net.http_post(
      url := v_base_url || '/functions/v1/wo-agent/execute',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || COALESCE(v_anon_key, ''),
        'apikey', COALESCE(v_anon_key, '')
      ),
      body := jsonb_build_object('work_order_id', v_parent_id::text)
    );

    -- Remove waiting-on-children tag if present
    UPDATE work_orders
    SET tags = array_remove(COALESCE(tags, ARRAY[]::TEXT[]), 'waiting-on-children')
    WHERE id = v_parent_id
      AND 'waiting-on-children' = ANY(COALESCE(tags, ARRAY[]::TEXT[]));
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: notify_work_order_webhook(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_work_order_webhook() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    payload JSONB;
BEGIN
    -- Build payload
    payload := jsonb_build_object(
        'type', TG_OP,
        'table', TG_TABLE_NAME,
        'record', to_jsonb(NEW),
        'old_record', CASE WHEN TG_OP = 'UPDATE' THEN to_jsonb(OLD) ELSE NULL END
    );
    
    -- Call webhook asynchronously via pg_net (if available) or log for polling
    INSERT INTO webhook_logs (event, payload, source)
    VALUES (
        CASE 
            WHEN TG_OP = 'INSERT' THEN 'work_order.created'
            WHEN NEW.status = 'done' THEN 'work_order.completed'
            ELSE 'work_order.updated'
        END,
        payload,
        'db_trigger'
    );
    
    RETURN NEW;
END;
$$;


--
-- Name: ops_heartbeat(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.ops_heartbeat() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  UPDATE system_settings SET setting_value = to_jsonb(now()::text)
  WHERE setting_key = 'ops_last_heartbeat';
END;
$$;


--
-- Name: parse_criteria_to_checklist(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.parse_criteria_to_checklist(p_criteria text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_checklist JSONB := '[]'::jsonb;
  v_line TEXT;
  v_idx INT := 0;
  v_clean TEXT;
BEGIN
  FOR v_line IN SELECT unnest(string_to_array(p_criteria, E'\n'))
  LOOP
    v_clean := trim(v_line);
    -- Match numbered (1. or 1)), bulleted (- or *), or AC-prefixed (AC1: or AC1.)
    IF v_clean ~ '^\d+[\.\)]\s' OR v_clean ~ '^[-*]\s' OR v_clean ~ '^AC\d+[\:\.\)]\s' THEN
      v_idx := v_idx + 1;
      v_checklist := v_checklist || jsonb_build_object(
        'id', 'ac-' || v_idx,
        'criterion', v_clean,
        'status', 'pending',
        'finding_id', null
      );
    END IF;
  END LOOP;
  RETURN v_checklist;
END;
$$;


--
-- Name: populate_function_signatures(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.populate_function_signatures() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_count INTEGER := 0;
    v_function RECORD;
    v_input_params JSONB;
    v_return_info JSONB;
    v_volatility TEXT;
    v_security_definer BOOLEAN;
    v_arg_names TEXT[];
    v_is_table_function BOOLEAN;
    v_return_type TEXT;
    v_col RECORD;
    v_return_columns JSONB := '[]'::jsonb;
    v_arg_oid OID;
    v_arg_oids OID[];
    v_arg_type TEXT;
    v_arg_name TEXT;
    v_has_default BOOLEAN;
BEGIN
    -- Process each function in object_registry
    FOR v_function IN 
        SELECT id, object_name 
        FROM object_registry 
        WHERE object_type = 'function'
    LOOP
        BEGIN
            -- Get function metadata from pg_proc using correct column names
            SELECT 
                p.provolatile,
                p.prokind = 'w',  -- window function check
                p.proretset,
                p.prorettype::regtype::text,
                p.proargnames,
                p.proargtypes
            INTO v_volatility, v_security_definer, v_is_table_function, v_return_type, v_arg_names, v_arg_oids
            FROM pg_proc p
            JOIN pg_namespace n ON n.oid = p.pronamespace
            WHERE p.proname = v_function.object_name
            AND n.nspname = 'public'
            LIMIT 1;
            
            IF NOT FOUND THEN
                CONTINUE;
            END IF;
            
            -- Process input parameters from proargtypes OID array
            v_input_params := '[]'::jsonb;
            
            IF v_arg_oids IS NOT NULL AND array_length(v_arg_oids, 1) > 0 THEN
                FOR i IN 1..array_length(v_arg_oids, 1) LOOP
                    v_arg_oid := v_arg_oids[i];
                    v_arg_type := NULL;
                    v_arg_name := NULL;
                    v_has_default := FALSE;
                    
                    -- Get type name from OID
                    SELECT format_type(v_arg_oid, NULL) INTO v_arg_type;
                    
                    -- Get arg name if available from proargnames array
                    IF v_arg_names IS NOT NULL AND array_length(v_arg_names, 1) >= i THEN
                        v_arg_name := v_arg_names[i];
                    END IF;
                    
                    v_input_params := v_input_params || jsonb_build_array(
                        jsonb_build_object(
                            'name', COALESCE(v_arg_name, 'arg' || i),
                            'type', COALESCE(v_arg_type, 'unknown'),
                            'has_default', v_has_default
                        )
                    );
                END LOOP;
            ELSE
                v_input_params := '[]'::jsonb;
            END IF;
            
            -- Process return type
            v_return_columns := '[]'::jsonb;
            
            -- For table functions (returns set of record), get column info from information_schema
            IF v_is_table_function = true AND v_return_type = 'record' THEN
                BEGIN
                    FOR v_col IN 
                        SELECT column_name, data_type
                        FROM information_schema.routine_columns
                        WHERE routine_name = v_function.object_name
                        AND routine_schema = 'public'
                        ORDER BY ordinal_position
                    LOOP
                        v_return_columns := v_return_columns || jsonb_build_array(
                            jsonb_build_object(
                                'name', v_col.column_name,
                                'type', v_col.data_type
                            )
                        );
                    END LOOP;
                EXCEPTION WHEN OTHERS THEN
                    NULL;
                END;
                
                v_return_info := jsonb_build_object(
                    'type', 'record',
                    'is_set', true,
                    'is_table', true,
                    'columns', v_return_columns
                );
            ELSE
                v_return_info := jsonb_build_object(
                    'type', v_return_type,
                    'is_set', COALESCE(v_is_table_function, false),
                    'is_table', false,
                    'columns', v_return_columns
                );
            END IF;
            
            -- Update the object_registry entry
            UPDATE object_registry
            SET properties = COALESCE(properties, '{}'::jsonb) || jsonb_build_object(
                'input_params', v_input_params,
                'return_type', v_return_info,
                'volatility', v_volatility,
                'security_definer', v_security_definer
            )
            WHERE id = v_function.id;
            
            v_count := v_count + 1;
            
        EXCEPTION WHEN OTHERS THEN
            CONTINUE;
        END;
    END LOOP;
    
    RETURN v_count;
END;
$$;


--
-- Name: populate_interface_implementations(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.populate_interface_implementations() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_interface RECORD;
  v_object RECORD;
  v_compliant boolean;
  v_prop_key text;
  v_required_type text;
  v_actual_type text;
  v_table_name text;
  v_schema_name text;
BEGIN
  DELETE FROM interface_implementations WHERE true;
  
  FOR v_interface IN SELECT id, interface_name, required_properties FROM ontology_interfaces LOOP
    FOR v_object IN SELECT id, object_name, properties FROM object_registry LOOP
      v_compliant := true;
      
      -- Get table info from properties
      v_table_name := v_object.object_name;
      v_schema_name := COALESCE(v_object.properties->>'schema', 'public');
      
      FOR v_prop_key, v_required_type IN SELECT * FROM jsonb_each_text(v_interface.required_properties) LOOP
        -- Check if column exists in the actual table
        IF NOT EXISTS (
          SELECT 1 FROM information_schema.columns 
          WHERE table_schema = v_schema_name 
          AND table_name = v_table_name 
          AND column_name = v_prop_key
        ) THEN
          v_compliant := false;
          EXIT;
        END IF;
        
        -- If required type is enum, verify it's an enum type
        IF v_required_type = 'enum' THEN
          SELECT data_type INTO v_actual_type
          FROM information_schema.columns
          WHERE table_schema = v_schema_name 
          AND table_name = v_table_name 
          AND column_name = v_prop_key;
          
          -- Check if it's a domain type (often used for enums) or is an enum
          IF v_actual_type NOT IN ('character varying', 'text', 'USER-DEFINED') THEN
            v_compliant := false;
            EXIT;
          END IF;
        END IF;
      END LOOP;
      
      INSERT INTO interface_implementations (interface_id, object_id, compliance_status, last_checked_at)
      VALUES (
        v_interface.id,
        v_object.id,
        CASE WHEN v_compliant THEN 'compliant' ELSE 'non_compliant' END,
        now()
      ) ON CONFLICT (interface_id, object_id) DO UPDATE SET
        compliance_status = EXCLUDED.compliance_status,
        last_checked_at = EXCLUDED.last_checked_at;
    END LOOP;
  END LOOP;
END;
$$;


--
-- Name: populate_object_registry(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.populate_object_registry() RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_tables_count INT := 0;
    v_columns_count INT := 0;
    v_functions_count INT := 0;
    v_triggers_count INT := 0;
    v_views_count INT := 0;
    v_indexes_count INT := 0;
    v_policies_count INT := 0;
    v_enums_count INT := 0;
    v_fk_links_count INT := 0;
    v_trigger_links_count INT := 0;
    v_ref_links_count INT := 0;
    v_dep_links_count INT := 0;
    v_rec RECORD;
    v_table_id UUID;
    v_parent_id UUID;
    v_source_id UUID;
    v_target_id UUID;
BEGIN
    -- ============================================================
    -- PHASE 1: OBJECTS
    -- ============================================================

    -- 1a. Tables
    FOR v_rec IN 
        SELECT t.table_name,
          (SELECT reltuples::bigint FROM pg_class WHERE relname = t.table_name AND relnamespace = 'public'::regnamespace) as row_est
        FROM information_schema.tables t
        WHERE t.table_schema = 'public' AND t.table_type = 'BASE TABLE'
    LOOP
        INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
        VALUES ('table', v_rec.table_name, 
            jsonb_build_object('row_estimate', COALESCE(v_rec.row_est, 0)),
            ARRAY['SELECT','INSERT','UPDATE','DELETE','ALTER','DROP'], true, NOW())
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET properties = EXCLUDED.properties, valid_actions = EXCLUDED.valid_actions, auto_populated = true;
        v_tables_count := v_tables_count + 1;
    END LOOP;
    
    -- 1b. Columns
    FOR v_rec IN
        SELECT c.table_name, c.column_name, c.data_type, c.is_nullable, c.column_default
        FROM information_schema.columns c
        JOIN information_schema.tables t ON c.table_name = t.table_name AND c.table_schema = t.table_schema
        WHERE c.table_schema = 'public' AND t.table_type = 'BASE TABLE'
    LOOP
        SELECT id INTO v_parent_id FROM object_registry WHERE object_type = 'table' AND object_name = v_rec.table_name;
        
        INSERT INTO object_registry (object_type, object_name, parent_id, properties, valid_actions, auto_populated, created_at)
        VALUES ('column', v_rec.table_name || '.' || v_rec.column_name, v_parent_id,
            jsonb_build_object('data_type', v_rec.data_type, 'is_nullable', v_rec.is_nullable, 'column_default', v_rec.column_default),
            ARRAY['SELECT','INSERT','UPDATE'], true, NOW())
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET properties = EXCLUDED.properties, parent_id = EXCLUDED.parent_id, auto_populated = true;
        v_columns_count := v_columns_count + 1;
    END LOOP;
    
    -- 1c. Functions
    FOR v_rec IN 
        SELECT p.proname, pg_get_function_arguments(p.oid) as args, p.provolatile, p.prosecdef
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        WHERE n.nspname = 'public'
    LOOP
        INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
        VALUES ('function', v_rec.proname, 
            jsonb_build_object('arguments', v_rec.args, 'volatile', v_rec.provolatile, 'security_definer', v_rec.prosecdef),
            ARRAY['EXECUTE','ALTER','DROP'], true, NOW())
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET properties = EXCLUDED.properties, valid_actions = EXCLUDED.valid_actions, auto_populated = true;
        v_functions_count := v_functions_count + 1;
    END LOOP;
    
    -- 1d. Triggers
    FOR v_rec IN 
        SELECT t.tgname, c.relname as table_name, 
          CASE t.tgtype & 2 WHEN 2 THEN 'BEFORE' ELSE 'AFTER' END as timing,
          CASE t.tgtype & 28 
            WHEN 4 THEN 'INSERT' WHEN 8 THEN 'DELETE' WHEN 16 THEN 'UPDATE'
            WHEN 20 THEN 'INSERT_OR_UPDATE' WHEN 12 THEN 'INSERT_OR_DELETE'
            WHEN 24 THEN 'UPDATE_OR_DELETE' WHEN 28 THEN 'INSERT_OR_UPDATE_OR_DELETE'
            ELSE 'UNKNOWN'
          END as event
        FROM pg_trigger t
        JOIN pg_class c ON t.tgrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = 'public' AND NOT t.tgisinternal
    LOOP
        SELECT id INTO v_parent_id FROM object_registry WHERE object_type = 'table' AND object_name = v_rec.table_name;
        
        INSERT INTO object_registry (object_type, object_name, parent_id, properties, valid_actions, auto_populated, created_at)
        VALUES ('trigger', v_rec.table_name || '.' || v_rec.tgname, v_parent_id,
            jsonb_build_object('table_name', v_rec.table_name, 'timing', v_rec.timing, 'event', v_rec.event),
            ARRAY['DROP'], true, NOW())
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET parent_id = EXCLUDED.parent_id, properties = EXCLUDED.properties, auto_populated = true;
        v_triggers_count := v_triggers_count + 1;
    END LOOP;
    
    -- 1e. Views
    FOR v_rec IN 
        SELECT table_name FROM information_schema.views WHERE table_schema = 'public'
    LOOP
        INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
        VALUES ('view', v_rec.table_name, '{}'::jsonb, ARRAY['SELECT','ALTER','DROP'], true, NOW())
        ON CONFLICT (object_type, object_name) DO UPDATE SET auto_populated = true;
        v_views_count := v_views_count + 1;
    END LOOP;
    
    -- 1f. Indexes (non-primary)
    FOR v_rec IN
        SELECT i.relname as index_name, t.relname as table_name, ix.indisunique
        FROM pg_index ix
        JOIN pg_class i ON ix.indexrelid = i.oid
        JOIN pg_class t ON ix.indrelid = t.oid
        JOIN pg_namespace n ON t.relnamespace = n.oid
        WHERE n.nspname = 'public' AND NOT ix.indisprimary
    LOOP
        SELECT id INTO v_parent_id FROM object_registry WHERE object_type = 'table' AND object_name = v_rec.table_name;
        
        INSERT INTO object_registry (object_type, object_name, parent_id, properties, valid_actions, auto_populated, created_at)
        VALUES ('index', v_rec.table_name || '.' || v_rec.index_name, v_parent_id,
            jsonb_build_object('table_name', v_rec.table_name, 'is_unique', v_rec.indisunique),
            ARRAY['DROP'], true, NOW())
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET parent_id = EXCLUDED.parent_id, properties = EXCLUDED.properties, auto_populated = true;
        v_indexes_count := v_indexes_count + 1;
    END LOOP;
    
    -- 1g. RLS Policies
    FOR v_rec IN
        SELECT pol.polname, c.relname as table_name, 
          CASE pol.polcmd WHEN 'r' THEN 'SELECT' WHEN 'a' THEN 'INSERT' WHEN 'w' THEN 'UPDATE' WHEN 'd' THEN 'DELETE' ELSE '*' END as command,
          CASE WHEN pol.polpermissive THEN 'PERMISSIVE' ELSE 'RESTRICTIVE' END as permissive
        FROM pg_policy pol
        JOIN pg_class c ON pol.polrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = 'public'
    LOOP
        SELECT id INTO v_parent_id FROM object_registry WHERE object_type = 'table' AND object_name = v_rec.table_name;
        
        INSERT INTO object_registry (object_type, object_name, parent_id, properties, valid_actions, auto_populated, created_at)
        VALUES ('policy', v_rec.table_name || '.' || v_rec.polname, v_parent_id,
            jsonb_build_object('table_name', v_rec.table_name, 'command', v_rec.command, 'permissive', v_rec.permissive),
            ARRAY['DROP','ALTER'], true, NOW())
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET parent_id = EXCLUDED.parent_id, properties = EXCLUDED.properties, auto_populated = true;
        v_policies_count := v_policies_count + 1;
    END LOOP;
    
    -- 1h. Enums
    FOR v_rec IN
        SELECT t.typname, string_agg(e.enumlabel, ',' ORDER BY e.enumsortorder) as labels
        FROM pg_type t
        JOIN pg_enum e ON t.oid = e.enumtypid
        JOIN pg_namespace n ON t.typnamespace = n.oid
        WHERE n.nspname = 'public'
        GROUP BY t.typname
    LOOP
        INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
        VALUES ('enum', v_rec.typname, jsonb_build_object('labels', v_rec.labels), ARRAY['ALTER'], true, NOW())
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET properties = EXCLUDED.properties, auto_populated = true;
        v_enums_count := v_enums_count + 1;
    END LOOP;

    -- ============================================================
    -- PHASE 2: LINKS
    -- ============================================================
    
    -- 2a. FK links (table → table)
    FOR v_rec IN 
        SELECT con.conname, c1.relname as source_table, c2.relname as target_table,
               a1.attname as source_column, a2.attname as target_column
        FROM pg_constraint con
        JOIN pg_class c1 ON con.conrelid = c1.oid
        JOIN pg_class c2 ON con.confrelid = c2.oid
        JOIN pg_attribute a1 ON con.conrelid = a1.attrelid AND a1.attnum = ANY(con.conkey)
        JOIN pg_attribute a2 ON con.confrelid = a2.attrelid AND a2.attnum = ANY(con.confkey)
        JOIN pg_namespace n ON c1.relnamespace = n.oid
        WHERE con.contype = 'f' AND n.nspname = 'public'
    LOOP
        SELECT id INTO v_source_id FROM object_registry WHERE object_type = 'table' AND object_name = v_rec.source_table;
        SELECT id INTO v_target_id FROM object_registry WHERE object_type = 'table' AND object_name = v_rec.target_table;
        
        IF v_source_id IS NOT NULL AND v_target_id IS NOT NULL THEN
            INSERT INTO object_links (source_id, target_id, link_type, properties, created_at)
            VALUES (v_source_id, v_target_id, 'fk',
                jsonb_build_object('constraint', v_rec.conname, 'source_col', v_rec.source_column, 'target_col', v_rec.target_column),
                NOW())
            ON CONFLICT (source_id, target_id, link_type) DO UPDATE SET properties = EXCLUDED.properties;
            v_fk_links_count := v_fk_links_count + 1;
        END IF;
    END LOOP;
    
    -- 2b. Trigger → table links
    FOR v_rec IN
        SELECT t.tgname, c.relname as table_name
        FROM pg_trigger t
        JOIN pg_class c ON t.tgrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = 'public' AND NOT t.tgisinternal
    LOOP
        SELECT id INTO v_source_id FROM object_registry WHERE object_type = 'trigger' AND object_name = v_rec.table_name || '.' || v_rec.tgname;
        SELECT id INTO v_target_id FROM object_registry WHERE object_type = 'table' AND object_name = v_rec.table_name;
        
        IF v_source_id IS NOT NULL AND v_target_id IS NOT NULL THEN
            INSERT INTO object_links (source_id, target_id, link_type, properties, created_at)
            VALUES (v_source_id, v_target_id, 'triggers', '{}'::jsonb, NOW())
            ON CONFLICT (source_id, target_id, link_type) DO NOTHING;
            v_trigger_links_count := v_trigger_links_count + 1;
        END IF;
    END LOOP;
    
    -- 2c. View → table reference links
    FOR v_rec IN
        SELECT DISTINCT view_name, table_name
        FROM information_schema.view_column_usage
        WHERE view_schema = 'public' AND table_schema = 'public'
    LOOP
        SELECT id INTO v_source_id FROM object_registry WHERE object_type = 'view' AND object_name = v_rec.view_name;
        SELECT id INTO v_target_id FROM object_registry WHERE object_type = 'table' AND object_name = v_rec.table_name;
        
        IF v_source_id IS NOT NULL AND v_target_id IS NOT NULL THEN
            INSERT INTO object_links (source_id, target_id, link_type, properties, created_at)
            VALUES (v_source_id, v_target_id, 'references', '{}'::jsonb, NOW())
            ON CONFLICT (source_id, target_id, link_type) DO NOTHING;
            v_ref_links_count := v_ref_links_count + 1;
        END IF;
    END LOOP;
    
    -- 2d. Trigger → function calls links
    FOR v_rec IN
        SELECT t.tgname, c.relname as table_name, p.proname as func_name
        FROM pg_trigger t
        JOIN pg_class c ON t.tgrelid = c.oid
        JOIN pg_proc p ON t.tgfoid = p.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = 'public' AND NOT t.tgisinternal
    LOOP
        SELECT id INTO v_source_id FROM object_registry WHERE object_type = 'trigger' AND object_name = v_rec.table_name || '.' || v_rec.tgname;
        SELECT id INTO v_target_id FROM object_registry WHERE object_type = 'function' AND object_name = v_rec.func_name;
        
        IF v_source_id IS NOT NULL AND v_target_id IS NOT NULL THEN
            INSERT INTO object_links (source_id, target_id, link_type, properties, created_at)
            VALUES (v_source_id, v_target_id, 'calls', '{}'::jsonb, NOW())
            ON CONFLICT (source_id, target_id, link_type) DO NOTHING;
            v_dep_links_count := v_dep_links_count + 1;
        END IF;
    END LOOP;

    -- ============================================================
    -- PHASE 3: CROSS-REFERENCES
    -- ============================================================
    UPDATE object_registry o
    SET system_manifest_id = s.id
    FROM system_manifest s
    WHERE o.object_name = s.name
      AND o.object_type = CASE 
            WHEN s.component_type = 'table' THEN 'table'
            WHEN s.component_type = 'edge_function' THEN 'function'
            WHEN s.component_type = 'trigger' THEN 'trigger'
            WHEN s.component_type = 'view' THEN 'view'
            ELSE o.object_type
          END
      AND o.system_manifest_id IS NULL;
    
    RETURN jsonb_build_object(
        'tables', v_tables_count, 'columns', v_columns_count,
        'functions', v_functions_count, 'triggers', v_triggers_count,
        'views', v_views_count, 'indexes', v_indexes_count,
        'policies', v_policies_count, 'enums', v_enums_count,
        'fk_links', v_fk_links_count, 'trigger_links', v_trigger_links_count,
        'reference_links', v_ref_links_count, 'dependency_links', v_dep_links_count
    );
END;
$$;


--
-- Name: populate_semantic_links(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.populate_semantic_links() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_depends_count INT := 0;
    v_mutates_count INT := 0;
    v_validates_count INT := 0;
    v_guards_count INT := 0;
    v_rec RECORD;
    v_source_id UUID;
    v_target_id UUID;
    v_link_id UUID;
BEGIN
    -- ============================================================
    -- TYPE 1: depends_on - Function dependencies via pg_depend
    -- ============================================================
    FOR v_rec IN
        SELECT 
            p.proname as source_func,
            ref_p.proname as target_func
        FROM pg_depend d
        JOIN pg_proc p ON d.objid = p.oid
        JOIN pg_namespace n ON p.pronamespace = n.oid
        JOIN pg_proc ref_p ON d.refobjid = ref_p.oid
        JOIN pg_namespace ref_n ON ref_p.pronamespace = ref_n.oid
        WHERE n.nspname = 'public' 
          AND ref_n.nspname = 'public'
          AND d.deptype = 'normal'
          AND p.proname != ref_p.proname
        GROUP BY p.proname, ref_p.proname
    LOOP
        -- Get source function id
        SELECT id INTO v_source_id 
        FROM object_registry 
        WHERE object_type = 'function' AND object_name = v_rec.source_func;
        
        -- Get target function id
        SELECT id INTO v_target_id 
        FROM object_registry 
        WHERE object_type = 'function' AND object_name = v_rec.target_func;
        
        IF v_source_id IS NOT NULL AND v_target_id IS NOT NULL THEN
            -- Check if link already exists
            SELECT id INTO v_link_id FROM object_links 
            WHERE source_id = v_source_id AND target_id = v_target_id AND link_type = 'depends_on';
            
            IF v_link_id IS NULL THEN
                INSERT INTO object_links (source_id, target_id, link_type, properties, created_at)
                VALUES (v_source_id, v_target_id, 'depends_on', 
                    jsonb_build_object('dependency_type', 'function_call'), NOW())
                ON CONFLICT DO NOTHING;
                v_depends_count := v_depends_count + 1;
            END IF;
        END IF;
        
        v_source_id := NULL;
        v_target_id := NULL;
        v_link_id := NULL;
    END LOOP;

    -- ============================================================
    -- TYPE 2: mutates - Trigger functions that modify tables
    -- ============================================================
    FOR v_rec IN
        SELECT 
            p.proname as trigger_func,
            c.relname as target_table
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        JOIN pg_trigger t ON p.oid = t.tgfoid
        JOIN pg_class c ON t.tgrelid = c.oid
        JOIN pg_namespace tn ON c.relnamespace = tn.oid
        WHERE n.nspname = 'public' 
          AND tn.nspname = 'public'
          AND NOT t.tgisinternal
    LOOP
        -- Get trigger function id
        SELECT id INTO v_source_id 
        FROM object_registry 
        WHERE object_type = 'function' AND object_name = v_rec.trigger_func;
        
        -- Get target table id
        SELECT id INTO v_target_id 
        FROM object_registry 
        WHERE object_type = 'table' AND object_name = v_rec.target_table;
        
        IF v_source_id IS NOT NULL AND v_target_id IS NOT NULL THEN
            -- Check if link already exists
            SELECT id INTO v_link_id FROM object_links 
            WHERE source_id = v_source_id AND target_id = v_target_id AND link_type = 'mutates';
            
            IF v_link_id IS NULL THEN
                INSERT INTO object_links (source_id, target_id, link_type, properties, created_at)
                VALUES (v_source_id, v_target_id, 'mutates', 
                    jsonb_build_object('trigger_event', 'INSERT/UPDATE/DELETE'), NOW())
                ON CONFLICT DO NOTHING;
                v_mutates_count := v_mutates_count + 1;
            END IF;
        END IF;
        
        v_source_id := NULL;
        v_target_id := NULL;
        v_link_id := NULL;
    END LOOP;

    -- ============================================================
    -- TYPE 3: validates - CHECK constraints and RLS policies
    -- ============================================================
    
    -- 3a. CHECK constraints per table
    FOR v_rec IN
        SELECT 
            c.conname as constraint_name,
            t.relname as table_name,
            pg_get_constraintdef(c.oid) as constraint_def
        FROM pg_constraint c
        JOIN pg_class t ON c.conrelid = t.oid
        JOIN pg_namespace n ON t.relnamespace = n.oid
        WHERE n.nspname = 'public' AND c.contype = 'c'
    LOOP
        -- Get table id
        SELECT id INTO v_source_id 
        FROM object_registry 
        WHERE object_type = 'table' AND object_name = v_rec.table_name;
        
        IF v_source_id IS NOT NULL THEN
            -- Check if link already exists
            SELECT id INTO v_link_id FROM object_links 
            WHERE source_id = v_source_id AND link_type = 'validates'
              AND properties->>'constraint_name' = v_rec.constraint_name;
            
            IF v_link_id IS NULL THEN
                INSERT INTO object_links (source_id, target_id, link_type, properties, created_at)
                VALUES (v_source_id, v_source_id, 'validates', 
                    jsonb_build_object('constraint_name', v_rec.constraint_name, 'constraint_def', v_rec.constraint_def), NOW())
                ON CONFLICT DO NOTHING;
                v_validates_count := v_validates_count + 1;
            END IF;
        END IF;
        
        v_source_id := NULL;
        v_target_id := NULL;
        v_link_id := NULL;
    END LOOP;
    
    -- 3b. RLS policies per table
    FOR v_rec IN
        SELECT 
            pol.polname as policy_name,
            c.relname as table_name,
            CASE pol.polcmd WHEN 'r' THEN 'SELECT' WHEN 'a' THEN 'INSERT' WHEN 'w' THEN 'UPDATE' WHEN 'd' THEN 'DELETE' ELSE '*' END as command
        FROM pg_policy pol
        JOIN pg_class c ON pol.polrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = 'public'
    LOOP
        SELECT id INTO v_source_id 
        FROM object_registry 
        WHERE object_type = 'table' AND object_name = v_rec.table_name;
        
        IF v_source_id IS NOT NULL THEN
            SELECT id INTO v_link_id FROM object_links 
            WHERE source_id = v_source_id AND link_type = 'validates'
              AND properties->>'policy_name' = v_rec.policy_name;
            
            IF v_link_id IS NULL THEN
                INSERT INTO object_links (source_id, target_id, link_type, properties, created_at)
                VALUES (v_source_id, v_source_id, 'validates', 
                    jsonb_build_object('policy_name', v_rec.policy_name, 'command', v_rec.command), NOW())
                ON CONFLICT DO NOTHING;
                v_validates_count := v_validates_count + 1;
            END IF;
        END IF;
        
        v_source_id := NULL;
        v_link_id := NULL;
    END LOOP;

    -- ============================================================
    -- TYPE 4: guards - Trigger functions that RAISE EXCEPTION
    -- ============================================================
    FOR v_rec IN
        SELECT 
            p.proname as guard_func,
            c.relname as table_name,
            t.tgname as trigger_name
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        JOIN pg_trigger t ON p.oid = t.tgfoid
        JOIN pg_class c ON t.tgrelid = c.oid
        JOIN pg_namespace tn ON c.relnamespace = tn.oid
        WHERE n.nspname = 'public' 
          AND tn.nspname = 'public'
          AND NOT t.tgisinternal
          AND p.prosrc ILIKE '%raise%exception%'
    LOOP
        SELECT id INTO v_source_id 
        FROM object_registry 
        WHERE object_type = 'function' AND object_name = v_rec.guard_func;
        
        SELECT id INTO v_target_id 
        FROM object_registry 
        WHERE object_type = 'table' AND object_name = v_rec.table_name;
        
        IF v_source_id IS NOT NULL AND v_target_id IS NOT NULL THEN
            SELECT id INTO v_link_id FROM object_links 
            WHERE source_id = v_source_id AND target_id = v_target_id AND link_type = 'guards';
            
            IF v_link_id IS NULL THEN
                INSERT INTO object_links (source_id, target_id, link_type, properties, created_at)
                VALUES (v_source_id, v_target_id, 'guards', 
                    jsonb_build_object('trigger_name', v_rec.trigger_name), NOW())
                ON CONFLICT DO NOTHING;
                v_guards_count := v_guards_count + 1;
            END IF;
        END IF;
        
        v_source_id := NULL;
        v_target_id := NULL;
        v_link_id := NULL;
    END LOOP;

    -- Log results
    RAISE NOTICE 'populate_semantic_links completed: depends_on=%, mutates=%, validates=%, guards=%', 
        v_depends_count, v_mutates_count, v_validates_count, v_guards_count;
END;
$$;


--
-- Name: pre_auto_close_insert_approval(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.pre_auto_close_insert_approval() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_item jsonb;
  v_all_pass boolean := true;
  v_has_items boolean := false;
  v_blocking_findings_count int := 0;
BEGIN
  -- Only act on WOs in review status
  IF NEW.status != 'review' THEN
    RETURN NEW;
  END IF;
  
  -- Only act when qa_checklist or qa_review_verified_at changes
  IF OLD.qa_checklist IS NOT DISTINCT FROM NEW.qa_checklist
     AND OLD.qa_review_verified_at IS NOT DISTINCT FROM NEW.qa_review_verified_at THEN
    RETURN NEW;
  END IF;
  
  -- Must have checklist items
  IF NEW.qa_checklist IS NULL OR jsonb_array_length(NEW.qa_checklist) = 0 THEN
    RETURN NEW;
  END IF;
  
  -- WO-0560 guard: must have qa_review_verified_at set
  IF NEW.qa_review_verified_at IS NULL THEN
    RETURN NEW;
  END IF;
  
  -- Check all checklist items pass
  FOR v_item IN SELECT * FROM jsonb_array_elements(NEW.qa_checklist)
  LOOP
    v_has_items := true;
    IF v_item->>'status' NOT IN ('pass', 'na') THEN
      v_all_pass := false;
      EXIT;
    END IF;
  END LOOP;
  
  IF v_has_items AND v_all_pass THEN
    -- Check no blocking fail findings
    SELECT count(*) INTO v_blocking_findings_count
    FROM qa_findings
    WHERE work_order_id = NEW.id
      AND finding_type = 'fail'
      AND resolved_at IS NULL;
    
    IF v_blocking_findings_count > 0 THEN
      RETURN NEW;
    END IF;
    
    -- All conditions met for auto-close. Insert approval record.
    PERFORM insert_auto_close_approval(NEW.id, jsonb_array_length(NEW.qa_checklist));
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: prevent_duplicate_lesson(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.prevent_duplicate_lesson() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Check if an unreviewed lesson with same category+pattern already exists
  IF EXISTS (
    SELECT 1 FROM lessons
    WHERE category = NEW.category
      AND pattern = NEW.pattern
      AND reviewed = false
    LIMIT 1
  ) THEN
    -- Silently skip the insert (return NULL to cancel)
    RAISE NOTICE 'Duplicate lesson detected: category=%, pattern=%. Skipping insert.', NEW.category, NEW.pattern;
    RETURN NULL;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION prevent_duplicate_lesson(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.prevent_duplicate_lesson() IS 'WO-0264: Prevents duplicate lessons with same (category, pattern) from being inserted';


--
-- Name: prevent_mutation_tampering(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.prevent_mutation_tampering() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Allow cleanup during test suite runs (transaction-scoped config)
  IF current_setting('app.test_cleanup_active', true) = 'true' THEN
    RETURN OLD;
  END IF;
  RAISE EXCEPTION 'Tampering with wo_mutations records is prohibited. Updates and deletes are blocked.';
END;
$$;


--
-- Name: process_effect_on_insert(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.process_effect_on_insert() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
BEGIN
  -- Outbox processor is now the sole handler for side effects.
  -- Old reactive triggers have been dropped.
  PERFORM process_wo_effect(NEW.id);
  RETURN NEW;
END;
$$;


--
-- Name: process_pending_effects(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.process_pending_effects() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_effect_id uuid;
  v_count int := 0;
BEGIN
  FOR v_effect_id IN
    SELECT id FROM wo_effects
    WHERE status = 'pending'
    ORDER BY created_at
    LIMIT 50
  LOOP
    PERFORM process_wo_effect(v_effect_id);
    v_count := v_count + 1;
  END LOOP;
  RETURN v_count;
END;
$$;


--
-- Name: process_wo_effect(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.process_wo_effect(p_effect_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$ 
DECLARE
  v_effect record;
  v_anon_key text;
  v_supabase_url text;
  v_wo record;
  v_result jsonb;
BEGIN
  SELECT * INTO v_effect FROM wo_effects WHERE id = p_effect_id;
  IF v_effect.id IS NULL THEN RETURN jsonb_build_object('success', false, 'error', 'Effect not found'); END IF;
  IF v_effect.status NOT IN ('pending', 'processing') THEN RETURN jsonb_build_object('success', false, 'error', 'Effect already ' || v_effect.status); END IF;

  UPDATE wo_effects SET status = 'processing' WHERE id = p_effect_id;
  SELECT * INTO v_wo FROM work_orders WHERE id = v_effect.work_order_id;

  SELECT (setting_value#>>'{}')::text INTO v_anon_key FROM system_settings WHERE setting_key = 'supabase_anon_key';
  SELECT (setting_value#>>'{}')::text INTO v_supabase_url FROM system_settings WHERE setting_key = 'supabase_url';

  CASE v_effect.effect_type

    WHEN 'dispatch_agent' THEN
      IF v_anon_key IS NULL THEN RAISE EXCEPTION 'supabase_anon_key not configured'; END IF;
      DECLARE v_agent_name text;
      BEGIN
        SELECT a.name INTO v_agent_name FROM agents a WHERE a.id = v_wo.assigned_to;
        IF v_agent_name = 'ilmarinen' THEN v_result := jsonb_build_object('skipped', true, 'reason', 'ilmarinen-assigned');
        ELSE
          PERFORM net.http_post(url := COALESCE(v_supabase_url, 'https://phfblljwuvzqzlbzkzpr.supabase.co') || '/functions/v1/wo-agent/execute',
            headers := jsonb_build_object('Content-Type', 'application/json', 'Authorization', 'Bearer ' || v_anon_key, 'apikey', v_anon_key),
            body := jsonb_build_object('work_order_id', v_effect.work_order_id));
          v_result := jsonb_build_object('dispatched', true);
        END IF;
      END;

    WHEN 'trigger_qa' THEN
      IF v_anon_key IS NULL THEN RAISE EXCEPTION 'supabase_anon_key not configured'; END IF;
      UPDATE qa_findings SET resolved_at = now() WHERE work_order_id = v_effect.work_order_id AND resolved_at IS NULL;
      DECLARE v_verdict jsonb;
      BEGIN
        v_verdict := evaluate_wo_lifecycle(v_effect.work_order_id, 'qa_verdict');
        IF v_verdict->>'verdict' IN ('skip', 'cancel') THEN v_result := jsonb_build_object('skipped', true, 'reason', v_verdict->>'reason');
        ELSE
          PERFORM net.http_post(url := COALESCE(v_supabase_url, 'https://phfblljwuvzqzlbzkzpr.supabase.co') || '/functions/v1/qa-review',
            headers := jsonb_build_object('Content-Type', 'application/json', 'Authorization', 'Bearer ' || v_anon_key, 'apikey', v_anon_key),
            body := jsonb_build_object('work_order_id', v_effect.work_order_id::text));
          v_result := jsonb_build_object('qa_triggered', true);
        END IF;
      END;

    WHEN 'unblock_dependents' THEN
      DECLARE v_unblocked int;
      BEGIN
        UPDATE work_orders SET status = 'ready', updated_at = NOW()
        WHERE status = 'blocked_on_input' AND depends_on && ARRAY[v_effect.work_order_id];
        GET DIAGNOSTICS v_unblocked = ROW_COUNT;
        v_result := jsonb_build_object('unblocked_count', v_unblocked);
      END;

    WHEN 'advance_pipeline' THEN
      IF v_wo.pipeline_run_id IS NOT NULL AND v_wo.pipeline_phase IS NOT NULL THEN
        PERFORM advance_pipeline_phase(v_wo.pipeline_run_id);
        v_result := jsonb_build_object('pipeline_advanced', true);
      ELSE v_result := jsonb_build_object('skipped', true, 'reason', 'not a pipeline WO'); END IF;

    WHEN 'close_parent_remediation' THEN
      DECLARE v_parent_status text; v_lifecycle_verdict jsonb;
      BEGIN
        IF 'remediation' = ANY(COALESCE(v_wo.tags, ARRAY[]::text[])) AND v_wo.parent_id IS NOT NULL THEN
          SELECT status INTO v_parent_status FROM work_orders WHERE id = v_wo.parent_id;
          IF v_parent_status = 'review' THEN v_result := jsonb_build_object('skipped', true, 'reason', 'parent in review');
          ELSE
            v_lifecycle_verdict := evaluate_wo_lifecycle(v_wo.parent_id, 'child_complete');
            IF (v_lifecycle_verdict->>'verdict') = 'proceed' THEN
              UPDATE work_orders SET status = 'review', completed_at = NOW() WHERE id = v_wo.parent_id;
              v_result := jsonb_build_object('parent_moved_to_review', true);
            ELSE v_result := jsonb_build_object('skipped', true, 'reason', 'lifecycle gate blocked'); END IF;
          END IF;
        ELSE v_result := jsonb_build_object('skipped', true, 'reason', 'not remediation or no parent'); END IF;
      END;

    WHEN 'spawn_remediation' THEN
      DECLARE
        v_already boolean; v_rem_id uuid; v_failure_reason text;
      BEGIN
        SELECT EXISTS(SELECT 1 FROM work_orders WHERE parent_id = v_effect.work_order_id
          AND 'remediation' = ANY(tags) AND status NOT IN ('cancelled', 'done'))
        INTO v_already;
        IF v_already THEN v_result := jsonb_build_object('skipped', true, 'reason', 'active remediation exists');
        ELSIF COALESCE(v_wo.retry_count, 0) >= COALESCE(v_wo.max_retries, 3) THEN
          v_result := jsonb_build_object('skipped', true, 'reason', 'max retries exhausted');
        ELSE
          v_failure_reason := COALESCE(
            v_effect.payload->>'failure_reason', v_effect.payload->>'error', v_effect.payload->>'reason',
            (SELECT detail->>'error' FROM work_order_execution_log
             WHERE work_order_id = v_effect.work_order_id AND phase = 'failed'
             ORDER BY created_at DESC LIMIT 1),
            'Unknown failure');

          INSERT INTO work_orders (slug, name, objective, acceptance_criteria, priority, status, source, tags, parent_id, created_by, client_info)
          VALUES (
            'remediation-' || v_wo.slug || '-' || to_char(NOW(), 'YYYYMMDD-HH24MISS'),
            'Remediate: ' || v_wo.name,
            build_remediation_objective(v_effect.work_order_id, v_failure_reason),
            COALESCE(NULLIF(trim(COALESCE(v_wo.acceptance_criteria, '')), ''),
              E'1. Investigate and fix the root cause of the failure\n2. Verify the fix resolves the original objective\n3. Ensure no regression in existing functionality'),
            v_wo.priority, 'draft', 'auto-qa',
            ARRAY['remediation', 'parent:' || v_wo.slug],
            v_effect.work_order_id, 'engineering',
            jsonb_build_object('remediation_of', v_wo.slug, 'retry_count', COALESCE(v_wo.retry_count, 0) + 1)
          ) RETURNING id INTO v_rem_id;

          PERFORM wo_transition(v_rem_id, 'approve',
            jsonb_build_object('auto_approved', true, 'remediation_of', v_wo.slug), 'system', 1);

          v_result := jsonb_build_object('spawned', true, 'remediation_id', v_rem_id, 'auto_started', true, 'failure_reason', v_failure_reason);
        END IF;
      END;

    WHEN 'auto_start' THEN
      DECLARE v_agent_name text;
      BEGIN
        SELECT a.name INTO v_agent_name FROM agents a WHERE a.id = v_wo.assigned_to;
        IF v_agent_name IS NULL THEN v_agent_name := 'builder'; END IF;
        v_result := wo_transition(v_effect.work_order_id, 'start_work',
          jsonb_build_object('auto_started', true, 'agent_name', v_agent_name), 'system', 1);
      END;

    WHEN 'unblock_pipelines' THEN
      DECLARE v_rows int;
      BEGIN
        IF v_wo.pipeline_run_id IS NOT NULL THEN
          UPDATE pipeline_runs SET updated_at = NOW()
          WHERE status = 'active' AND v_wo.pipeline_run_id = ANY(depends_on_pipeline_ids);
          GET DIAGNOSTICS v_rows = ROW_COUNT;
          v_result := jsonb_build_object('unblocked_pipelines', v_rows);
        ELSE v_result := jsonb_build_object('skipped', true, 'reason', 'no pipeline'); END IF;
      END;

    WHEN 'schedule_liveness_check' THEN
      IF v_anon_key IS NULL THEN RAISE EXCEPTION 'supabase_anon_key not configured'; END IF;
      PERFORM net.http_post(
        url := COALESCE(v_supabase_url, 'https://phfblljwuvzqzlbzkzpr.supabase.co') || '/functions/v1/health-check',
        headers := jsonb_build_object('Content-Type', 'application/json', 'Authorization', 'Bearer ' || v_anon_key, 'apikey', v_anon_key),
        body := jsonb_build_object('action', 'liveness-check', 'work_order_id', v_effect.work_order_id::text),
        timeout_milliseconds := 5000);
      v_result := jsonb_build_object('liveness_check_scheduled', true);

    WHEN 'populate_qa_checklist' THEN
      DECLARE v_criteria_source text; v_ac_count int;
      BEGIN
        IF v_wo.qa_checklist IS NULL OR v_wo.qa_checklist = '[]'::jsonb THEN
          v_criteria_source := COALESCE(NULLIF(trim(COALESCE(v_wo.acceptance_criteria, '')), ''), NULLIF(trim(COALESCE(v_wo.objective, '')), ''));
          IF v_criteria_source IS NOT NULL THEN
            v_ac_count := count_acceptance_criteria(v_criteria_source);
            IF v_ac_count > 0 THEN
              UPDATE work_orders SET qa_checklist = parse_criteria_to_checklist(v_criteria_source) WHERE id = v_wo.id;
              v_result := jsonb_build_object('populated', true, 'item_count', v_ac_count);
            ELSE v_result := jsonb_build_object('skipped', true, 'reason', 'no criteria found'); END IF;
          ELSE v_result := jsonb_build_object('skipped', true, 'reason', 'no criteria source'); END IF;
        ELSE v_result := jsonb_build_object('skipped', true, 'reason', 'checklist already exists'); END IF;
      END;

    WHEN 'settle_children' THEN
      DECLARE v_settled int;
      BEGIN
        PERFORM set_config('app.wo_enforce_bypass', 'true', true);
        UPDATE work_orders SET status = 'cancelled', cancellation_reason = 'Parent ' || v_wo.status
        WHERE parent_id = v_wo.id AND status NOT IN ('done', 'cancelled', 'failed') AND NOT ('remediation' = ANY(COALESCE(tags, ARRAY[]::text[])));
        GET DIAGNOSTICS v_settled = ROW_COUNT;
        v_result := jsonb_build_object('settled_count', v_settled);
      END;

    WHEN 'resume_parent' THEN
      DECLARE v_parent_id uuid; v_active_children int; v_parent_status text; v_is_remediation boolean;
      BEGIN
        v_parent_id := v_wo.parent_id;
        IF v_parent_id IS NULL THEN v_result := jsonb_build_object('skipped', true, 'reason', 'no parent');
        ELSE
          SELECT status INTO v_parent_status FROM work_orders WHERE id = v_parent_id;
          v_is_remediation := 'remediation' = ANY(COALESCE(v_wo.tags, ARRAY[]::text[]));
          IF v_is_remediation AND v_parent_status = 'review' THEN
            UPDATE work_orders SET qa_review_verified_at = NULL, updated_at = NOW() WHERE id = v_parent_id;
            INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
            VALUES (v_parent_id, 'stream', 'system', jsonb_build_object('event_type', 'qa_retriggered', 'remediation_slug', v_wo.slug));
            v_result := jsonb_build_object('qa_retriggered', true, 'parent_id', v_parent_id);
          ELSIF v_parent_status = 'in_progress' THEN
            SELECT count(*) INTO v_active_children FROM work_orders
            WHERE parent_id = v_parent_id AND id != v_wo.id AND status IN ('in_progress', 'review', 'ready', 'draft');
            IF v_active_children = 0 AND v_anon_key IS NOT NULL THEN
              PERFORM net.http_post(url := COALESCE(v_supabase_url, 'https://phfblljwuvzqzlbzkzpr.supabase.co') || '/functions/v1/wo-agent/execute',
                headers := jsonb_build_object('Content-Type', 'application/json', 'Authorization', 'Bearer ' || v_anon_key, 'apikey', v_anon_key),
                body := jsonb_build_object('work_order_id', v_parent_id::text));
              v_result := jsonb_build_object('parent_dispatched', true, 'parent_id', v_parent_id);
            ELSE v_result := jsonb_build_object('skipped', true, 'reason', 'active children or no key'); END IF;
          ELSE v_result := jsonb_build_object('skipped', true, 'reason', 'parent ' || COALESCE(v_parent_status, 'null')); END IF;
        END IF;
      END;

    WHEN 'escalate_parent_failure' THEN
      DECLARE v_parent_id uuid; v_parent_status text; v_parent_slug text; v_failed_count int; v_total_children int;
      BEGIN
        v_parent_id := v_wo.parent_id;
        IF v_parent_id IS NULL THEN v_result := jsonb_build_object('skipped', true, 'reason', 'no parent');
        ELSE
          SELECT status, slug INTO v_parent_status, v_parent_slug FROM work_orders WHERE id = v_parent_id;
          IF v_parent_status IN ('done', 'cancelled', 'failed') THEN v_result := jsonb_build_object('skipped', true, 'reason', 'parent terminal');
          ELSE
            SELECT COUNT(*) INTO v_total_children FROM work_orders WHERE parent_id = v_parent_id;
            SELECT COUNT(*) INTO v_failed_count FROM work_orders WHERE parent_id = v_parent_id AND status = 'failed';
            IF v_failed_count = v_total_children AND v_total_children > 0 THEN
              PERFORM set_config('app.wo_enforce_bypass', 'true', true);
              UPDATE work_orders SET status = 'failed', summary = 'All children failed' WHERE id = v_parent_id;
              v_result := jsonb_build_object('parent_escalated', true, 'failed_children', v_failed_count);
            ELSE v_result := jsonb_build_object('skipped', true, 'reason', 'not all failed'); END IF;
          END IF;
        END IF;
      END;

    WHEN 'audit_failure' THEN
      INSERT INTO audit_log (event_type, actor_type, target_type, target_id, action, payload, work_order_id)
      VALUES ('failure', 'system', 'work_order', v_wo.id, 'work_order_failed',
        jsonb_build_object('slug', v_wo.slug, 'retry_count', COALESCE(v_wo.retry_count, 0)), v_wo.id);
      v_result := jsonb_build_object('audit_logged', true);

    ELSE RAISE EXCEPTION 'Unknown effect_type: %', v_effect.effect_type;
  END CASE;

  UPDATE wo_effects SET status = 'completed', processed_at = now(),
    payload = payload || jsonb_build_object('result', COALESCE(v_result, '{}'::jsonb))
  WHERE id = p_effect_id;
  RETURN jsonb_build_object('success', true, 'effect_type', v_effect.effect_type, 'result', v_result);

EXCEPTION WHEN OTHERS THEN
  DECLARE v_current_retry int; v_max int; v_original_error text;
  BEGIN
    v_original_error := SQLERRM;
    SELECT retry_count, max_retries INTO v_current_retry, v_max FROM wo_effects WHERE id = p_effect_id;
    v_current_retry := COALESCE(v_current_retry, 0); v_max := COALESCE(v_max, 3);
    UPDATE wo_effects SET status = 'failed', error_detail = v_original_error, retry_count = v_current_retry + 1 WHERE id = p_effect_id;
    IF v_current_retry + 1 < v_max THEN
      INSERT INTO wo_effects (work_order_id, effect_type, payload, status, retry_count, max_retries)
      VALUES (v_effect.work_order_id, v_effect.effect_type,
        v_effect.payload || jsonb_build_object('retry_of', p_effect_id, 'retry_error', v_original_error),
        'pending', v_current_retry + 1, v_max);
    END IF;
  EXCEPTION WHEN OTHERS THEN
    UPDATE wo_effects SET status = 'failed', error_detail = v_original_error || ' [retry: ' || SQLERRM || ']' WHERE id = p_effect_id;
  END;
  RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
 $$;


--
-- Name: promote_lesson_to_directive(uuid, text, text, integer, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.promote_lesson_to_directive(p_lesson_id uuid, p_directive_type text DEFAULT 'rule'::text, p_enforcement text DEFAULT 'soft'::text, p_priority integer DEFAULT 50, p_promoted_by text DEFAULT 'system'::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_lesson lessons;
  v_directive_id UUID;
  v_existing_directive_id UUID;
  v_directive_name TEXT;
  v_version_number INTEGER;
BEGIN
  SELECT * INTO v_lesson FROM lessons WHERE id = p_lesson_id;
  
  IF v_lesson.id IS NULL THEN
    RAISE EXCEPTION 'Lesson not found: %', p_lesson_id;
  END IF;
  
  IF v_lesson.applied_to_directives THEN
    RAISE EXCEPTION 'Lesson already promoted to directive: %', v_lesson.directive_id;
  END IF;

  -- Generate directive name
  v_directive_name := 'learned_' || COALESCE(REPLACE(LOWER(v_lesson.category), ' ', '_'), 'general') || '_' || SUBSTRING(v_lesson.id::text, 1, 8);

  -- Check if a directive with the same category pattern already exists
  SELECT id INTO v_existing_directive_id
  FROM system_directives
  WHERE name LIKE 'learned_' || COALESCE(REPLACE(LOWER(v_lesson.category), ' ', '_'), 'general') || '%'
    AND active = true
  ORDER BY created_at DESC
  LIMIT 1;

  IF v_existing_directive_id IS NOT NULL THEN
    -- Version the existing directive before updating
    SELECT COALESCE(MAX(version_number), 0) + 1 INTO v_version_number
    FROM directive_versions WHERE directive_id = v_existing_directive_id;

    INSERT INTO directive_versions (
      directive_id, version_number, previous_content, new_content,
      previous_enforcement, new_enforcement, change_reason, changed_by, lesson_id
    )
    SELECT 
      v_existing_directive_id, v_version_number, content,
      v_lesson.rule || E'\n\nLearned from: ' || v_lesson.pattern,
      enforcement, p_enforcement,
      'Auto-promoted from lesson ' || p_lesson_id,
      p_promoted_by, p_lesson_id
    FROM system_directives WHERE id = v_existing_directive_id;

    -- Update existing directive with new content (append, don't replace)
    UPDATE system_directives SET
      content = content || E'\n\n[v' || v_version_number || '] ' || v_lesson.rule,
      enforcement = CASE WHEN p_enforcement = 'hard' THEN 'hard' ELSE enforcement END,
      priority = GREATEST(priority, p_priority),
      updated_at = now()
    WHERE id = v_existing_directive_id;

    v_directive_id := v_existing_directive_id;
  ELSE
    -- Create new directive
    INSERT INTO system_directives (
      scope, directive_type, name, content, enforcement, priority, active
    ) VALUES (
      'global', p_directive_type, v_directive_name,
      v_lesson.rule || E'\n\nLearned from: ' || v_lesson.pattern,
      p_enforcement, p_priority, true
    ) RETURNING id INTO v_directive_id;

    -- Create version 1 record
    INSERT INTO directive_versions (
      directive_id, version_number, new_content, new_enforcement,
      change_reason, changed_by, lesson_id
    ) VALUES (
      v_directive_id, 1,
      v_lesson.rule || E'\n\nLearned from: ' || v_lesson.pattern,
      p_enforcement,
      'Initial creation from lesson ' || p_lesson_id,
      p_promoted_by, p_lesson_id
    );
  END IF;
  
  -- Mark lesson as promoted
  UPDATE lessons SET
    applied_to_directives = true,
    directive_id = v_directive_id,
    promoted_at = now(),
    promoted_by = p_promoted_by,
    updated_at = now()
  WHERE id = p_lesson_id;

  -- Audit log
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
  VALUES (
    'lesson_promoted',
    'system',
    p_promoted_by,
    'directive',
    v_directive_id,
    'promote',
    jsonb_build_object(
      'lesson_id', p_lesson_id,
      'directive_type', p_directive_type,
      'enforcement', p_enforcement,
      'category', v_lesson.category,
      'severity', v_lesson.severity,
      'is_update', v_existing_directive_id IS NOT NULL
    )
  );
  
  RETURN v_directive_id;
END;
$$;


--
-- Name: qa_review(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.qa_review(p_work_order_id uuid, p_agent_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo RECORD;
  v_qa_agent_id UUID;
  v_pass_count INT := 0;
  v_fail_count INT := 0;
  v_warning_count INT := 0;
  v_checklist_item jsonb;
  v_checklist_pass INT := 0;
  v_checklist_fail INT := 0;
  v_checklist_na INT := 0;
  v_checklist_pending INT := 0;
  v_result jsonb;
  v_item_count INT := 0;
  v_per_item_verdicts jsonb := '[]'::jsonb;
  v_verdict TEXT;
BEGIN
  IF p_agent_id IS NULL THEN
    SELECT id INTO v_qa_agent_id FROM agents WHERE name = 'qa-gate' LIMIT 1;
  ELSE
    v_qa_agent_id := p_agent_id;
  END IF;

  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Work order not found: %', p_work_order_id;
  END IF;

  -- Clear previous qa_review findings to avoid duplicates on re-run
  DELETE FROM qa_findings 
  WHERE work_order_id = p_work_order_id 
    AND category = 'acceptance_criterion';

  -- ITERATE EACH CHECKLIST ITEM AND CREATE PER-ITEM FINDINGS
  IF v_wo.qa_checklist IS NOT NULL AND jsonb_array_length(v_wo.qa_checklist) > 0 THEN
    FOR v_checklist_item IN SELECT * FROM jsonb_array_elements(v_wo.qa_checklist)
    LOOP
      v_item_count := v_item_count + 1;
      
      CASE v_checklist_item->>'status'
        WHEN 'pass' THEN 
          v_checklist_pass := v_checklist_pass + 1;
          INSERT INTO qa_findings (work_order_id, finding_type, category, description, evidence, agent_id, checklist_item_id)
          VALUES (
            p_work_order_id, 'pass', 'acceptance_criterion',
            COALESCE(v_checklist_item->>'criterion', 'Acceptance criterion'),
            jsonb_build_object('item', v_checklist_item, 'status', 'pass'),
            v_qa_agent_id, v_checklist_item->>'id'
          );
          v_pass_count := v_pass_count + 1;
          
        WHEN 'fail' THEN 
          v_checklist_fail := v_checklist_fail + 1;
          INSERT INTO qa_findings (work_order_id, finding_type, category, description, evidence, agent_id, checklist_item_id)
          VALUES (
            p_work_order_id, 'fail', 'acceptance_criterion',
            format('FAILED: %s', COALESCE(v_checklist_item->>'criterion', 'Acceptance criterion')),
            jsonb_build_object('item', v_checklist_item, 'status', 'fail'),
            v_qa_agent_id, v_checklist_item->>'id'
          );
          v_fail_count := v_fail_count + 1;
          
        WHEN 'na' THEN 
          v_checklist_na := v_checklist_na + 1;
          INSERT INTO qa_findings (work_order_id, finding_type, category, description, evidence, agent_id, checklist_item_id)
          VALUES (
            p_work_order_id, 'info', 'acceptance_criterion',
            format('N/A: %s', COALESCE(v_checklist_item->>'criterion', 'Acceptance criterion')),
            jsonb_build_object('item', v_checklist_item, 'status', 'na'),
            v_qa_agent_id, v_checklist_item->>'id'
          );
          
        ELSE 
          -- WO-0249: PENDING items are WARNINGS, not failures
          -- Pending = "not yet evaluated by auto-QA", not "evaluated and failed"
          v_checklist_pending := v_checklist_pending + 1;
          INSERT INTO qa_findings (work_order_id, finding_type, category, description, evidence, agent_id, checklist_item_id)
          VALUES (
            p_work_order_id, 'warning', 'acceptance_criterion',
            format('PENDING: %s', COALESCE(v_checklist_item->>'criterion', 'Acceptance criterion')),
            jsonb_build_object('item', v_checklist_item, 'status', 'pending'),
            v_qa_agent_id, v_checklist_item->>'id'
          );
          v_warning_count := v_warning_count + 1;
      END CASE;
      
      v_per_item_verdicts := v_per_item_verdicts || jsonb_build_object(
        'id', v_checklist_item->>'id',
        'criterion', v_checklist_item->>'criterion',
        'status', COALESCE(v_checklist_item->>'status', 'pending')
      );
    END LOOP;
  ELSE
    INSERT INTO qa_findings (work_order_id, finding_type, category, description, evidence, agent_id)
    VALUES (p_work_order_id, 'warning', 'qa_checklist', 'No checklist found', '{}'::jsonb, v_qa_agent_id);
    v_warning_count := v_warning_count + 1;
  END IF;

  -- EXISTING CHECKS
  IF EXISTS (SELECT 1 FROM state_mutations WHERE work_order_id = p_work_order_id) THEN
    INSERT INTO qa_findings (work_order_id, finding_type, category, description, evidence, agent_id)
    VALUES (p_work_order_id, 'pass', 'state_consistency', 
      format('%s mutations', (SELECT COUNT(*) FROM state_mutations WHERE work_order_id = p_work_order_id)),
      jsonb_build_object('count', (SELECT COUNT(*) FROM state_mutations WHERE work_order_id = p_work_order_id)),
      v_qa_agent_id);
    v_pass_count := v_pass_count + 1;
  ELSE
    INSERT INTO qa_findings (work_order_id, finding_type, category, description, evidence, agent_id)
    VALUES (p_work_order_id, 'warning', 'state_consistency', 'No mutations', '{}'::jsonb, v_qa_agent_id);
    v_warning_count := v_warning_count + 1;
  END IF;

  IF EXISTS (SELECT 1 FROM work_order_execution_log WHERE work_order_id = p_work_order_id) THEN
    INSERT INTO qa_findings (work_order_id, finding_type, category, description, evidence, agent_id)
    VALUES (p_work_order_id, 'pass', 'execution_trail', 'Execution logged',
      (SELECT jsonb_agg(jsonb_build_object('phase', phase)) FROM work_order_execution_log WHERE work_order_id = p_work_order_id LIMIT 10),
      v_qa_agent_id);
    v_pass_count := v_pass_count + 1;
  ELSE
    INSERT INTO qa_findings (work_order_id, finding_type, category, description, evidence, agent_id)
    VALUES (p_work_order_id, 'warning', 'execution_trail', 'No execution log', '{}'::jsonb, v_qa_agent_id);
    v_warning_count := v_warning_count + 1;
  END IF;

  IF v_wo.summary IS NOT NULL THEN
    INSERT INTO qa_findings (work_order_id, finding_type, category, description, evidence, agent_id)
    VALUES (p_work_order_id, 'pass', 'completion_summary', 'Summary provided', '{}'::jsonb, v_qa_agent_id);
    v_pass_count := v_pass_count + 1;
  ELSE
    INSERT INTO qa_findings (work_order_id, finding_type, category, description, evidence, agent_id)
    VALUES (p_work_order_id, 'warning', 'completion_summary', 'No summary', '{}'::jsonb, v_qa_agent_id);
    v_warning_count := v_warning_count + 1;
  END IF;

  -- WO-0249: Three-state verdict: PASS, FAIL, or PENDING
  IF v_fail_count > 0 THEN
    v_verdict := 'FAIL';
  ELSIF v_checklist_pending > 0 THEN
    v_verdict := 'PENDING';
  ELSE
    v_verdict := 'PASS';
  END IF;

  -- CONSENSUS VOTE
  INSERT INTO consensus_votes (work_order_id, agent_id, vote, reason, evidence)
  VALUES (
    p_work_order_id, v_qa_agent_id,
    CASE WHEN v_verdict = 'PASS' THEN 'approve' 
         WHEN v_verdict = 'PENDING' THEN 'abstain'
         ELSE 'reject' END,
    format('QA: %s pass, %s fail, %s warn, %s pending — verdict: %s', 
      v_pass_count, v_fail_count, v_warning_count, v_checklist_pending, v_verdict),
    jsonb_build_object('pass', v_pass_count, 'fail', v_fail_count, 'warn', v_warning_count, 'pending', v_checklist_pending, 'verdict', v_verdict)
  )
  ON CONFLICT (work_order_id, agent_id) 
  DO UPDATE SET vote = EXCLUDED.vote, reason = EXCLUDED.reason, evidence = EXCLUDED.evidence, created_at = now();

  v_result := jsonb_build_object(
    'work_order_id', p_work_order_id,
    'work_order_slug', v_wo.slug,
    'qa_agent_id', v_qa_agent_id,
    'pass_count', v_pass_count,
    'fail_count', v_fail_count,
    'warning_count', v_warning_count,
    'pending_count', v_checklist_pending,
    'verdict', v_verdict,
    'checklist_summary', jsonb_build_object(
      'pass', v_checklist_pass, 
      'fail', v_checklist_fail, 
      'na', v_checklist_na, 
      'pending', v_checklist_pending, 
      'total_items', v_item_count
    ),
    'per_item_verdicts', v_per_item_verdicts
  );

  INSERT INTO work_order_execution_log (work_order_id, phase, detail)
  VALUES (p_work_order_id, 'qa_review', v_result);

  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
  VALUES (
    'qa_review_completed', 'agent', v_qa_agent_id::text, 'work_order', p_work_order_id, 
    format('QA Review: %s', v_verdict),
    v_result
  );

  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION qa_review(p_work_order_id uuid, p_agent_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.qa_review(p_work_order_id uuid, p_agent_id uuid) IS 'Enhanced QA review with checklist validation. Enforces all qa_checklist items must be pass/fail/na. Emits to audit_log.';


--
-- Name: query_object_links(uuid, uuid, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.query_object_links(p_source_id uuid DEFAULT NULL::uuid, p_target_id uuid DEFAULT NULL::uuid, p_link_type text DEFAULT NULL::text, p_limit integer DEFAULT 100) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
    v_result JSONB;
    v_count BIGINT;
BEGIN
    -- Handle NULL limit
    IF p_limit IS NULL OR p_limit <= 0 THEN
        p_limit := 100;
    END IF;
    
    -- Calculate total count with filters
    SELECT count(*)::bigint INTO v_count
    FROM object_links ol
    WHERE (p_source_id IS NULL OR ol.source_id = p_source_id)
      AND (p_target_id IS NULL OR ol.target_id = p_target_id)
      AND (p_link_type IS NULL OR ol.link_type = p_link_type);
    
    -- Get limited links with joined data
    SELECT jsonb_agg(link ORDER BY link.source_name, link.target_name) INTO v_result
    FROM (
        SELECT ol.id, ol.source_id, ol.target_id, ol.link_type, ol.properties, ol.created_at,
               src.object_name AS source_name, src.object_type AS source_type,
               tgt.object_name AS target_name, tgt.object_type AS target_type
        FROM object_links ol
        JOIN object_registry src ON src.id = ol.source_id
        JOIN object_registry tgt ON tgt.id = ol.target_id
        WHERE (p_source_id IS NULL OR ol.source_id = p_source_id)
          AND (p_target_id IS NULL OR ol.target_id = p_target_id)
          AND (p_link_type IS NULL OR ol.link_type = p_link_type)
        ORDER BY ol.source_id, ol.target_id
        LIMIT p_limit
    ) link;
    
    -- Handle null case
    IF v_result IS NULL THEN
        v_result := '[]'::jsonb;
    END IF;
    
    RETURN jsonb_build_object(
        'links', v_result,
        'total_count', v_count
    );
END;
$$;


--
-- Name: query_object_registry(text, text, uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.query_object_registry(p_object_type text DEFAULT NULL::text, p_name_pattern text DEFAULT NULL::text, p_parent_id uuid DEFAULT NULL::uuid, p_limit integer DEFAULT 100) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
    v_result JSONB;
    v_count BIGINT;
BEGIN
    -- Handle NULL limit
    IF p_limit IS NULL OR p_limit <= 0 THEN
        p_limit := 100;
    END IF;
    
    -- Calculate total count with filters
    SELECT count(*)::bigint INTO v_count
    FROM object_registry
    WHERE (p_object_type IS NULL OR object_type = p_object_type)
      AND (p_name_pattern IS NULL OR object_name ILIKE '%' || p_name_pattern || '%')
      AND (p_parent_id IS NULL OR parent_id = p_parent_id);
    
    -- Get limited objects
    SELECT jsonb_agg(obj ORDER BY obj.object_name) INTO v_result
    FROM (
        SELECT id, object_type, object_name, parent_id, properties, valid_actions, 
               system_manifest_id, auto_populated, created_at
        FROM object_registry
        WHERE (p_object_type IS NULL OR object_type = p_object_type)
          AND (p_name_pattern IS NULL OR object_name ILIKE '%' || p_name_pattern || '%')
          AND (p_parent_id IS NULL OR parent_id = p_parent_id)
        ORDER BY object_name
        LIMIT p_limit
    ) obj;
    
    -- Handle null case
    IF v_result IS NULL THEN
        v_result := '[]'::jsonb;
    END IF;
    
    RETURN jsonb_build_object(
        'objects', v_result,
        'total_count', v_count
    );
END;
$$;


--
-- Name: reap_orphaned_spans(interval); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.reap_orphaned_spans(p_timeout_interval interval DEFAULT '00:05:00'::interval) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_reaped_count integer;
  v_reaped_ids uuid[];
BEGIN
  -- Collect IDs first for logging
  SELECT array_agg(id) INTO v_reaped_ids
  FROM spans
  WHERE status = 'running'
    AND ended_at IS NULL
    AND started_at < (now() - p_timeout_interval);

  IF v_reaped_ids IS NULL OR array_length(v_reaped_ids, 1) IS NULL THEN
    RETURN jsonb_build_object('reaped', 0, 'message', 'No orphaned spans found');
  END IF;

  -- Update orphaned spans
  UPDATE spans
  SET
    status = 'timeout',
    ended_at = now(),
    error_message = format('Reaped by span reaper: exceeded %s timeout (started_at=%s)', 
                           p_timeout_interval::text, started_at::text)
  WHERE id = ANY(v_reaped_ids);

  GET DIAGNOSTICS v_reaped_count = ROW_COUNT;

  -- Log to audit_log
  INSERT INTO audit_log (event_type, actor_type, actor_id, action, new_state)
  VALUES (
    'span_reaper', 'system', 'reap_orphaned_spans',
    format('Reaped %s orphaned spans', v_reaped_count),
    jsonb_build_object(
      'reaped_count', v_reaped_count,
      'span_ids', to_jsonb(v_reaped_ids),
      'timeout_interval', p_timeout_interval::text
    )
  );

  RETURN jsonb_build_object(
    'reaped', v_reaped_count,
    'span_ids', to_jsonb(v_reaped_ids)
  );
END;
$$;


--
-- Name: reassign_work_order(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.reassign_work_order(p_work_order_id uuid, p_agent_name text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_wo record;
  v_agent_id uuid;
  v_old_agent_name text;
  v_auth_key text;
  v_dispatched boolean := false;
  v_now timestamptz := now();
BEGIN
  -- Look up agent UUID from agents table by name
  SELECT id INTO v_agent_id 
  FROM agents 
  WHERE name = p_agent_name AND status = 'active';
  
  IF v_agent_id IS NULL THEN
    RAISE EXCEPTION 'Agent not found or inactive: %', p_agent_name;
  END IF;

  -- Get current WO state with lock
  SELECT * INTO v_wo 
  FROM work_orders 
  WHERE id = p_work_order_id 
  FOR UPDATE;
  
  IF v_wo IS NULL THEN
    RAISE EXCEPTION 'Work order not found: %', p_work_order_id;
  END IF;

  -- Get old agent name for logging
  SELECT name INTO v_old_agent_name
  FROM agents
  WHERE id = v_wo.assigned_to;

  -- Update work_orders.assigned_to (SECURITY DEFINER allows this)
  UPDATE work_orders 
  SET 
    assigned_to = v_agent_id,
    updated_at = v_now
  WHERE id = p_work_order_id;

  -- Log reassignment to execution_log
  INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
  VALUES (
    p_work_order_id,
    'stream',
    'system',
    jsonb_build_object(
      'event_type', 'reassigned',
      'old_agent', v_old_agent_name,
      'new_agent', p_agent_name,
      'status', v_wo.status
    )
  );

  -- If WO status is in_progress, auto-dispatch to wo-agent/execute
  IF v_wo.status = 'in_progress' AND p_agent_name != 'ilmarinen' THEN
    -- Get anon key from system_settings
    SELECT (setting_value#>>'{}')::text INTO v_auth_key
    FROM system_settings
    WHERE setting_key = 'supabase_anon_key';

    IF v_auth_key IS NOT NULL THEN
      PERFORM net.http_post(
        url := 'https://phfblljwuvzqzlbzkzpr.supabase.co/functions/v1/wo-agent/execute',
        headers := jsonb_build_object(
          'Content-Type', 'application/json',
          'Authorization', 'Bearer ' || v_auth_key,
      'apikey', v_auth_key
        ),
        body := jsonb_build_object(
          'work_order_id', p_work_order_id::text,
          'trigger', 'reassignment'
        )
      );
      v_dispatched := true;

      -- Log dispatch
      INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
      VALUES (
        p_work_order_id,
        'stream',
        'system',
        jsonb_build_object(
          'event_type', 'dispatched',
          'trigger', 'reassignment',
          'target_agent', p_agent_name
        )
      );
    END IF;
  END IF;

  -- Return result
  RETURN jsonb_build_object(
    'old_agent', v_old_agent_name,
    'new_agent', p_agent_name,
    'dispatched', v_dispatched,
    'work_order_id', p_work_order_id,
    'status', v_wo.status
  );
END;
$$;


--
-- Name: FUNCTION reassign_work_order(p_work_order_id uuid, p_agent_name text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.reassign_work_order(p_work_order_id uuid, p_agent_name text) IS 'WO-0555: Reassign work order to different agent. Auto-dispatches if status=in_progress and agent!=ilmarinen';


--
-- Name: recheck_auto_close_on_findings_resolved(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.recheck_auto_close_on_findings_resolved() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_wo record;
  v_item jsonb;
  v_all_pass boolean := true;
  v_has_items boolean := false;
  v_unresolved_fail_count int;
  v_transition_result jsonb;
BEGIN
  -- Only proceed if finding was just resolved (resolved_at changed from NULL to non-NULL)
  IF OLD.resolved_at IS NOT NULL OR NEW.resolved_at IS NULL THEN
    RETURN NEW;
  END IF;
  
  -- Load the work order with its checklist
  SELECT id, slug, status, qa_checklist, summary
  INTO v_wo
  FROM work_orders
  WHERE id = NEW.work_order_id;
  
  -- Only act on review WOs
  IF v_wo.status != 'review' THEN
    RETURN NEW;
  END IF;
  
  -- Must have a checklist
  IF v_wo.qa_checklist IS NULL OR jsonb_array_length(v_wo.qa_checklist) = 0 THEN
    RETURN NEW;
  END IF;
  
  -- Check all checklist items are pass or na
  FOR v_item IN SELECT * FROM jsonb_array_elements(v_wo.qa_checklist)
  LOOP
    v_has_items := true;
    IF v_item->>'status' NOT IN ('pass', 'na') THEN
      v_all_pass := false;
      EXIT;
    END IF;
  END LOOP;
  
  -- If not all pass, exit
  IF NOT (v_has_items AND v_all_pass) THEN
    RETURN NEW;
  END IF;
  
  -- Count remaining unresolved fail findings (excluding the one we just resolved)
  SELECT COUNT(*)
  INTO v_unresolved_fail_count
  FROM qa_findings
  WHERE work_order_id = v_wo.id
    AND finding_type = 'fail'
    AND resolved_at IS NULL
    AND id != NEW.id;
  
  -- If there are still fail findings, exit
  IF v_unresolved_fail_count > 0 THEN
    RETURN NEW;
  END IF;
  
  -- All conditions met: auto-close the WO using update_work_order_state RPC
  -- (The RPC handles bypass and enforcement checks internally)
  SELECT update_work_order_state(
    p_work_order_id := v_wo.id,
    p_status := 'done',
    p_completed_at := NOW(),
    p_summary := COALESCE(NULLIF(v_wo.summary, ''), 'Auto-closed: all QA checklist items passed after findings resolved')
  ) INTO v_transition_result;
  
  -- Log the auto-close
  INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
  VALUES (
    v_wo.id,
    'execution_complete',
    'qa-gate',
    jsonb_build_object(
      'event_type', 'auto_close_qa_pass',
      'message', format('Auto-closed %s: all %s checklist items passed, last fail finding resolved', v_wo.slug, jsonb_array_length(v_wo.qa_checklist)),
      'trigger', 'recheck_auto_close_on_findings_resolved',
      'checklist_items', jsonb_array_length(v_wo.qa_checklist),
      'rpc_result', v_transition_result
    )
  );
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION recheck_auto_close_on_findings_resolved(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.recheck_auto_close_on_findings_resolved() IS 'Trigger function to re-run auto-close check when fail findings are resolved.
Fixed WO-0470: Inlines auto-close logic directly instead of trying to re-fire trg_auto_close_review_on_qa_pass.
The auto-close trigger uses IS NOT DISTINCT FROM which prevents simple qa_checklist touch from working.';


--
-- Name: reconstruct_wo_state(uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.reconstruct_wo_state(p_stream_id uuid, p_up_to_version integer DEFAULT NULL::integer) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_event record;
  v_state jsonb := '{}'::jsonb;
BEGIN
  FOR v_event IN 
    SELECT * FROM wo_event_stream 
    WHERE stream_id = p_stream_id 
      AND (p_up_to_version IS NULL OR version <= p_up_to_version)
    ORDER BY version ASC
  LOOP
    -- Each event's state_after IS the state at that point
    v_state := v_event.state_after;
  END LOOP;

  IF v_state = '{}'::jsonb THEN
    RETURN jsonb_build_object('error', 'No events found for stream');
  END IF;

  RETURN v_state;
END;
$$;


--
-- Name: record_cli_mutation(uuid, text, text, text, text, boolean, text, jsonb, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_cli_mutation(p_work_order_id uuid, p_tool_name text, p_object_type text, p_object_id text, p_action text, p_success boolean, p_error_detail text, p_context jsonb, p_agent_name text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_id uuid;
BEGIN
  INSERT INTO wo_mutations (
    work_order_id,
    tool_name,
    object_type,
    object_id,
    action,
    success,
    error_detail,
    context,
    agent_name,
    created_at
  ) VALUES (
    p_work_order_id,
    p_tool_name,
    p_object_type,
    p_object_id,
    p_action,
    p_success,
    p_error_detail,
    p_context,
    p_agent_name,
    NOW()
  )
  RETURNING id INTO v_id;
  
  RETURN v_id;
END;
$$;


--
-- Name: record_cli_mutation(uuid, text, text, text, text, boolean, text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_cli_mutation(p_work_order_id uuid, p_tool_name text, p_object_type text, p_object_id text, p_action text, p_success boolean, p_agent_name text, p_error_detail text DEFAULT NULL::text, p_context jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_id uuid;
BEGIN
  INSERT INTO wo_mutations (
    work_order_id,
    tool_name,
    object_type,
    object_id,
    action,
    success,
    error_detail,
    context,
    agent_name,
    created_at
  ) VALUES (
    p_work_order_id,
    p_tool_name,
    p_object_type,
    p_object_id,
    p_action,
    p_success,
    p_error_detail,
    p_context,
    p_agent_name,
    NOW()
  )
  RETURNING id INTO v_id;
  
  RETURN v_id;
END;
$$;


--
-- Name: record_interaction_outcome(text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_interaction_outcome(p_interaction_name text, p_outcome text, p_context jsonb DEFAULT '{}'::jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO interaction_log (interaction_name, outcome, context)
  VALUES (p_interaction_name, p_outcome, p_context);
END;
$$;


--
-- Name: FUNCTION record_interaction_outcome(p_interaction_name text, p_outcome text, p_context jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.record_interaction_outcome(p_interaction_name text, p_outcome text, p_context jsonb) IS 'Logs the outcome of an interaction to interaction_log table.
Parameters: interaction_name (must exist in interaction_definitions), outcome (success/failure/blocked/warned), context (JSONB with relevant details)';


--
-- Name: record_mutation(uuid, text, text, text, text, boolean, text, text, text, boolean, jsonb, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_mutation(p_work_order_id uuid, p_tool_name text, p_object_type text, p_object_id text, p_action text, p_success boolean, p_error_class text DEFAULT NULL::text, p_error_detail text DEFAULT NULL::text, p_verification_query text DEFAULT NULL::text, p_verified boolean DEFAULT false, p_context jsonb DEFAULT '{}'::jsonb, p_agent_name text DEFAULT 'unknown'::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
DECLARE
  v_new_id uuid;
BEGIN
  -- Skip recording SELECT queries - they are reads, not mutations
  IF p_tool_name = 'execute_sql' AND upper(left(trim(p_object_id), 6)) = 'SELECT' THEN
    RETURN NULL;
  END IF;

  INSERT INTO wo_mutations (
    work_order_id,
    tool_name,
    object_type,
    object_id,
    action,
    success,
    error_class,
    error_detail,
    verification_query,
    verified,
    context,
    agent_name
  ) VALUES (
    p_work_order_id,
    p_tool_name,
    p_object_type,
    p_object_id,
    p_action,
    p_success,
    p_error_class,
    p_error_detail,
    p_verification_query,
    p_verified,
    p_context,
    p_agent_name
  ) RETURNING id INTO v_new_id;
  
  RETURN v_new_id;
END;
$$;


--
-- Name: record_verification(uuid, text, jsonb, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_verification(p_work_order_id uuid, p_verification_type text, p_evidence jsonb, p_passed boolean) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_wo_record work_orders;
  v_new_verification_status TEXT;
  v_log_id UUID;
BEGIN
  -- Get the work order record
  SELECT * INTO v_wo_record FROM work_orders WHERE id = p_work_order_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Work order not found'
    );
  END IF;

  -- Determine new verification status
  IF p_passed THEN
    v_new_verification_status := 'verified';
  ELSE
    v_new_verification_status := 'failed';
  END IF;

  -- Insert into verification_log
  INSERT INTO verification_log (work_order_id, verified_by, verification_type, evidence, passed)
  VALUES (p_work_order_id, current_user, p_verification_type, p_evidence, p_passed)
  RETURNING id INTO v_log_id;

  -- Update work_orders verification_status
  UPDATE work_orders 
  SET verification_status = v_new_verification_status,
      updated_at = now()
  WHERE id = p_work_order_id;

  -- Insert audit_log entry
  INSERT INTO audit_log (
    event_type, 
    actor_type, 
    actor_id, 
    target_type, 
    target_id, 
    action, 
    payload, 
    previous_state, 
    new_state
  )
  VALUES (
    'verification_recorded',
    'system',
    'record_verification',
    'work_order',
    p_work_order_id,
    format('Verification: %s', p_verification_type),
    jsonb_build_object(
      'wo_slug', v_wo_record.slug,
      'verification_type', p_verification_type,
      'passed', p_passed,
      'verification_log_id', v_log_id,
      'evidence', p_evidence
    ),
    jsonb_build_object('verification_status', v_wo_record.verification_status),
    jsonb_build_object('verification_status', v_new_verification_status)
  );

  RETURN jsonb_build_object(
    'success', true,
    'verification_log_id', v_log_id,
    'new_verification_status', v_new_verification_status
  );
END;
$$;


--
-- Name: record_verification(uuid, text, text, boolean, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_verification(p_work_order_id uuid, p_verified_by text, p_verification_type text, p_passed boolean, p_evidence jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
DECLARE
  v_log_id UUID;
  v_wo work_orders%ROWTYPE;
  v_new_status TEXT;
BEGIN
  -- Fix ADV-002: Validate input - reject empty strings
  IF p_verified_by IS NULL OR trim(p_verified_by) = '' THEN
    RETURN jsonb_build_object('error', 'verified_by cannot be empty');
  END IF;
  
  IF p_verification_type IS NULL OR trim(p_verification_type) = '' THEN
    RETURN jsonb_build_object('error', 'verification_type cannot be empty');
  END IF;

  -- Validate WO exists
  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  IF NOT FOUND THEN
    RETURN jsonb_build_object('error', 'Work order not found');
  END IF;

  -- Insert verification log entry
  INSERT INTO verification_log (work_order_id, verified_by, verification_type, evidence, passed)
  VALUES (p_work_order_id, p_verified_by, p_verification_type, p_evidence, p_passed)
  RETURNING id INTO v_log_id;

  -- Update verification_status on the work order
  IF p_passed THEN
    v_new_status := 'verified';
  ELSE
    v_new_status := 'failed';
  END IF;

  UPDATE work_orders 
  SET verification_status = v_new_status
  WHERE id = p_work_order_id;

  -- Audit log
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload, previous_state, new_state)
  VALUES (
    'verification_recorded', 'agent', p_verified_by,
    'work_order', p_work_order_id,
    format('verification_%s', CASE WHEN p_passed THEN 'passed' ELSE 'failed' END),
    jsonb_build_object(
      'wo_slug', v_wo.slug,
      'verification_type', p_verification_type,
      'passed', p_passed,
      'log_id', v_log_id
    ),
    jsonb_build_object('verification_status', v_wo.verification_status),
    jsonb_build_object('verification_status', v_new_status)
  );

  RETURN jsonb_build_object(
    'success', true,
    'log_id', v_log_id,
    'verification_status', v_new_status,
    'wo_slug', v_wo.slug
  );
END;
$$;


--
-- Name: record_verification(uuid, text, text, jsonb, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_verification(p_work_order_id uuid, p_verified_by text, p_verification_type text, p_evidence jsonb, p_passed boolean) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_log_id UUID;
  v_wo work_orders%ROWTYPE;
  v_new_status TEXT;
BEGIN
  -- Validate WO exists
  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  IF NOT FOUND THEN
    RETURN jsonb_build_object('error', 'Work order not found');
  END IF;

  -- Insert verification log entry
  INSERT INTO verification_log (work_order_id, verified_by, verification_type, evidence, passed)
  VALUES (p_work_order_id, p_verified_by, p_verification_type, p_evidence, p_passed)
  RETURNING id INTO v_log_id;

  -- Update verification_status on the work order
  IF p_passed THEN
    v_new_status := 'verified';
  ELSE
    v_new_status := 'failed';
  END IF;

  UPDATE work_orders 
  SET verification_status = v_new_status
  WHERE id = p_work_order_id;

  -- Audit log
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload, previous_state, new_state)
  VALUES (
    'verification_recorded', 'agent', p_verified_by,
    'work_order', p_work_order_id,
    format('verification_%s', CASE WHEN p_passed THEN 'passed' ELSE 'failed' END),
    jsonb_build_object(
      'wo_slug', v_wo.slug,
      'verification_type', p_verification_type,
      'passed', p_passed,
      'log_id', v_log_id
    ),
    jsonb_build_object('verification_status', v_wo.verification_status),
    jsonb_build_object('verification_status', v_new_status)
  );

  RETURN jsonb_build_object(
    'success', true,
    'log_id', v_log_id,
    'verification_status', v_new_status,
    'wo_slug', v_wo.slug
  );
END;
$$;


--
-- Name: refresh_action_rates(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.refresh_action_rates() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY object_action_rates;
    REFRESH MATERIALIZED VIEW CONCURRENTLY action_type_rates;
END;
$$;


--
-- Name: regenerate_architecture_docs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.regenerate_architecture_docs(p_project_id uuid DEFAULT '7558abf4-78d4-4ca2-a4dd-457f5b061e25'::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_doc TEXT := '';
  v_row RECORD;
  v_count INT;
  v_doc_id UUID;
  v_now TIMESTAMPTZ := now();
BEGIN
  v_doc := '# ENDGAME-001 System Architecture' || E'\n';
  v_doc := v_doc || '**Auto-generated**: ' || to_char(v_now, 'YYYY-MM-DD HH24:MI:SS UTC') || E'\n\n';

  -- TABLES
  v_doc := v_doc || '## Tables' || E'\n\n';
  SELECT count(*) INTO v_count FROM pg_tables WHERE schemaname = 'public';
  v_doc := v_doc || 'Total: ' || v_count || E'\n\n';
  v_doc := v_doc || '| Table | Columns | RLS |' || E'\n' || '|-------|---------|-----|' || E'\n';
  FOR v_row IN
    SELECT t.tablename,
      (SELECT count(*) FROM information_schema.columns c WHERE c.table_schema='public' AND c.table_name=t.tablename) as col_count,
      t.rowsecurity
    FROM pg_tables t WHERE t.schemaname='public' ORDER BY t.tablename
  LOOP
    v_doc := v_doc || '| ' || v_row.tablename || ' | ' || v_row.col_count || ' | ' || 
      CASE WHEN v_row.rowsecurity THEN 'Yes' ELSE 'No' END || ' |' || E'\n';
  END LOOP;

  -- EDGE FUNCTIONS
  v_doc := v_doc || E'\n## Edge Functions' || E'\n\n';
  v_doc := v_doc || '| Name | Version | Description |' || E'\n' || '|------|---------|-------------|' || E'\n';
  FOR v_row IN
    SELECT name, coalesce(config->>'version','N/A') as ver, coalesce(substring(description from 1 for 120),'') as d
    FROM system_manifest WHERE component_type='edge_function' AND status='active' ORDER BY name
  LOOP
    v_doc := v_doc || '| ' || v_row.name || ' | ' || v_row.ver || ' | ' || v_row.d || ' |' || E'\n';
  END LOOP;

  -- RPC FUNCTIONS
  v_doc := v_doc || E'\n## RPC Functions' || E'\n\n';
  SELECT count(*) INTO v_count FROM system_manifest WHERE component_type='rpc_function' AND status='active';
  v_doc := v_doc || 'Total: ' || v_count || E'\n\n';
  v_doc := v_doc || '| Name | Purpose |' || E'\n' || '|------|---------|' || E'\n';
  FOR v_row IN
    SELECT name, coalesce(substring(purpose from 1 for 150), coalesce(substring(description from 1 for 150),'')) as p
    FROM system_manifest WHERE component_type='rpc_function' AND status='active' ORDER BY name
  LOOP
    v_doc := v_doc || '| ' || v_row.name || ' | ' || v_row.p || ' |' || E'\n';
  END LOOP;

  -- TRIGGERS
  v_doc := v_doc || E'\n## Triggers' || E'\n\n';
  FOR v_row IN
    SELECT name, coalesce(substring(description from 1 for 150),'') as d
    FROM system_manifest WHERE component_type='trigger' AND status='active' ORDER BY name
  LOOP
    v_doc := v_doc || '- **' || v_row.name || '**: ' || v_row.d || E'\n';
  END LOOP;

  -- VIEWS
  v_doc := v_doc || E'\n## Views' || E'\n\n';
  FOR v_row IN
    SELECT name, coalesce(substring(description from 1 for 150),'') as d
    FROM system_manifest WHERE component_type='view' AND status='active' ORDER BY name
  LOOP
    v_doc := v_doc || '- **' || v_row.name || '**: ' || v_row.d || E'\n';
  END LOOP;

  -- ENUMS
  v_doc := v_doc || E'\n## Enums' || E'\n\n';
  FOR v_row IN
    SELECT t.typname, string_agg(e.enumlabel, ', ' ORDER BY e.enumsortorder) as vals
    FROM pg_type t JOIN pg_enum e ON t.oid=e.enumtypid
    WHERE t.typnamespace='public'::regnamespace GROUP BY t.typname ORDER BY t.typname
  LOOP
    v_doc := v_doc || '- **' || v_row.typname || '**: ' || v_row.vals || E'\n';
  END LOOP;

  -- RECENT CHANGES
  v_doc := v_doc || E'\n## Recent Schema Changes (30d)' || E'\n\n';
  FOR v_row IN
    SELECT change_type, object_name, object_type, substring(reason from 1 for 200) as reason, created_at
    FROM schema_changes WHERE created_at > v_now - interval '30 days' ORDER BY created_at DESC LIMIT 20
  LOOP
    v_doc := v_doc || '- [' || to_char(v_row.created_at, 'YYYY-MM-DD') || '] ' || 
      coalesce(v_row.change_type,'') || ' ' || coalesce(v_row.object_type,'') || ' ' || 
      coalesce(v_row.object_name,'') || ': ' || coalesce(v_row.reason,'') || E'\n';
  END LOOP;

  -- DECISION GATES
  v_doc := v_doc || E'\n## Decision Gates' || E'\n\n';
  FOR v_row IN
    SELECT name, trigger_type, coalesce(substring(description from 1 for 150),'') as d
    FROM decision_gates WHERE active=true ORDER BY name
  LOOP
    v_doc := v_doc || '- **' || v_row.name || '** (' || v_row.trigger_type || '): ' || v_row.d || E'\n';
  END LOOP;

  -- STATS
  v_doc := v_doc || E'\n## System Stats' || E'\n\n';
  v_doc := v_doc || '- Tables: ' || (SELECT count(*) FROM pg_tables WHERE schemaname='public') || E'\n';
  v_doc := v_doc || '- Manifest entries: ' || (SELECT count(*) FROM system_manifest WHERE status='active') || E'\n';
  v_doc := v_doc || '- Lessons: ' || (SELECT count(*) FROM lessons) || E'\n';
  v_doc := v_doc || '- Active directives: ' || (SELECT count(*) FROM directives WHERE active=true) || E'\n';
  v_doc := v_doc || '- Work orders (total/done): ' || (SELECT count(*) FROM work_orders) || '/' || (SELECT count(*) FROM work_orders WHERE status='done') || E'\n';

  -- Upsert
  SELECT id INTO v_doc_id FROM project_documents 
    WHERE project_id=p_project_id AND doc_type='architecture' AND title='ENDGAME-001 Architecture' LIMIT 1;
  IF v_doc_id IS NOT NULL THEN
    UPDATE project_documents SET content=v_doc, version=version+1, status='generated',
      updated_by='regenerate_architecture_docs', updated_at=v_now WHERE id=v_doc_id;
  ELSE
    INSERT INTO project_documents (project_id,doc_type,title,content,version,status,created_by,updated_by,created_at,updated_at)
    VALUES (p_project_id,'architecture','ENDGAME-001 Architecture',v_doc,1,'generated','regenerate_architecture_docs','regenerate_architecture_docs',v_now,v_now)
    RETURNING id INTO v_doc_id;
  END IF;

  RETURN jsonb_build_object('success',true,'doc_id',v_doc_id,'doc_length',length(v_doc),'generated_at',v_now);
END;
$$;


--
-- Name: register_edge_function(text, uuid, integer, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.register_edge_function(p_function_name text, p_function_id uuid DEFAULT NULL::uuid, p_version integer DEFAULT 1, p_description text DEFAULT NULL::text, p_work_order_slug text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_manifest_id UUID;
  v_current_version INTEGER;
  v_mutation_id UUID;
  v_payload JSONB;
  v_wo_id UUID;
BEGIN
  -- Get work order UUID if slug provided
  IF p_work_order_slug IS NOT NULL THEN
    SELECT id INTO v_wo_id 
    FROM work_orders 
    WHERE slug = p_work_order_slug 
    LIMIT 1;
  END IF;

  -- Check if function already exists in manifest
  SELECT id, version INTO v_manifest_id, v_current_version
  FROM system_manifest
  WHERE component_type = 'edge_function'
    AND name = p_function_name;

  IF v_manifest_id IS NOT NULL THEN
    -- Update existing entry via state_write
    v_payload := jsonb_build_object(
      'id', v_manifest_id,
      'version', GREATEST(COALESCE(v_current_version, 0), p_version),
      'updated_at', NOW(),
      'last_modified_wo', COALESCE(p_work_order_slug, 'auto-register'),
      'description', COALESCE(p_description, (SELECT description FROM system_manifest WHERE id = v_manifest_id)),
      'config', jsonb_build_object('function_id', p_function_id)
    );

    v_mutation_id := state_write(
      p_mutation_type := 'UPDATE',
      p_target_table := 'system_manifest',
      p_payload := v_payload,
      p_work_order_id := v_wo_id
    );
    
    RETURN v_manifest_id;
  ELSE
    -- Insert new entry via state_write
    v_manifest_id := gen_random_uuid();
    
    v_payload := jsonb_build_object(
      'id', v_manifest_id,
      'component_type', 'edge_function',
      'name', p_function_name,
      'description', COALESCE(p_description, 'Auto-registered edge function'),
      'purpose', 'Edge function deployed to Supabase',
      'version', p_version,
      'status', 'active',
      'created_by_wo', COALESCE(p_work_order_slug, 'auto-register'),
      'last_modified_wo', COALESCE(p_work_order_slug, 'auto-register'),
      'config', jsonb_build_object('function_id', p_function_id)
    );

    v_mutation_id := state_write(
      p_mutation_type := 'INSERT',
      p_target_table := 'system_manifest',
      p_payload := v_payload,
      p_work_order_id := v_wo_id
    );
    
    RETURN v_manifest_id;
  END IF;
END;
$$;


--
-- Name: FUNCTION register_edge_function(p_function_name text, p_function_id uuid, p_version integer, p_description text, p_work_order_slug text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.register_edge_function(p_function_name text, p_function_id uuid, p_version integer, p_description text, p_work_order_slug text) IS 'Auto-registers or updates edge function in system_manifest via state_write(). Called after deployments to maintain manifest accuracy.';


--
-- Name: release_file_locks(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.release_file_locks(p_wo_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  UPDATE wo_file_locks
  SET released_at = now()
  WHERE work_order_id = p_wo_id AND released_at IS NULL;
END;
$$;


--
-- Name: release_lock(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.release_lock(p_agent_name text, p_resource_type text, p_resource_id text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_agent_id UUID;
  v_deleted INT;
BEGIN
  SELECT id INTO v_agent_id FROM agents WHERE name = p_agent_name;
  IF v_agent_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Agent not found');
  END IF;
  
  DELETE FROM workspace_locks 
  WHERE resource_type = p_resource_type 
    AND resource_id = p_resource_id 
    AND agent_id = v_agent_id;
  
  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  
  RETURN jsonb_build_object('success', true, 'released', v_deleted > 0);
END;
$$;


--
-- Name: release_locks_on_wo_done(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.release_locks_on_wo_done() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.status IN ('done', 'failed', 'cancelled') AND OLD.status != NEW.status THEN
    PERFORM release_file_locks(NEW.id);
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: request_approval(uuid, text, text, jsonb, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.request_approval(p_work_order_id uuid, p_request_type text, p_summary text, p_detail jsonb, p_requested_by text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_gate RECORD;
  v_approval_id UUID;
  v_context JSONB;
  v_wo RECORD;
BEGIN
  -- Get work order context
  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  
  v_context := jsonb_build_object(
    'priority', v_wo.priority,
    'cost_usd', COALESCE(v_wo.estimated_cost_usd, 0)
  ) || COALESCE(p_detail, '{}'::jsonb);
  
  -- Check gate
  SELECT * INTO v_gate FROM check_decision_gate(p_request_type, v_context);
  
  IF NOT v_gate.needs_approval THEN
    -- Auto-approved
    INSERT INTO approval_queue (
      gate_id, work_order_id, request_type, request_summary, request_detail,
      status, requested_by, decided_by, decided_at, decision_notes
    ) VALUES (
      v_gate.gate_id, p_work_order_id, p_request_type, p_summary, p_detail,
      'auto_approved', p_requested_by, 'auto', now(), v_gate.reason
    ) RETURNING id INTO v_approval_id;
    
    RETURN v_approval_id;
  END IF;
  
  -- Needs approval - queue it
  INSERT INTO approval_queue (
    gate_id, work_order_id, request_type, request_summary, request_detail,
    status, requested_by
  ) VALUES (
    v_gate.gate_id, p_work_order_id, p_request_type, p_summary, p_detail,
    'pending', p_requested_by
  ) RETURNING id INTO v_approval_id;
  
  RETURN v_approval_id;
END;
$$;


--
-- Name: resolve_pipeline_agent(jsonb, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.resolve_pipeline_agent(p_config jsonb, p_phase_key text, p_phase_default text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_agent text;
BEGIN
    -- 1. Phase-specific override from pipeline config
    v_agent := p_config->'agents'->>p_phase_key;
    IF v_agent IS NOT NULL AND v_agent != '' THEN RETURN v_agent; END IF;
    
    -- 2. Phase-specific built-in default (e.g., 'security' for harden_red)
    IF p_phase_default IS NOT NULL THEN RETURN p_phase_default; END IF;
    
    -- 3. Pipeline-wide default from config
    v_agent := p_config->>'default_agent';
    IF v_agent IS NOT NULL AND v_agent != '' THEN RETURN v_agent; END IF;
    
    -- 4. System-wide default from decision_gates (first non-human work_order_execute assignee)
    SELECT default_assignee INTO v_agent 
    FROM decision_gates 
    WHERE active = true 
      AND trigger_type = 'work_order_execute' 
      AND default_assignee != 'human'
    ORDER BY name LIMIT 1;
    
    RETURN COALESCE(v_agent, 'builder');
END;
$$;


--
-- Name: resolve_qa_findings(uuid, uuid[], text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.resolve_qa_findings(p_work_order_id uuid, p_finding_ids uuid[], p_resolved_by text, p_resolution_notes text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_resolved_count INT := 0;
  v_finding_id UUID;
  v_result jsonb;
BEGIN
  -- Validate work order exists
  IF NOT EXISTS (SELECT 1 FROM work_orders WHERE id = p_work_order_id) THEN
    RAISE EXCEPTION 'Work order not found: %', p_work_order_id;
  END IF;

  -- Resolve each finding
  FOREACH v_finding_id IN ARRAY p_finding_ids
  LOOP
    UPDATE qa_findings
    SET 
      resolved_at = now(),
      reviewed_by = (SELECT id FROM agents WHERE name = 'qa' LIMIT 1),
      evidence = CASE 
        WHEN evidence IS NULL THEN jsonb_build_object('resolution_notes', p_resolution_notes, 'resolved_by', p_resolved_by)
        ELSE evidence || jsonb_build_object('resolution_notes', p_resolution_notes, 'resolved_by', p_resolved_by)
      END
    WHERE id = v_finding_id 
      AND work_order_id = p_work_order_id
      AND resolved_at IS NULL;
    
    IF FOUND THEN
      v_resolved_count := v_resolved_count + 1;
    END IF;
  END LOOP;

  -- Audit log
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
  VALUES (
    'qa_findings_resolved',
    'agent',
    p_resolved_by,
    'work_order',
    p_work_order_id,
    format('Resolved %s QA findings', v_resolved_count),
    jsonb_build_object(
      'finding_ids', p_finding_ids,
      'resolved_count', v_resolved_count,
      'resolution_notes', p_resolution_notes
    )
  );

  v_result := jsonb_build_object(
    'success', true,
    'resolved_count', v_resolved_count,
    'work_order_id', p_work_order_id
  );

  RETURN v_result;
END;
$$;


--
-- Name: retrigger_qa_on_remediation_done(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.retrigger_qa_on_remediation_done() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  DECLARE
    v_parent_id uuid;
    v_parent_status text;
  BEGIN
    IF NEW.status != 'done' OR 'remediation' != ANY(COALESCE(NEW.tags, ARRAY[]::text[])) THEN
      RETURN NEW;
    END IF;
    
    SELECT parent_id INTO v_parent_id
    FROM work_orders WHERE id = NEW.id;
    
    IF v_parent_id IS NULL THEN
      RETURN NEW;
    END IF;
    
    SELECT status INTO v_parent_status
    FROM work_orders WHERE id = v_parent_id;
    
    IF v_parent_status != 'review' THEN
      RETURN NEW;
    END IF;
    
    UPDATE work_orders
    SET qa_review_verified_at = NULL,
        updated_at = NOW()
    WHERE id = v_parent_id;
    
    INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
    VALUES (v_parent_id, 'stream', 'system',
      jsonb_build_object(
        'event_type', 'qa_retriggered',
        'content', format('QA re-triggered for %s after remediation %s completed', 
          (SELECT slug FROM work_orders WHERE id = v_parent_id),
          NEW.slug),
        'remediation_slug', NEW.slug
      )
    );
    
    RETURN NEW;
  END;
END;
$$;


--
-- Name: retry_failed_dispatch(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.retry_failed_dispatch() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_retry_wo RECORD;
  v_auth_key text;
  v_request_id bigint;
  v_backoff_seconds integer;
  v_retry_count integer := 0;
  v_failed_count integer := 0;
  v_result jsonb;
  v_wo_id uuid;
  v_wo_slug text;
  v_active_count int;
  v_max_concurrent int := 3;
BEGIN
  -- CONCURRENCY LIMITER: Check before doing anything
  SELECT COUNT(*) INTO v_active_count
  FROM work_orders w
  JOIN agents a ON a.id = w.assigned_to
  WHERE w.status = 'in_progress'
    AND a.name != 'ilmarinen'
    AND w.started_at > NOW() - interval '30 minutes';
  
  IF v_active_count >= v_max_concurrent THEN
    RETURN jsonb_build_object(
      'skipped', true,
      'reason', 'concurrency_limit',
      'active_count', v_active_count,
      'max_concurrent', v_max_concurrent
    );
  END IF;

  SELECT (setting_value#>>'{}')::text INTO v_auth_key
  FROM system_settings
  WHERE setting_key = 'supabase_anon_key';

  IF v_auth_key IS NULL THEN
    RETURN jsonb_build_object('error', 'supabase_anon_key not found');
  END IF;

  -- Retry eligible WOs (capped by remaining concurrency slots)
  FOR v_retry_wo IN
    SELECT 
      wo.id,
      wo.slug,
      wo.dispatch_attempts,
      wo.last_dispatch_at,
      wo.last_dispatch_error,
      wo.assigned_to
    FROM work_orders wo
    WHERE wo.status = 'in_progress'
      AND wo.dispatch_attempts > 0
      AND wo.dispatch_attempts < 3
      AND wo.last_dispatch_error IS NOT NULL
      AND wo.last_dispatch_at < now() - interval '30 seconds'
      AND NOT EXISTS (
        SELECT 1 FROM work_order_execution_log el
        WHERE el.work_order_id = wo.id
          AND el.created_at > wo.last_dispatch_at
      )
    ORDER BY wo.last_dispatch_at ASC
    LIMIT LEAST(10, v_max_concurrent - v_active_count)
  LOOP
    v_wo_id := v_retry_wo.id;
    v_wo_slug := v_retry_wo.slug;
    
    v_backoff_seconds := 30 * POWER(2, v_retry_wo.dispatch_attempts - 1);
    
    IF v_retry_wo.last_dispatch_at IS NOT NULL AND 
       v_retry_wo.last_dispatch_at > now() - (v_backoff_seconds || ' seconds')::interval THEN
      CONTINUE;
    END IF;

    SELECT net.http_post(
      url := 'https://phfblljwuvzqzlbzkzpr.supabase.co/functions/v1/wo-agent/execute',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || v_auth_key,
        'apikey', v_auth_key
      ),
      body := jsonb_build_object(
        'work_order_id', v_wo_id::text,
        'trigger', 'dispatch_retry',
        'retry_attempt', v_retry_wo.dispatch_attempts + 1
      )
    ) INTO v_request_id;

    UPDATE work_orders
    SET 
      dispatch_attempts = dispatch_attempts + 1,
      last_dispatch_at = now(),
      last_dispatch_error = NULL,
      updated_at = now()
    WHERE id = v_wo_id;

    INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
    VALUES (
      v_wo_id,
      'stream',
      'system',
      jsonb_build_object(
        'event_type', 'dispatch_retry',
        'wo_slug', v_wo_slug,
        'attempt_number', v_retry_wo.dispatch_attempts + 1,
        'backoff_seconds', v_backoff_seconds,
        'pg_net_request_id', v_request_id
      )
    );

    v_retry_count := v_retry_count + 1;
    v_active_count := v_active_count + 1;
  END LOOP;

  -- Handle WOs that exceeded max retries
  PERFORM set_config('app.wo_trigger_context', 'true', true);
  PERFORM set_config('app.wo_executor_bypass', 'true', true);
  
  FOR v_retry_wo IN
    SELECT wo.id, wo.slug, wo.dispatch_attempts, wo.last_dispatch_error
    FROM work_orders wo
    WHERE wo.status = 'in_progress'
      AND wo.dispatch_attempts >= 3
      AND wo.last_dispatch_error IS NOT NULL
  LOOP
    PERFORM update_work_order_state(
      p_work_order_id := v_retry_wo.id,
      p_status := 'failed',
      p_approved_at := NULL::timestamptz,
      p_approved_by := NULL::text,
      p_started_at := NULL::timestamptz,
      p_completed_at := now(),
      p_summary := 'Dispatch failed after 3 attempts. Last error: ' || COALESCE(v_retry_wo.last_dispatch_error, 'unknown')
    );

    INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
    VALUES (
      v_retry_wo.id,
      'failed',
      'system',
      jsonb_build_object(
        'event_type', 'dispatch_failed_permanent',
        'wo_slug', v_retry_wo.slug,
        'total_attempts', v_retry_wo.dispatch_attempts,
        'last_error', v_retry_wo.last_dispatch_error
      )
    );

    v_failed_count := v_failed_count + 1;
  END LOOP;
  
  PERFORM set_config('app.wo_executor_bypass', '', true);
  PERFORM set_config('app.wo_trigger_context', '', true);

  RETURN jsonb_build_object(
    'retries_attempted', v_retry_count,
    'permanently_failed', v_failed_count
  );
END;
$$;


--
-- Name: rollback_work_order(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rollback_work_order(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo RECORD;
  v_snapshot JSONB;
  v_schema_changes JSONB;
  v_state_mutations UUID[];
  v_rollback_wo_id UUID;
  v_rollback_count INT := 0;
  v_failed_items JSONB := '[]'::JSONB;
  v_migration_version TEXT;
  v_down_sql TEXT;
  v_result JSONB;
  v_edge_function JSONB;
  v_old_version INT;
BEGIN
  -- Fetch work order and snapshot
  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'work_order_not_found',
      'work_order_id', p_work_order_id
    );
  END IF;

  v_snapshot := v_wo.pre_execution_snapshot;
  
  IF v_snapshot IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'no_snapshot_found',
      'message', 'Cannot rollback: no pre_execution_snapshot exists',
      'work_order_id', p_work_order_id
    );
  END IF;

  -- Step 1: Rollback state mutations (newest first)
  SELECT array_agg(id ORDER BY created_at DESC) INTO v_state_mutations
  FROM state_mutations
  WHERE work_order_id = p_work_order_id
    AND rolled_back_at IS NULL;
  
  IF v_state_mutations IS NOT NULL THEN
    FOR i IN 1..array_length(v_state_mutations, 1) LOOP
      BEGIN
        PERFORM state_rollback(v_state_mutations[i]);
        v_rollback_count := v_rollback_count + 1;
      EXCEPTION WHEN OTHERS THEN
        v_failed_items := v_failed_items || jsonb_build_object(
          'type', 'state_mutation',
          'id', v_state_mutations[i],
          'error', SQLERRM
        );
      END;
    END LOOP;
  END IF;

  -- Step 2: Apply down migrations (reverse order)
  SELECT jsonb_agg(
    jsonb_build_object(
      'version', change_sql,
      'object_name', object_name
    ) ORDER BY created_at DESC
  ) INTO v_schema_changes
  FROM schema_changes
  WHERE work_order_id = p_work_order_id;

  IF v_schema_changes IS NOT NULL THEN
    FOR i IN 0..(jsonb_array_length(v_schema_changes) - 1) LOOP
      v_migration_version := v_schema_changes->i->>'object_name';
      
      -- Try to find corresponding down migration
      BEGIN
        -- apply_down_migration will look up the down SQL from migrations
        v_result := apply_down_migration(v_migration_version);
        
        IF v_result->>'success' = 'true' THEN
          v_rollback_count := v_rollback_count + 1;
        ELSE
          v_failed_items := v_failed_items || jsonb_build_object(
            'type', 'migration',
            'version', v_migration_version,
            'error', v_result->>'error'
          );
        END IF;
      EXCEPTION WHEN OTHERS THEN
        v_failed_items := v_failed_items || jsonb_build_object(
          'type', 'migration',
          'version', v_migration_version,
          'error', SQLERRM
        );
      END;
    END LOOP;
  END IF;

  -- Step 3: Revert edge function versions from snapshot
  IF v_snapshot ? 'edge_functions' THEN
    FOR i IN 0..(jsonb_array_length(v_snapshot->'edge_functions') - 1) LOOP
      v_edge_function := v_snapshot->'edge_functions'->i;
      v_old_version := (v_edge_function->>'version')::INT;
      
      BEGIN
        -- Record the version reversion in system_manifest
        UPDATE system_manifest
        SET 
          version = v_old_version,
          config = jsonb_set(
            COALESCE(config, '{}'::jsonb),
            '{rollback_info}',
            jsonb_build_object(
              'rolled_back_at', NOW(),
              'rolled_back_by_wo', p_work_order_id,
              'previous_version', version
            )
          ),
          updated_at = NOW()
        WHERE component_type = 'edge_function'
          AND name = v_edge_function->>'name';
        
        IF FOUND THEN
          v_rollback_count := v_rollback_count + 1;
          
          -- Note: Actual function code redeployment requires manual intervention
          -- or integration with Supabase Management API. This marks the version
          -- for manual rollback verification.
        ELSE
          v_failed_items := v_failed_items || jsonb_build_object(
            'type', 'edge_function',
            'name', v_edge_function->>'name',
            'error', 'function_not_found_in_manifest'
          );
        END IF;
      EXCEPTION WHEN OTHERS THEN
        v_failed_items := v_failed_items || jsonb_build_object(
          'type', 'edge_function',
          'name', v_edge_function->>'name',
          'error', SQLERRM
        );
      END;
    END LOOP;
  END IF;

  -- Step 4: Create rollback audit WO (per WO-0073)
  INSERT INTO work_orders (
    slug,
    name,
    objective,
    created_by,
    status,
    priority,
    tags,
    summary
  ) VALUES (
    'WO-ROLLBACK-' || EXTRACT(EPOCH FROM NOW())::BIGINT,
    'Rollback: ' || v_wo.name,
    'Automated rollback of WO-' || v_wo.slug || ' due to failure or remediation',
    'engineering',
    'done',
    'p1_high',
    ARRAY['rollback', 'parent:' || v_wo.slug, 'audit-trail'],
    jsonb_build_object(
      'parent_wo_id', p_work_order_id,
      'rollback_count', v_rollback_count,
      'failed_items', v_failed_items,
      'snapshot_restored', v_snapshot
    )::TEXT
  ) RETURNING id INTO v_rollback_wo_id;

  -- Step 5: Update original WO status
  UPDATE work_orders
  SET 
    status = 'cancelled',
    summary = COALESCE(summary, '') || 
      E'\n\nROLLED BACK: ' || v_rollback_count || ' changes reverted. See ' || v_rollback_wo_id
  WHERE id = p_work_order_id;

  RETURN jsonb_build_object(
    'success', true,
    'work_order_id', p_work_order_id,
    'rollback_wo_id', v_rollback_wo_id,
    'rollback_count', v_rollback_count,
    'failed_items', v_failed_items,
    'partial_rollback', jsonb_array_length(v_failed_items) > 0
  );
END;
$$;


--
-- Name: FUNCTION rollback_work_order(p_work_order_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.rollback_work_order(p_work_order_id uuid) IS 'WO-0076: Complete rollback mechanism that reverts state mutations, applies down migrations, and restores edge function versions from pre_execution_snapshot. Creates audit WO per WO-0073.';


--
-- Name: route_failed_to_audit(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.route_failed_to_audit() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- NO wo_transition_active check — fires through wo_transition
  IF NEW.status = 'failed' AND OLD.status != 'failed' THEN
    INSERT INTO audit_log (event_type, actor_type, target_type, target_id, action, payload, work_order_id)
    VALUES ('failure', 'system', 'work_order', NEW.id, 'work_order_failed',
      jsonb_build_object('failure_count', NEW.client_info->>'failure_count'), NEW.id);
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: route_work_order(text[], text, text, text, uuid, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.route_work_order(p_tags text[], p_source text, p_objective text DEFAULT NULL::text, p_acceptance_criteria text DEFAULT NULL::text, p_assigned_to uuid DEFAULT NULL::uuid, p_status text DEFAULT 'draft'::text, p_priority text DEFAULT 'p2_medium'::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_agent_id UUID;
  v_agent_name TEXT;
  v_tags TEXT[];
  v_routing_reason TEXT;
  v_skip_detection BOOLEAN := false;
  v_detected_local BOOLEAN := false;
  v_approved_at TIMESTAMPTZ := NULL;
BEGIN
  -- If already assigned, return as-is
  IF p_assigned_to IS NOT NULL THEN
    SELECT name INTO v_agent_name FROM agents WHERE id = p_assigned_to;
    RETURN jsonb_build_object('agent_id', p_assigned_to, 'agent_name', COALESCE(v_agent_name, 'unknown'), 'approved_at', NULL, 'routing_reason', 'pre-assigned');
  END IF;
  IF p_status NOT IN ('draft', 'ready') THEN
    RETURN jsonb_build_object('agent_id', NULL, 'agent_name', NULL, 'approved_at', NULL, 'routing_reason', 'status not routable');
  END IF;

  v_tags := COALESCE(p_tags, ARRAY[]::TEXT[]);
  v_skip_detection := ('remediation' = ANY(v_tags)) OR (p_source IN ('auto-qa', 'api'));

  -- RULE 0: Remediation → builder
  IF 'remediation' = ANY(v_tags) THEN
    SELECT id, name INTO v_agent_id, v_agent_name FROM agents WHERE name = 'builder' AND status = 'active';
    v_routing_reason := 'remediation: always builder';
  -- Rule 1: auto-qa → qa-gate
  ELSIF p_source = 'auto-qa' THEN
    SELECT id, name INTO v_agent_id, v_agent_name FROM agents WHERE name = 'qa-gate' AND status = 'active';
    v_routing_reason := 'auto-qa source → qa-gate';
  -- Rule 2: security review → security
  ELSIF ARRAY['security-review', 'red-team', 'vulnerability-scan'] && v_tags
     AND NOT ARRAY['code-change', 'migration', 'deploy', 'pipeline-phase', 'sql-only', 'hardening'] && v_tags THEN
    SELECT id, name INTO v_agent_id, v_agent_name FROM agents WHERE name = 'security' AND status = 'active';
    v_routing_reason := 'security review → security';
  -- Rule 3: health/monitoring → ops
  ELSIF ARRAY['health-check', 'monitoring', 'stuck-detection'] && v_tags
     AND NOT ARRAY['code-change', 'migration', 'deploy', 'pipeline-phase', 'sql-only'] && v_tags THEN
    SELECT id, name INTO v_agent_id, v_agent_name FROM agents WHERE name = 'ops' AND status = 'active';
    v_routing_reason := 'monitoring → ops';
  -- Rule 4: QA/review → qa-gate
  ELSIF ARRAY['qa', 'review', 'evaluation', 'compliance'] && v_tags
     AND NOT ARRAY['code-change', 'migration', 'deploy', 'pipeline-phase', 'sql-only'] && v_tags THEN
    SELECT id, name INTO v_agent_id, v_agent_name FROM agents WHERE name = 'qa-gate' AND status = 'active';
    v_routing_reason := 'QA/review → qa-gate';
  -- Rule 5: frontend → frontend
  ELSIF ARRAY['frontend', 'ui', 'portal', 'dashboard', 'html'] && v_tags
     AND NOT ARRAY['migration', 'sql-only', 'edge-function', 'supabase'] && v_tags THEN
    SELECT id, name INTO v_agent_id, v_agent_name FROM agents WHERE name = 'frontend' AND status = 'active';
    v_routing_reason := 'frontend-tagged → frontend';
  -- Rule 6: default → builder
  ELSE
    SELECT id, name INTO v_agent_id, v_agent_name FROM agents WHERE name = 'builder' AND status = 'active';
    v_routing_reason := 'default → builder';
  END IF;

  -- Local filesystem detection
  IF v_agent_name = 'builder' AND NOT v_skip_detection THEN
    v_detected_local := detect_local_filesystem_need(p_objective, p_acceptance_criteria);
    IF v_detected_local THEN
      v_routing_reason := v_routing_reason || ', local-filesystem detected';
    END IF;
  END IF;

  -- Auto-approve P1/P2/P3 and auto-qa
  IF v_agent_id IS NOT NULL THEN
    IF p_priority IN ('p1_high', 'p2_medium', 'p3_low') OR p_source = 'auto-qa' THEN
      v_approved_at := now();
    END IF;
  END IF;

  RETURN jsonb_build_object(
    'agent_id', v_agent_id,
    'agent_name', v_agent_name,
    'approved_at', v_approved_at,
    'routing_reason', v_routing_reason
  );
END;
$$;


--
-- Name: run_advance_pipeline(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.run_advance_pipeline(p_pipeline_run_id uuid, p_triggering_wo_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
    RETURN public.advance_pipeline_phase(p_pipeline_run_id, p_triggering_wo_id);
END;
$$;


--
-- Name: run_pre_execution_gate(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.run_pre_execution_gate(p_wo_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo record;
  v_scope_analysis jsonb;
  v_agent_fit jsonb;
  v_rejection_reasons text[];
  v_passed boolean := true;
  v_gate_result jsonb;
  v_issues jsonb := jsonb_build_array();
  v_agent_name text;
  v_scope_size int;
  v_tags text[];
  v_affected_items text[];
BEGIN
  v_rejection_reasons := ARRAY[]::text[];
  
  SELECT * INTO v_wo FROM work_orders WHERE id = p_wo_id;
  
  IF v_wo.id IS NULL THEN
    RETURN jsonb_build_object('passed', false, 'error', 'Work order not found');
  END IF;
  
  v_tags := COALESCE(v_wo.tags, ARRAY[]::text[]);
  
  -- Only exempt remediation and pipeline-phase WOs. skip-quality-gate REMOVED.
  IF v_tags && ARRAY['remediation', 'pipeline-phase'] THEN
    RETURN jsonb_build_object('passed', true, 'skipped', true, 'reason', 'Exempted WO type (remediation/pipeline-phase)');
  END IF;
  
  -- Retry exemption — retried WOs already passed the gate once
  IF COALESCE(v_wo.retry_count, 0) > 0 THEN
    RETURN jsonb_build_object('passed', true, 'skipped', true, 'reason', 'Retry exemption (retry_count=' || v_wo.retry_count || ')');
  END IF;
  
  -- Run scope analysis
  v_scope_analysis := analyze_wo_scope(v_wo.objective, v_wo.acceptance_criteria);
  
  v_affected_items := ARRAY(
    SELECT val FROM jsonb_array_elements_text(COALESCE(v_scope_analysis->'affected_tables', '[]'::jsonb)) val
    UNION ALL
    SELECT val FROM jsonb_array_elements_text(COALESCE(v_scope_analysis->'affected_functions', '[]'::jsonb)) val
    UNION ALL
    SELECT val FROM jsonb_array_elements_text(COALESCE(v_scope_analysis->'affected_files', '[]'::jsonb)) val
  );
  v_scope_size := COALESCE(array_length(v_affected_items, 1), 0);
  
  -- Check specificity
  IF (v_scope_analysis->>'specificity_score')::int < 4 THEN
    v_passed := false;
    v_rejection_reasons := array_append(v_rejection_reasons, 
      'Specificity score too low: ' || (v_scope_analysis->>'specificity_score') || '/10');
    v_issues := v_issues || jsonb_build_array(jsonb_build_object('type', 'specificity', 'score', v_scope_analysis->>'specificity_score'));
  END IF;
  
  -- Check deterministic score
  IF (v_scope_analysis->>'deterministic_score')::int < 5 THEN
    v_passed := false;
    v_rejection_reasons := array_append(v_rejection_reasons, 
      'Deterministic score too low: ' || (v_scope_analysis->>'deterministic_score') || '/10');
    v_issues := v_issues || jsonb_build_array(jsonb_build_object('type', 'deterministic', 'score', v_scope_analysis->>'deterministic_score'));
  END IF;
  
  -- Check agent fit
  BEGIN
    SELECT name INTO v_agent_name FROM agents WHERE id = v_wo.assigned_to LIMIT 1;
    IF v_agent_name IS NULL THEN v_agent_name := 'builder'; END IF;
    
    v_agent_fit := check_agent_fit(
      v_agent_name,
      ARRAY(SELECT jsonb_array_elements_text(COALESCE(v_scope_analysis->'required_tools', '[]'::jsonb))),
      v_scope_size
    );
    
    IF NOT (v_agent_fit->>'tools_available')::boolean THEN
      v_passed := false;
      v_rejection_reasons := array_append(v_rejection_reasons, 
        'Missing tools: ' || (v_agent_fit->>'missing_tools'));
    END IF;
    
    IF NOT (v_agent_fit->>'fits_context')::boolean THEN
      v_passed := false;
      v_rejection_reasons := array_append(v_rejection_reasons, 
        'Context overflow: estimated ' || (v_agent_fit->>'estimated_tokens') || ' tokens');
    END IF;
    
  EXCEPTION WHEN OTHERS THEN
    v_agent_fit := jsonb_build_object('tools_available', true, 'error', SQLERRM);
  END;
  
  RETURN jsonb_build_object(
    'passed', v_passed,
    'scope_analysis', v_scope_analysis,
    'agent_fit', v_agent_fit,
    'rejection_reasons', v_rejection_reasons,
    'issues', v_issues,
    'skipped', false
  );
END;
$$;


--
-- Name: run_regression_suite(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.run_regression_suite() RETURNS TABLE(suite_name text, test_wo_slug text, baseline_score numeric, test_score numeric, delta_pct numeric, status text, alert boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
  suite_rec RECORD;
  latest_scorecard RECORD;
  v_delta_pct NUMERIC;
  test_status TEXT;
  alert_flag BOOLEAN;
  threshold NUMERIC;
BEGIN
  -- Loop through active suite definitions
  FOR suite_rec IN 
    SELECT sd.id, sd.suite_name, sd.canonical_wo_slug, sd.canonical_wo_id, 
           sd.baseline_score, sd.baseline_scorecard_id, 
           COALESCE(sd.alert_threshold_pct, 10.0) as alert_threshold_pct
    FROM regression_suite_definitions sd
    WHERE sd.active = true
  LOOP
    -- Get the most recent scorecard for this canonical WO
    SELECT rs.id, rs.work_order_id, rs.overall_score, wo.slug
    INTO latest_scorecard
    FROM run_scorecards rs
    JOIN work_orders wo ON wo.id = rs.work_order_id
    WHERE wo.slug = suite_rec.canonical_wo_slug
    ORDER BY rs.created_at DESC
    LIMIT 1;
    
    IF latest_scorecard.id IS NULL THEN
      -- No scorecard found, mark as error
      INSERT INTO regression_suite_runs (
        suite_definition_id, status, execution_details
      ) VALUES (
        suite_rec.id, 'error', 
        jsonb_build_object('error', 'No scorecard found for WO')
      );
      
      suite_name := suite_rec.suite_name;
      test_wo_slug := suite_rec.canonical_wo_slug;
      baseline_score := suite_rec.baseline_score;
      test_score := NULL;
      delta_pct := NULL;
      status := 'error';
      alert := false;
      RETURN NEXT;
      CONTINUE;
    END IF;
    
    -- Calculate delta
    IF suite_rec.baseline_score IS NOT NULL THEN
      v_delta_pct := ((latest_scorecard.overall_score - suite_rec.baseline_score) / suite_rec.baseline_score) * 100;
      threshold := suite_rec.alert_threshold_pct;
      
      -- Check if alert threshold exceeded (dynamic threshold from table)
      IF v_delta_pct < -threshold THEN
        test_status := 'fail';
        alert_flag := true;
      ELSE
        test_status := 'pass';
        alert_flag := false;
      END IF;
    ELSE
      v_delta_pct := NULL;
      test_status := 'pending';
      alert_flag := false;
    END IF;
    
    -- Record the run
    INSERT INTO regression_suite_runs (
      suite_definition_id, test_wo_id, test_scorecard_id,
      test_score, baseline_score, score_delta, score_delta_pct,
      status, alert_triggered, execution_details
    ) VALUES (
      suite_rec.id, latest_scorecard.work_order_id, latest_scorecard.id,
      latest_scorecard.overall_score, suite_rec.baseline_score,
      latest_scorecard.overall_score - COALESCE(suite_rec.baseline_score, 0),
      v_delta_pct, test_status, alert_flag,
      jsonb_build_object('canonical_wo_slug', suite_rec.canonical_wo_slug, 'threshold_used', threshold)
    );
    
    -- Return result
    suite_name := suite_rec.suite_name;
    test_wo_slug := latest_scorecard.slug;
    baseline_score := suite_rec.baseline_score;
    test_score := latest_scorecard.overall_score;
    delta_pct := v_delta_pct;
    status := test_status;
    alert := alert_flag;
    RETURN NEXT;
  END LOOP;
END;
$$;


--
-- Name: FUNCTION run_regression_suite(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.run_regression_suite() IS 'Execute regression suite: compare latest scorecards to baselines, alert on >10% drop';


--
-- Name: run_sql(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.run_sql(sql_query text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  result jsonb;
BEGIN
  EXECUTE 'SELECT jsonb_agg(row_to_json(t)) FROM (' || sql_query || ') t' INTO result;
  RETURN COALESCE(result, '[]'::jsonb);
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('error', SQLERRM, 'detail', SQLSTATE);
END;
$$;


--
-- Name: run_sql_void(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.run_sql_void(sql_query text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_calling_agent text;
  v_affects_work_orders boolean := false;
BEGIN
  -- WO-0399: Block config manipulation for bypass/enforcement keys
  IF sql_query ILIKE '%set_config%wo_executor_bypass%'
     OR sql_query ILIKE '%set_config%wo_trigger_context%'
     OR sql_query ILIKE '%set_config%wo_transition_active%'
     OR sql_query ILIKE '%set_config%state_write_bypass%' THEN
    INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, action, payload)
    VALUES ('config_manipulation_blocked', 'agent',
      COALESCE(current_setting('app.current_agent_name', true), 'unknown'),
      'system', 'Blocked attempt to set bypass/enforcement config via SQL',
      jsonb_build_object('sql_query', LEFT(sql_query, 500), 'timestamp', NOW())
    );
    RETURN jsonb_build_object('error', 'CONFIG_GUARD: Setting bypass/enforcement config values via SQL is blocked. Use designated RPCs.');
  END IF;

  -- WO-0399: Clear trigger context before executing user SQL (defense-in-depth)
  PERFORM set_config('app.wo_trigger_context', '', true);

  -- Detect calling agent
  v_calling_agent := current_setting('app.current_agent_name', true);
  IF v_calling_agent IS NULL OR v_calling_agent = '' THEN
    v_calling_agent := current_setting('request.jwt.claims', true)::jsonb->>'sub';
  END IF;
  IF v_calling_agent IS NULL OR v_calling_agent = '' THEN
    v_calling_agent := 'unknown';
  END IF;

  -- Check if query affects work_orders table status
  v_affects_work_orders := (
    sql_query ILIKE '%work_orders%' AND (
      sql_query ILIKE '%UPDATE%' OR
      sql_query ILIKE '%SET status%' OR
      sql_query ILIKE '%SET approved_%' OR
      sql_query ILIKE '%SET started_at%' OR
      sql_query ILIKE '%SET completed_at%'
    )
  );

  -- Log if it affects work_orders
  IF v_affects_work_orders THEN
    INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, action, payload)
    VALUES (
      'raw_sql_execution',
      CASE 
        WHEN v_calling_agent IN ('work-order-executor', 'wo-agent') THEN 'agent'
        WHEN v_calling_agent = 'unknown' THEN 'system'
        ELSE 'agent'
      END,
      v_calling_agent,
      'work_order',
      'Raw SQL affecting work_orders table',
      jsonb_build_object(
        'sql_query', LEFT(sql_query, 1000),
        'calling_agent', v_calling_agent,
        'timestamp', NOW()
      )
    );
  END IF;

  -- Execute the query
  EXECUTE sql_query;
  
  RETURN jsonb_build_object('success', true);
EXCEPTION WHEN OTHERS THEN
  IF v_affects_work_orders THEN
    INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, action, payload)
    VALUES (
      'raw_sql_execution_failed',
      CASE 
        WHEN v_calling_agent IN ('work-order-executor', 'wo-agent') THEN 'agent'
        WHEN v_calling_agent = 'unknown' THEN 'system'
        ELSE 'agent'
      END,
      v_calling_agent,
      'work_order',
      'Raw SQL failed on work_orders table',
      jsonb_build_object(
        'sql_query', LEFT(sql_query, 1000),
        'error', SQLERRM,
        'sqlstate', SQLSTATE,
        'calling_agent', v_calling_agent
      )
    );
  END IF;
  
  RETURN jsonb_build_object('error', SQLERRM, 'detail', SQLSTATE);
END;
$$;


--
-- Name: FUNCTION run_sql_void(sql_query text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.run_sql_void(sql_query text) IS 'Execute raw SQL with audit logging for work_orders table changes. AC#2 from WO-0385';


--
-- Name: safe_rollback_order(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.safe_rollback_order(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_mutation_ids uuid[];
    v_result jsonb := '[]'::jsonb;
    v_mutation RECORD;
    v_conflict_wo RECORD;
    v_conflict_slugs text[];
    v_sorted_ids uuid[];
    v_processed_ids uuid[] := '{}'::uuid[];
    v_remaining_ids uuid[];
    v_has_dependency boolean;
    v_id uuid;
BEGIN
    -- Get all write/delete mutations for this work order
    SELECT ARRAY_AGG(id ORDER BY created_at DESC)
    INTO v_mutation_ids
    FROM wo_mutations
    WHERE work_order_id = p_work_order_id
      AND tool_name IN ('apply_migration', 'execute_sql', 'deploy_edge_function')
      AND action IN ('CREATE', 'CREATE TABLE', 'ALTER', 'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE FUNCTION', 'CREATE OR REPLACE FUNCTION');

    IF v_mutation_ids IS NULL OR array_length(v_mutation_ids, 1) IS NULL THEN
        RETURN jsonb_build_object(
            'work_order_id', p_work_order_id,
            'rollback_order', '[]'::jsonb,
            'message', 'No write mutations found for work order'
        );
    END IF;

    -- Build reverse topological order using dependency information
    v_remaining_ids := v_mutation_ids;
    
    WHILE array_length(v_remaining_ids, 1) > 0 LOOP
        -- Find mutations with no unresolved dependencies
        FOREACH v_id IN ARRAY v_remaining_ids LOOP
            -- Check if this mutation has dependencies on other remaining mutations
            SELECT EXISTS(
                SELECT 1 FROM wo_mutation_dependencies d
                JOIN unnest(v_remaining_ids) WITH ORDINALITY AS r(id, ord) ON r.id = d.depends_on_mutation_id
                WHERE d.mutation_id = v_id
            ) INTO v_has_dependency;
            
            IF NOT v_has_dependency OR NOT EXISTS(
                SELECT 1 FROM wo_mutation_dependencies d
                WHERE d.mutation_id = v_id
                  AND d.depends_on_mutation_id = ANY(v_remaining_ids)
            ) THEN
                -- This mutation can be processed next
                v_sorted_ids := array_append(v_sorted_ids, v_id);
                v_processed_ids := array_append(v_processed_ids, v_id);
            END IF;
        END LOOP;
        
        -- Remove processed from remaining
        IF array_length(v_processed_ids, 1) = array_length(v_remaining_ids, 1) THEN
            -- All processed, we're done
            EXIT;
        END IF;
        
        -- Remove processed IDs from remaining
        v_remaining_ids := array(
            SELECT unnest(v_remaining_ids) 
            WHERE unnest NOT IN (SELECT unnest FROM unnest(v_processed_ids))
        );
        
        -- Safety: if no progress, break to avoid infinite loop
        IF array_length(v_remaining_ids, 1) = array_length(v_mutation_ids, 1) THEN
            -- No progress made, just use reverse chronological order
            v_sorted_ids := v_mutation_ids;
            EXIT;
        END IF;
    END LOOP;

    -- If sorted is empty (no dependencies recorded), use reverse chronological
    IF v_sorted_ids IS NULL OR array_length(v_sorted_ids, 1) IS NULL THEN
        v_sorted_ids := v_mutation_ids;
    END IF;

    -- Build result with conflict detection
    FOR v_mutation IN
        SELECT id, tool_name, object_type, object_id, action
        FROM wo_mutations
        WHERE id = ANY(v_sorted_ids)
    LOOP
        -- Check for conflicts: other WOs touching same object_id
        v_conflict_slugs := NULL;
        
        SELECT ARRAY_AGG(DISTINCT wo.slug ORDER BY wo.slug)
        INTO v_conflict_slugs
        FROM wo_mutations m
        JOIN work_orders wo ON wo.id = m.work_order_id
        WHERE m.work_order_id != p_work_order_id
          AND m.object_id = v_mutation.object_id
          AND m.tool_name IN ('apply_migration', 'execute_sql', 'deploy_edge_function')
          AND m.action IN ('CREATE', 'CREATE TABLE', 'ALTER', 'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE FUNCTION', 'CREATE OR REPLACE FUNCTION');
        
        v_result := v_result || jsonb_build_array(jsonb_build_object(
            'mutation_id', v_mutation.id,
            'tool_name', v_mutation.tool_name,
            'object_id', v_mutation.object_id,
            'action', v_mutation.action,
            'safe_to_rollback', v_conflict_slugs IS NULL OR array_length(v_conflict_slugs, 1) = 0,
            'conflict_wo_slugs', COALESCE(v_conflict_slugs, '{}'::text[])
        ));
    END LOOP;

    RETURN jsonb_build_object(
        'work_order_id', p_work_order_id,
        'rollback_order', v_result,
        'mutation_count', array_length(v_sorted_ids, 1)
    );
END;
$$;


--
-- Name: schedule_enforcer_run(text, jsonb, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.schedule_enforcer_run(p_trigger_type text DEFAULT 'manual'::text, p_trigger_context jsonb DEFAULT '{}'::jsonb, p_work_order_id text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_supabase_url TEXT;
  v_service_key TEXT;
  v_response_id BIGINT;
BEGIN
  SELECT value INTO v_supabase_url FROM enforcer_config WHERE key = 'supabase_url';
  SELECT value INTO v_service_key FROM enforcer_config WHERE key = 'service_role_key';
  
  IF v_supabase_url IS NULL OR v_service_key IS NULL THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'Enforcer config not set'
    );
  END IF;
  
  SELECT net.http_post(
    url := v_supabase_url || '/functions/v1/audit-enforcer',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || v_service_key,
      'apikey', v_service_key
    ),
    body := jsonb_build_object(
      'trigger_type', p_trigger_type,
      'trigger_context', p_trigger_context,
      'work_order_id', p_work_order_id
    )
  ) INTO v_response_id;
  
  RETURN jsonb_build_object(
    'success', TRUE,
    'request_id', v_response_id
  );
END;
$$;


--
-- Name: score_ac_specificity(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.score_ac_specificity(p_acceptance_criteria text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_score int := 60;
  v_flags text[] := '{}';
  v_lines text[];
  v_line text;
  v_ac_count int := 0;
BEGIN
  IF p_acceptance_criteria IS NULL OR trim(p_acceptance_criteria) = '' THEN
    RETURN jsonb_build_object('score', 0, 'ac_count', 0, 'flags', to_jsonb(ARRAY['no_acceptance_criteria']));
  END IF;

  v_lines := string_to_array(p_acceptance_criteria, E'\n');
  
  FOREACH v_line IN ARRAY v_lines LOOP
    v_line := trim(v_line);
    IF v_line = '' THEN CONTINUE; END IF;
    -- Count lines starting with number or bullet as ACs
    IF v_line ~ '^\d+[\.\)]\s' OR v_line ~ '^[-*]\s' THEN
      v_ac_count := v_ac_count + 1;
      
      -- Vague verbs: -20 each (use \m/\M for PostgreSQL word boundaries)
      IF v_line ~* '\m(find|investigate|discover|identify|check all|look for|explore|research|analyze all)\M' THEN
        v_score := v_score - 20;
        v_flags := array_append(v_flags, 'vague_verb: ' || left(v_line, 80));
      END IF;
      
      -- Open-ended enumeration: -15 each
      IF v_line ~* '\m(all tables|each candidate|every function|all unused|all files|for each|all endpoints|all functions)\M' THEN
        v_score := v_score - 15;
        v_flags := array_append(v_flags, 'open_ended_enum: ' || left(v_line, 80));
      END IF;
      
      -- Missing exact names (no quoted identifiers, no dot paths, no parens, no file exts): -10
      IF v_line !~ '["`''][\w_]+["`'']' 
         AND v_line !~ '[\w_]+\.[\w_]+'
         AND v_line !~ '[\w_]+\(' 
         AND v_line !~ '/[\w_/]+\.\w+' THEN
        v_score := v_score - 10;
        v_flags := array_append(v_flags, 'no_exact_names: ' || left(v_line, 80));
      END IF;
      
      -- Exact file paths: +20
      IF v_line ~ '(src/|supabase/|\.ts\M|\.js\M|\.sql\M|\.html\M)' THEN
        v_score := v_score + 20;
        v_flags := array_append(v_flags, 'has_file_path: ' || left(v_line, 80));
      END IF;
      
      -- Exact function/RPC names with parens: +20
      IF v_line ~ '[a-z_][a-z0-9_]*\s*\(' THEN
        v_score := v_score + 20;
        v_flags := array_append(v_flags, 'has_function_name: ' || left(v_line, 80));
      END IF;
      
      -- Exact SQL patterns: +10
      IF v_line ~* '\m(CREATE|ALTER|DROP|INSERT INTO|UPDATE|SELECT|RETURNS|LANGUAGE)\M' THEN
        v_score := v_score + 10;
        v_flags := array_append(v_flags, 'has_sql_pattern: ' || left(v_line, 80));
      END IF;
      
      -- Qualified names (table.column): +15
      IF v_line ~ '[a-z_]+\.[a-z_]+' THEN
        v_score := v_score + 15;
        v_flags := array_append(v_flags, 'has_qualified_name: ' || left(v_line, 80));
      END IF;
      
      -- Line number references: +15
      IF v_line ~* '(line|ln)\s+\d+' THEN
        v_score := v_score + 15;
        v_flags := array_append(v_flags, 'has_line_ref: ' || left(v_line, 80));
      END IF;
    END IF;
  END LOOP;

  v_score := GREATEST(0, LEAST(100, v_score));

  RETURN jsonb_build_object(
    'score', v_score,
    'ac_count', v_ac_count,
    'flags', to_jsonb(v_flags)
  );
END;
$$;


--
-- Name: score_wo_complexity(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.score_wo_complexity(p_objective text, p_acceptance_criteria text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_file_count int := 0;
  v_large_file_flag boolean := false;
  v_multi_file_flag boolean := false;
  v_schema_change_flag boolean := false;
  v_complexity_score int := 0;
  v_recommended_agent text := 'builder';
  v_combined_text text;
  v_problematic_count int := 0;
BEGIN
  v_combined_text := COALESCE(p_objective, '') || ' ' || COALESCE(p_acceptance_criteria, '');
  
  v_file_count := (
    SELECT COUNT(DISTINCT match[1])
    FROM regexp_matches(
      v_combined_text,
      '([a-zA-Z0-9_/-]+\.(ts|tsx|js|jsx|py|sql|json|yaml|yml|md))',
      'gi'
    ) AS match
  );
  
  v_large_file_flag := (
    v_combined_text ~* '\mtools\.ts\M'
    OR v_combined_text ~* '\mindex\.ts\M'
    OR v_combined_text ~* '\mwo-agent/index\.ts\M'
    OR v_combined_text ~* '\msupabase/functions/wo-agent/index\.ts\M'
  );
  
  IF NOT v_large_file_flag THEN
    SELECT COUNT(*) INTO v_problematic_count
    FROM problematic_files pf
    WHERE pf.object_type = 'file'
      AND v_combined_text ~* ('\m' || pf.object_id || '\M')
      AND pf.failure_count > 5;
    
    IF v_problematic_count > 0 THEN
      v_large_file_flag := true;
    END IF;
  END IF;
  
  v_multi_file_flag := v_file_count > 2;
  
  v_schema_change_flag := (
    v_combined_text ~* '\mCREATE\s+TABLE\M'
    OR v_combined_text ~* '\mALTER\s+TABLE\M'
    OR v_combined_text ~* '\mCREATE\s+FUNCTION\M'
    OR v_combined_text ~* '\mCREATE\s+OR\s+REPLACE\s+FUNCTION\M'
    OR v_combined_text ~* '\mCREATE\s+INDEX\M'
    OR v_combined_text ~* '\mCREATE\s+VIEW\M'
    OR v_combined_text ~* '\mCREATE\s+TRIGGER\M'
  );
  
  v_complexity_score := 1;
  
  IF v_file_count > 0 THEN
    v_complexity_score := v_complexity_score + LEAST(v_file_count, 3);
  END IF;
  
  IF v_large_file_flag THEN
    v_complexity_score := v_complexity_score + 3;
  END IF;
  
  IF v_multi_file_flag THEN
    v_complexity_score := v_complexity_score + 2;
  END IF;
  
  IF v_schema_change_flag THEN
    v_complexity_score := v_complexity_score + 1;
  END IF;
  
  v_complexity_score := LEAST(v_complexity_score, 10);
  
  -- ALWAYS route to builder. ilmarinen has no server-side executor.
  -- Complexity score is retained for analytics only.
  v_recommended_agent := 'builder';
  
  RETURN jsonb_build_object(
    'file_count', v_file_count,
    'large_file_flag', v_large_file_flag,
    'multi_file_flag', v_multi_file_flag,
    'schema_change_flag', v_schema_change_flag,
    'complexity_score', v_complexity_score,
    'recommended_agent', v_recommended_agent,
    'analysis', jsonb_build_object(
      'file_count_score', LEAST(v_file_count, 3),
      'large_file_penalty', CASE WHEN v_large_file_flag THEN 3 ELSE 0 END,
      'multi_file_penalty', CASE WHEN v_multi_file_flag THEN 2 ELSE 0 END,
      'schema_change_bonus', CASE WHEN v_schema_change_flag THEN 1 ELSE 0 END
    )
  );
END;
$$;


--
-- Name: FUNCTION score_wo_complexity(p_objective text, p_acceptance_criteria text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.score_wo_complexity(p_objective text, p_acceptance_criteria text) IS 'Analyzes WO objective and acceptance criteria to score complexity (1-10) and recommend routing to builder (<=4) or ilmarinen (>4)';


--
-- Name: score_work_order(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.score_work_order(p_wo_id uuid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_wo RECORD;
  v_priority_score INTEGER;
  v_dep_score INTEGER;
  v_freshness_score INTEGER;
  v_lesson_score INTEGER;
  v_complexity_score INTEGER;
  v_final_score INTEGER;
  v_rank INTEGER;
  v_age_days NUMERIC;
  v_total_deps INTEGER;
  v_done_deps INTEGER;
  v_matching_lessons INTEGER;
  v_tags TEXT[];
BEGIN
  -- Load the WO
  SELECT id, name, objective, priority, status, tags, depends_on, created_at, updated_at
  INTO v_wo
  FROM work_orders WHERE id = p_wo_id;

  IF v_wo.id IS NULL THEN RETURN 500; END IF;

  v_tags := COALESCE(v_wo.tags, ARRAY[]::TEXT[]);

  -- === Dimension 1: Priority (weight 30%) ===
  v_priority_score := CASE v_wo.priority
    WHEN 'p0_critical' THEN 100
    WHEN 'p1_high' THEN 75
    WHEN 'p2_medium' THEN 50
    WHEN 'p3_low' THEN 25
    ELSE 50
  END;

  -- === Dimension 2: Dependency readiness (weight 25%) ===
  v_total_deps := COALESCE(array_length(v_wo.depends_on, 1), 0);
  IF v_total_deps = 0 THEN
    v_dep_score := 100;
  ELSE
    SELECT COUNT(*) INTO v_done_deps
    FROM work_orders
    WHERE id = ANY(v_wo.depends_on) AND status = 'done';

    IF v_done_deps = v_total_deps THEN
      v_dep_score := 100;
    ELSIF v_done_deps > 0 THEN
      v_dep_score := 50;
    ELSE
      v_dep_score := 0;
    END IF;
  END IF;

  -- === Dimension 3: Freshness (weight 20%) ===
  v_age_days := EXTRACT(EPOCH FROM (now() - v_wo.created_at)) / 86400.0;
  v_freshness_score := GREATEST(0, 100 - (v_age_days * 10)::INTEGER);

  -- === Dimension 4: Lesson alignment (weight 15%) ===
  -- Check if WO objective/name keywords match recurring lesson categories
  SELECT COUNT(*) INTO v_matching_lessons
  FROM lessons
  WHERE severity IN ('critical', 'high')
    AND reviewed = true
    AND (
      v_wo.objective ILIKE '%' || pattern || '%'
      OR v_wo.name ILIKE '%' || category::TEXT || '%'
      OR EXISTS (
        SELECT 1 FROM unnest(v_tags) t WHERE t ILIKE '%' || category::TEXT || '%'
      )
    );

  v_lesson_score := CASE
    WHEN v_matching_lessons >= 3 THEN 100
    WHEN v_matching_lessons >= 1 THEN 60
    ELSE 30
  END;

  -- === Dimension 5: Complexity fit (weight 10%) ===
  -- Server-side executable = boost, needs local filesystem = penalty
  IF 'server-side-agent' = ANY(v_tags) OR 'remediation' = ANY(v_tags) THEN
    v_complexity_score := 90;
  ELSIF 'local-filesystem' = ANY(v_tags) OR 'git-required' = ANY(v_tags) THEN
    v_complexity_score := 40;
  ELSE
    v_complexity_score := 60;
  END IF;

  -- === Final weighted score (0-100, higher = better) ===
  v_final_score := (
    (v_priority_score * 30) +
    (v_dep_score * 25) +
    (v_freshness_score * 20) +
    (v_lesson_score * 15) +
    (v_complexity_score * 10)
  ) / 100;

  -- Map score to rank: higher score → lower rank number (higher priority)
  -- Score 100 → rank 1, score 0 → rank 999
  v_rank := GREATEST(1, LEAST(999, 1000 - (v_final_score * 10)));

  RETURN v_rank;
END;
$$;


--
-- Name: score_work_order_risk(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.score_work_order_risk(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo work_orders%ROWTYPE;
  v_objective TEXT;
  v_tags TEXT[];
  v_name TEXT;
  v_scope_score NUMERIC := 20;
  v_mutation_score NUMERIC := 20;
  v_reversibility_score NUMERIC := 20;
  v_priority_score NUMERIC := 20;
  v_source_trust_score NUMERIC := 20;
  v_composite NUMERIC;
BEGIN
  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  IF NOT FOUND THEN
    RETURN jsonb_build_object('error', 'Work order not found');
  END IF;

  v_objective := LOWER(COALESCE(v_wo.objective, ''));
  v_name := LOWER(COALESCE(v_wo.name, ''));
  v_tags := COALESCE(v_wo.tags, ARRAY[]::TEXT[]);

  -- ── Scope (weight 0.30) ──
  -- Check for multi-component or cross-system indicators
  IF v_objective ~ '(all |every |system-wide|cross-|architecture|infrastructure)' THEN
    v_scope_score := 90;
  ELSIF v_objective ~ '(multiple|several|both|and also|additionally|migration)' OR
        array_length(v_tags, 1) > 3 THEN
    v_scope_score := 50;
  ELSE
    v_scope_score := 15;
  END IF;

  -- ── Mutation type (weight 0.25) ──
  IF v_objective ~ '(drop |alter table|rls|row level|auth|permission|role|grant|revoke)' OR
     'schema' = ANY(v_tags) OR 'migration' = ANY(v_tags) OR 'security' = ANY(v_tags) THEN
    v_mutation_score := 90;
  ELSIF v_objective ~ '(deploy|edge function|update |insert |delete )' OR
        'deploy' = ANY(v_tags) THEN
    v_mutation_score := 50;
  ELSIF v_objective ~ '(fix|log|monitor|metric|alert|check|test|lint)' THEN
    v_mutation_score := 10;
  END IF;

  -- ── Reversibility (weight 0.20) ──
  IF v_objective ~ '(drop |truncate|delete all|remove table|cascade)' THEN
    v_reversibility_score := 90;
  ELSIF v_objective ~ '(update |modify |change |alter )' THEN
    v_reversibility_score := 50;
  ELSE
    v_reversibility_score := 10;
  END IF;

  -- ── Priority (weight 0.15) ──
  v_priority_score := CASE v_wo.priority::text
    WHEN 'p0_critical' THEN 100
    WHEN 'p1_high' THEN 80
    WHEN 'p2_medium' THEN 40
    WHEN 'p3_low' THEN 10
    ELSE 50
  END;

  -- ── Source trust (weight 0.10) ──
  v_source_trust_score := CASE
    WHEN v_wo.source = 'lesson_promoter' THEN 10
    WHEN v_wo.source = 'intake_api' THEN 30
    WHEN v_wo.source = 'portal' THEN 40
    WHEN v_wo.source = 'daemon' THEN 20
    ELSE 60
  END;

  -- ── Composite score ──
  v_composite := (v_scope_score * 0.30) +
                 (v_mutation_score * 0.25) +
                 (v_reversibility_score * 0.20) +
                 (v_priority_score * 0.15) +
                 (v_source_trust_score * 0.10);

  RETURN jsonb_build_object(
    'risk_score', ROUND(v_composite, 2),
    'dimensions', jsonb_build_object(
      'scope', jsonb_build_object('score', v_scope_score, 'weight', 0.30),
      'mutation_type', jsonb_build_object('score', v_mutation_score, 'weight', 0.25),
      'reversibility', jsonb_build_object('score', v_reversibility_score, 'weight', 0.20),
      'priority', jsonb_build_object('score', v_priority_score, 'weight', 0.15),
      'source_trust', jsonb_build_object('score', v_source_trust_score, 'weight', 0.10)
    ),
    'eligible', v_composite <= 25,
    'work_order_id', p_work_order_id
  );
END;
$$;


--
-- Name: search_conversations_ranked(public.vector, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.search_conversations_ranked(query_embedding public.vector, match_threshold double precision DEFAULT 0.3, match_count integer DEFAULT 10, half_life_days integer DEFAULT 90) RETURNS TABLE(id uuid, title text, source public.conversation_source, metadata jsonb, created_at timestamp with time zone, similarity double precision, recency_boost double precision, frequency_boost double precision, final_score double precision)
    LANGUAGE plpgsql
    AS $$
DECLARE
  max_retrieval int;
BEGIN
  -- Get max retrieval count for normalization
  SELECT GREATEST(MAX(c.retrieval_count), 1) INTO max_retrieval FROM conversations c;
  
  RETURN QUERY
  WITH scored AS (
    SELECT 
      c.id,
      c.title,
      c.source,
      c.metadata,
      c.created_at,
      (1 - (c.embedding <=> query_embedding))::float as sim,
      EXP(-EXTRACT(EPOCH FROM (NOW() - c.created_at)) / (half_life_days * 86400.0))::float as rec_boost,
      (LN(COALESCE(c.retrieval_count, 0) + 1) / LN(max_retrieval + 1))::float as freq_boost
    FROM conversations c
    WHERE c.embedding IS NOT NULL
      AND (1 - (c.embedding <=> query_embedding)) > match_threshold
  )
  SELECT 
    s.id, 
    s.title, 
    s.source, 
    s.metadata, 
    s.created_at,
    s.sim as similarity,
    s.rec_boost as recency_boost,
    s.freq_boost as frequency_boost,
    -- High similarity (>0.7) = pure similarity, else weighted
    CASE 
      WHEN s.sim > 0.7 THEN s.sim
      ELSE s.sim * 0.6 + s.rec_boost * 0.25 + s.freq_boost * 0.15
    END as final_score
  FROM scored s
  ORDER BY 
    CASE 
      WHEN s.sim > 0.7 THEN s.sim
      ELSE s.sim * 0.6 + s.rec_boost * 0.25 + s.freq_boost * 0.15
    END DESC
  LIMIT match_count;
END;
$$;


--
-- Name: search_conversations_semantic(public.vector, double precision, integer, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.search_conversations_semantic(query_embedding public.vector, match_threshold double precision DEFAULT 0.3, match_count integer DEFAULT 10, filter_source text DEFAULT NULL::text, filter_org text DEFAULT NULL::text) RETURNS TABLE(id uuid, title text, source public.conversation_source, org public.org_type, created_at timestamp with time zone, metadata jsonb, similarity double precision)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    c.id,
    c.title,
    c.source,
    c.org,
    c.created_at,
    c.metadata,
    1 - (c.embedding <=> query_embedding) AS similarity
  FROM conversations c
  WHERE c.embedding IS NOT NULL
    AND 1 - (c.embedding <=> query_embedding) > match_threshold
    AND (filter_source IS NULL OR c.source = filter_source::conversation_source)
    AND (filter_org IS NULL OR c.org = filter_org::org_type)
  ORDER BY c.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;


--
-- Name: search_lessons(text, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.search_lessons(p_query text, p_category text DEFAULT NULL::text, p_limit integer DEFAULT 5) RETURNS TABLE(id uuid, pattern text, rule text, category text, severity text, promoted_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    l.id,
    l.pattern,
    l.rule,
    l.category::TEXT,
    l.severity::TEXT,
    l.promoted_at
  FROM lessons l
  WHERE l.promoted_at IS NOT NULL
    AND (
      l.rule ILIKE '%' || p_query || '%'
      OR l.pattern ILIKE '%' || p_query || '%'
      OR l.context ILIKE '%' || p_query || '%'
    )
    AND (p_category IS NULL OR l.category::TEXT = p_category)
  ORDER BY l.promoted_at DESC
  LIMIT COALESCE(p_limit, 5);
END;
$$;


--
-- Name: search_lessons(text, text[], text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.search_lessons(p_category text DEFAULT NULL::text, p_tags text[] DEFAULT NULL::text[], p_agent_name text DEFAULT NULL::text, p_limit integer DEFAULT 10) RETURNS TABLE(id uuid, pattern text, rule text, context text, severity text, category text, example_bad text, example_good text, occurred_at timestamp with time zone, promoted_at timestamp with time zone, created_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    l.id,
    l.pattern,
    l.rule,
    l.context,
    l.severity,
    l.category,
    l.example_bad,
    l.example_good,
    l.occurred_at,
    l.promoted_at,
    l.created_at
  FROM lessons l
  WHERE 
    -- Only return promoted lessons
    l.promoted_at IS NOT NULL
    AND l.review_status = 'approved'
    -- Filter by category if provided
    AND (p_category IS NULL OR l.category = p_category)
    -- Filter by agent name if provided (check context field for mentions)
    AND (p_agent_name IS NULL OR 
         l.context ILIKE '%' || p_agent_name || '%' OR
         l.pattern ILIKE '%' || p_agent_name || '%')
    -- Filter by tag overlap if provided (check work_order_id's tags)
    AND (p_tags IS NULL OR 
         EXISTS (
           SELECT 1 FROM work_orders wo 
           WHERE wo.id = l.work_order_id 
           AND wo.tags && p_tags
         ))
  ORDER BY 
    -- Sort by severity (critical first) then recency
    CASE l.severity
      WHEN 'critical' THEN 1
      WHEN 'high' THEN 2
      WHEN 'medium' THEN 3
      WHEN 'low' THEN 4
      ELSE 5
    END,
    l.created_at DESC
  LIMIT p_limit;
END;
$$;


--
-- Name: FUNCTION search_lessons(p_category text, p_tags text[], p_agent_name text, p_limit integer); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.search_lessons(p_category text, p_tags text[], p_agent_name text, p_limit integer) IS 'Search promoted lessons with filters for category, tags, agent name. Returns top N by severity and recency.';


--
-- Name: set_agent_context(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_agent_context(p_agent_name text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_agent_id UUID;
BEGIN
  SELECT id INTO v_agent_id FROM agents WHERE name = p_agent_name AND status = 'active';
  
  IF v_agent_id IS NULL THEN
    RAISE EXCEPTION 'Agent not found or inactive: %', p_agent_name;
  END IF;
  
  PERFORM set_config('app.current_agent_id', v_agent_id::text, true);
  
  RETURN v_agent_id;
END;
$$;


--
-- Name: set_work_order_source(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_work_order_source() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Check for source in app context (set by Edge Functions)
  NEW.source := COALESCE(
    current_setting('app.wo_source', true),
    NEW.source,
    'direct'
  );
  
  -- Capture request ID if provided
  NEW.request_id := COALESCE(
    current_setting('app.request_id', true),
    NEW.request_id
  );
  
  RETURN NEW;
END;
$$;


--
-- Name: settle_children_on_parent_terminal(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.settle_children_on_parent_terminal() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.status IN ('done', 'cancelled', 'failed') AND OLD.status NOT IN ('done', 'cancelled', 'failed') THEN
    UPDATE work_orders SET status = 'cancelled', cancellation_reason = 'Parent ' || NEW.status
    WHERE parent_id = NEW.id AND status NOT IN ('done', 'cancelled', 'failed');
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION settle_children_on_parent_terminal(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.settle_children_on_parent_terminal() IS 'WO-0455 AC#2: Recursively cancel all descendant WOs when parent reaches done/cancelled';


--
-- Name: smart_restart_chain(uuid, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.smart_restart_chain(p_failed_wo_id uuid, p_restart_failed_deps boolean DEFAULT true) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_result jsonb;
  v_restarted uuid[];
  v_blocked uuid[];
  v_cancelled uuid[];
  v_dep record;
  v_dependent record;
BEGIN
  v_restarted := ARRAY[]::uuid[];
  v_blocked := ARRAY[]::uuid[];
  v_cancelled := ARRAY[]::uuid[];
  
  -- First, check if this WO has failed dependencies
  IF p_restart_failed_deps THEN
    FOR v_dep IN 
      SELECT wo.id, wo.slug, wo.status
      FROM work_orders wo
      WHERE wo.id IN (
        SELECT unnest(depends_on) 
        FROM work_orders 
        WHERE id = p_failed_wo_id
      )
      AND wo.status = 'failed'
    LOOP
      -- Recursively restart failed dependencies first
      PERFORM smart_restart_chain(v_dep.id, true);
      v_restarted := v_restarted || v_dep.id;
    END LOOP;
  END IF;
  
  -- Restart the failed WO itself
  UPDATE work_orders
  SET status = 'ready',
      started_at = NULL,
      completed_at = NULL,
      updated_at = now()
  WHERE id = p_failed_wo_id
    AND status = 'failed';
  
  IF FOUND THEN
    v_restarted := v_restarted || p_failed_wo_id;
    
    -- Log the restart
    INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
    VALUES ('smart_restart', 'system', 'smart_restart_chain',
            'work_order', p_failed_wo_id,
            'Smart restart from dependency failure',
            jsonb_build_object('restarted_count', array_length(v_restarted, 1)));
  END IF;
  
  -- Find all blocked dependents
  FOR v_dependent IN
    SELECT wo_id, wo_slug, wo_status
    FROM walk_dependency_chain(p_failed_wo_id)
    WHERE is_blocked = true
  LOOP
    v_blocked := v_blocked || v_dependent.wo_id;
  END LOOP;
  
  v_result := jsonb_build_object(
    'action', 'smart_restart',
    'root_wo_id', p_failed_wo_id,
    'restarted_wos', v_restarted,
    'restarted_count', array_length(v_restarted, 1),
    'blocked_wos', v_blocked,
    'blocked_count', array_length(v_blocked, 1)
  );
  
  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION smart_restart_chain(p_failed_wo_id uuid, p_restart_failed_deps boolean); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.smart_restart_chain(p_failed_wo_id uuid, p_restart_failed_deps boolean) IS 'Smart restart with cascade from root if dependencies failed';


--
-- Name: spawn_remediation_on_qa_failure(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.spawn_remediation_on_qa_failure() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  DECLARE
    v_finding_count int;
    v_already_has_remediation boolean;
    v_remediation_wo_id uuid;
  BEGIN
    IF NEW.status != 'review' OR OLD.status = 'review' THEN
      RETURN NEW;
    END IF;
    
    SELECT COUNT(*) INTO v_finding_count
    FROM qa_findings
    WHERE work_order_id = NEW.id
      AND finding_type = 'fail'
      AND resolved_at IS NULL;
    
    IF v_finding_count = 0 THEN
      RETURN NEW;
    END IF;
    
    SELECT EXISTS(SELECT 1 FROM work_orders WHERE parent_id = NEW.id AND 'remediation' = ANY(tags))
    INTO v_already_has_remediation;
    
    IF v_already_has_remediation THEN
      RETURN NEW;
    END IF;
    
    INSERT INTO work_orders (
      slug,
      name,
      objective,
      priority,
      status,
      source,
      tags,
      parent_id,
      created_by
    ) VALUES (
      'remediation-' || NEW.slug || '-' || to_char(NOW(), 'YYYYMMDD-HH24MISS'),
      'Remediate: ' || NEW.name,
      'Investigate and resolve fail findings for ' || NEW.slug || '. Review the fail findings in qa_findings table and implement fixes. After remediation, parent WO will be re-evaluated by QA.',
      LEAST(NEW.priority::text, 'p1_high'::text)::work_order_priority,
      'draft',
      'auto-qa',
      ARRAY['remediation', 'parent:' || NEW.slug],
      NEW.id,
      'engineering'
    )
    RETURNING id INTO v_remediation_wo_id;
    
    INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload, work_order_id)
    VALUES (
      'remediation_spawned',
      'system',
      'spawn_remediation_on_qa_failure',
      'work_order',
      v_remediation_wo_id,
      'create',
      jsonb_build_object(
        'parent_wo', NEW.slug,
        'finding_count', v_finding_count
      ),
      NEW.id
    );
    
    RETURN NEW;
  END;
END;
$$;


--
-- Name: spawn_remediation_on_qa_failure(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.spawn_remediation_on_qa_failure(p_work_order_id uuid, p_findings jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_parent_wo record;
  v_remediation_wo_id uuid;
  v_depth int := 0;
  v_current_id uuid;
BEGIN
  -- Get parent WO details
  SELECT * INTO v_parent_wo
  FROM work_orders
  WHERE id = p_work_order_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Work order % not found', p_work_order_id;
  END IF;

  -- Calculate depth (walk up parent chain)
  v_current_id := p_work_order_id;
  LOOP
    SELECT parent_id INTO v_current_id
    FROM work_orders
    WHERE id = v_current_id;
    
    EXIT WHEN v_current_id IS NULL;
    v_depth := v_depth + 1;
  END LOOP;

  -- DEPTH GUARD: Stop at depth 1 (changed from 3)
  IF v_depth >= 1 THEN
    -- Log and flag for human review instead of auto-creating remediation
    INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
    VALUES (
      p_work_order_id,
      'qa_validation',
      'qa-gate',
      jsonb_build_object(
        'event', 'remediation_depth_limit',
        'depth', v_depth,
        'message', 'Flagged for human review',
        'findings', p_findings
      )
    );
    RETURN NULL;
  END IF;

  -- Create remediation WO
  INSERT INTO work_orders (
    slug,
    name,
    objective,
    acceptance_criteria,
    priority,
    status,
    created_by,
    source,
    tags,
    parent_id,
    client_info
  )
  SELECT
    NULL, -- auto-generate slug
    'Fix: ' || v_parent_wo.name,
    'Remediate QA findings for ' || v_parent_wo.slug || E':\n\n' || 
    (p_findings->>'summary')::text,
    'Address the following QA findings:' || E'\n' ||
    (SELECT string_agg(
      '- ' || (value->>'description')::text,
      E'\n'
    ) FROM jsonb_array_elements(p_findings->'findings')),
    v_parent_wo.priority,
    'draft',
    'engineering',
    'auto-qa',
    array_append(v_parent_wo.tags, 'remediation'),
    p_work_order_id,
    jsonb_build_object(
      'parent_wo_id', p_work_order_id,
      'remediation_depth', v_depth + 1,
      'qa_findings', p_findings
    )
  RETURNING id INTO v_remediation_wo_id;

  -- Log remediation creation
  INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
  VALUES (
    p_work_order_id,
    'qa_validation',
    'qa-gate',
    jsonb_build_object(
      'event', 'remediation_spawned',
      'remediation_wo_id', v_remediation_wo_id,
      'depth', v_depth + 1
    )
  );

  RETURN v_remediation_wo_id;
END;
$$;


--
-- Name: start_batch_execution(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.start_batch_execution(p_batch_id uuid, p_executor_agent text DEFAULT 'builder'::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_validation JSONB;
  v_batch RECORD;
BEGIN
  -- Validate batch can be executed
  v_validation := validate_batch_execution(p_batch_id);
  
  IF NOT (v_validation->>'valid')::boolean THEN
    RETURN v_validation;
  END IF;

  -- Update batch execution timestamps
  UPDATE wo_batches
  SET 
    execution_started_at = NOW(),
    status = 'in_progress',
    updated_at = NOW()
  WHERE id = p_batch_id
  RETURNING * INTO v_batch;

  RETURN jsonb_build_object(
    'success', true,
    'batch_id', p_batch_id,
    'execution_mode', v_batch.execution_mode,
    'started_at', v_batch.execution_started_at
  );
END;
$$;


--
-- Name: FUNCTION start_batch_execution(p_batch_id uuid, p_executor_agent text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.start_batch_execution(p_batch_id uuid, p_executor_agent text) IS 'Starts batch execution and updates timestamps';


--
-- Name: start_interrogation(text, uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.start_interrogation(p_trigger_type text, p_project_id uuid DEFAULT NULL::uuid, p_thread_id uuid DEFAULT NULL::uuid, p_work_order_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_session_id UUID;
  v_initial_questions JSONB;
BEGIN
  v_initial_questions := '[
    {"domain": "user", "question": "Who is this for? Describe the target user.", "priority": 1},
    {"domain": "user", "question": "What problem does this solve for them?", "priority": 2},
    {"domain": "core", "question": "What is the core action a user takes?", "priority": 1},
    {"domain": "core", "question": "What happens when they complete that action?", "priority": 2},
    {"domain": "data", "question": "What data needs to be saved?", "priority": 1},
    {"domain": "data", "question": "What data needs to be displayed?", "priority": 2},
    {"domain": "flow", "question": "What happens on success?", "priority": 1},
    {"domain": "flow", "question": "What happens on error?", "priority": 2},
    {"domain": "auth", "question": "Does this require authentication? What level?", "priority": 1},
    {"domain": "technical", "question": "Does this need a database? What kind?", "priority": 1},
    {"domain": "technical", "question": "What external services or APIs are needed?", "priority": 2},
    {"domain": "constraints", "question": "What is explicitly out of scope?", "priority": 1},
    {"domain": "constraints", "question": "What are the non-negotiable requirements?", "priority": 2}
  ]'::jsonb;
  
  INSERT INTO interrogation_sessions (
    project_id, thread_id, work_order_id, trigger_type, questions_asked
  ) VALUES (
    p_project_id, p_thread_id, p_work_order_id, p_trigger_type, v_initial_questions
  ) RETURNING id INTO v_session_id;
  
  RETURN v_session_id;
END;
$$;


--
-- Name: start_wo_trace(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.start_wo_trace(p_work_order_id uuid, p_session_id text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_wo work_orders;
  v_trace_id TEXT;
BEGIN
  -- Get work order
  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  
  IF v_wo.id IS NULL THEN
    RAISE EXCEPTION 'Work order not found: %', p_work_order_id;
  END IF;
  
  -- Generate trace ID
  v_trace_id := 'wo-' || v_wo.slug || '-' || extract(epoch from now())::bigint;
  
  -- Create trace
  INSERT INTO traces (
    trace_id,
    name,
    session_id,
    work_order_id,
    input,
    metadata,
    status
  ) VALUES (
    v_trace_id,
    'WO Execution: ' || v_wo.name,
    COALESCE(p_session_id, 'direct-execution'),
    p_work_order_id,
    jsonb_build_object(
      'slug', v_wo.slug,
      'objective', v_wo.objective,
      'acceptance_criteria', v_wo.acceptance_criteria
    ),
    jsonb_build_object(
      'priority', v_wo.priority,
      'complexity', v_wo.complexity,
      'started_at', now()
    ),
    'running'
  );
  
  -- Set trace context for child operations
  PERFORM set_config('app.current_trace_id', v_trace_id, false);
  
  RETURN v_trace_id;
END;
$$;


--
-- Name: start_work_order(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.start_work_order(p_work_order_id uuid, p_agent_name text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_wo record;
    v_agent_id uuid;
    v_now timestamptz := now();
    v_result jsonb;
    v_gate_result jsonb;
BEGIN
    SELECT id INTO v_agent_id FROM agents WHERE name = p_agent_name AND status = 'active';
    IF v_agent_id IS NULL THEN
        RETURN jsonb_build_object('error', format('Agent not found or inactive: %s', p_agent_name));
    END IF;

    SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id FOR UPDATE;
    IF v_wo IS NULL THEN
        RETURN jsonb_build_object('error', 'Work order not found');
    END IF;

    IF v_wo.status NOT IN ('draft', 'ready', 'blocked') THEN
        RETURN jsonb_build_object('error', format('Cannot start WO in status: %s (must be draft, ready, or blocked)', v_wo.status));
    END IF;

    BEGIN
        v_gate_result := run_pre_execution_gate(p_work_order_id);
        IF v_gate_result IS NOT NULL AND v_gate_result->>'failed' = 'true' THEN
            RETURN jsonb_build_object('error', 'Pre-execution gate failed', 'gate_result', v_gate_result);
        END IF;
    EXCEPTION WHEN OTHERS THEN
        RAISE NOTICE 'Pre-execution gate error: %', SQLERRM;
    END;

    RETURN jsonb_build_object('status', 'would_continue');
END;
$$;


--
-- Name: state_read(text, jsonb, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.state_read(p_target_table text, p_filters jsonb DEFAULT '{}'::jsonb, p_limit integer DEFAULT 100) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  v_result JSONB;
  v_where_clause TEXT := '';
  v_key TEXT;
  v_value TEXT;
BEGIN
  FOR v_key, v_value IN SELECT * FROM jsonb_each_text(p_filters)
  LOOP
    IF v_where_clause = '' THEN
      v_where_clause := format('WHERE %I = %L', v_key, v_value);
    ELSE
      v_where_clause := v_where_clause || format(' AND %I = %L', v_key, v_value);
    END IF;
  END LOOP;

  EXECUTE format(
    'SELECT COALESCE(jsonb_agg(to_jsonb(t)), ''[]''::jsonb) FROM (SELECT * FROM %I %s LIMIT %s) t',
    p_target_table, v_where_clause, p_limit
  ) INTO v_result;

  RETURN v_result;
END;
$$;


--
-- Name: state_rollback(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.state_rollback(p_mutation_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
  v_mutation RECORD;
  v_rollback_mutation_id UUID;
  v_sql TEXT;
  v_result JSONB;
BEGIN
  SELECT * INTO v_mutation FROM state_mutations WHERE id = p_mutation_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'mutation_not_found');
  END IF;

  IF v_mutation.rolled_back_at IS NOT NULL THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', 'already_rolled_back',
      'rolled_back_at', v_mutation.rolled_back_at
    );
  END IF;

  -- Create inverse mutation record
  INSERT INTO state_mutations (
    mutation_type,
    target_table,
    target_id,
    payload,
    previous_state,
    work_order_id,
    agent_id,
    session_id
  ) VALUES (
    CASE 
      WHEN v_mutation.mutation_type = 'INSERT' THEN 'DELETE'
      WHEN v_mutation.mutation_type = 'DELETE' THEN 'INSERT'
      ELSE 'UPDATE'
    END,
    v_mutation.target_table,
    v_mutation.target_id,
    v_mutation.previous_state,
    v_mutation.payload,
    v_mutation.work_order_id,
    v_mutation.agent_id,
    v_mutation.session_id
  ) RETURNING id INTO v_rollback_mutation_id;

  -- Apply the rollback based on mutation type
  BEGIN
    CASE v_mutation.mutation_type
      WHEN 'INSERT' THEN
        -- Rollback INSERT: delete the row
        EXECUTE format('DELETE FROM %I WHERE id = $1', v_mutation.target_table)
        USING v_mutation.target_id;
        
      WHEN 'DELETE' THEN
        -- Rollback DELETE: restore previous_state
        IF v_mutation.previous_state IS NULL THEN
          RAISE EXCEPTION 'Cannot rollback DELETE: no previous_state stored';
        END IF;
        RAISE WARNING 'DELETE rollback not fully implemented - manual restore required';
        
      WHEN 'UPDATE' THEN
        -- Rollback UPDATE: restore previous_state fields
        IF v_mutation.previous_state IS NULL THEN
          RAISE EXCEPTION 'Cannot rollback UPDATE: no previous_state stored';
        END IF;
        RAISE WARNING 'UPDATE rollback requires table-specific logic - manual restore required';
    END CASE;

    -- Mark original mutation as rolled back
    UPDATE state_mutations
    SET 
      rolled_back_at = NOW(),
      rollback_mutation_id = v_rollback_mutation_id
    WHERE id = p_mutation_id;

    RETURN jsonb_build_object(
      'success', true,
      'mutation_id', p_mutation_id,
      'rollback_mutation_id', v_rollback_mutation_id,
      'mutation_type', v_mutation.mutation_type
    );
    
  EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', SQLERRM,
      'mutation_id', p_mutation_id
    );
  END;
END;
$_$;


--
-- Name: FUNCTION state_rollback(p_mutation_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.state_rollback(p_mutation_id uuid) IS 'WO-0076: Reverts a single state_mutation by applying inverse operation';


--
-- Name: state_write(text, text, jsonb, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.state_write(p_mutation_type text, p_target_table text, p_payload jsonb, p_work_order_id uuid DEFAULT NULL::uuid, p_agent_id uuid DEFAULT NULL::uuid, p_session_id text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_mutation_id UUID;
  v_target_id UUID;
  v_previous_state JSONB;
  v_protected_tables TEXT[] := ARRAY['system_manifest', 'work_orders', 'decisions', 'schema_changes'];
  v_columns TEXT;
  v_values TEXT;
  v_span_id UUID;
  v_trace_id TEXT;
  v_start_time TIMESTAMPTZ := clock_timestamp();
BEGIN
  -- Get or create trace context
  v_trace_id := current_setting('app.current_trace_id', true);
  
  -- Emit span for this mutation (if trace context exists)
  IF v_trace_id IS NOT NULL AND v_trace_id != '' THEN
    v_span_id := emit_harness_span(
      v_trace_id,
      'db-query',
      'state_write:' || p_mutation_type || ':' || p_target_table,
      jsonb_build_object(
        'mutation_type', p_mutation_type,
        'target_table', p_target_table,
        'payload_keys', (SELECT jsonb_agg(key) FROM jsonb_object_keys(p_payload) AS key),
        'work_order_id', p_work_order_id
      ),
      jsonb_build_object('agent_id', p_agent_id, 'session_id', p_session_id)
    );
  END IF;

  -- Require work order for protected tables
  IF p_target_table = ANY(v_protected_tables) AND p_work_order_id IS NULL THEN
    IF v_span_id IS NOT NULL THEN
      PERFORM complete_harness_span(v_span_id, NULL, 'error', 'Work order required for ' || p_target_table);
    END IF;
    RAISE EXCEPTION 'Work order required for mutations to %', p_target_table;
  END IF;

  -- Validate work order if provided
  IF p_work_order_id IS NOT NULL THEN
    PERFORM wo_enforcer(p_work_order_id);
  END IF;

  -- Set bypass flag for triggers
  PERFORM set_config('app.state_write_bypass', 'true', true);

  -- Extract or generate target ID
  v_target_id := (p_payload->>'id')::UUID;
  IF v_target_id IS NULL AND p_mutation_type = 'INSERT' THEN
    v_target_id := gen_random_uuid();
    p_payload := jsonb_set(p_payload, '{id}', to_jsonb(v_target_id::text));
  END IF;
  
  -- Capture previous state for UPDATE/DELETE
  IF v_target_id IS NOT NULL AND p_mutation_type IN ('UPDATE', 'DELETE') THEN
    EXECUTE format('SELECT to_jsonb(t) FROM %I t WHERE id = $1', p_target_table)
    INTO v_previous_state
    USING v_target_id;
  END IF;

  -- Log mutation first
  INSERT INTO state_mutations (
    mutation_type, target_table, target_id, payload, 
    previous_state, work_order_id, agent_id, session_id
  ) VALUES (
    p_mutation_type, p_target_table, v_target_id, p_payload,
    v_previous_state, p_work_order_id, p_agent_id, p_session_id
  ) RETURNING id INTO v_mutation_id;

  -- Execute based on mutation type
  IF p_mutation_type = 'INSERT' THEN
    SELECT 
      string_agg(quote_ident(key), ', '),
      string_agg(
        CASE 
          WHEN jsonb_typeof(p_payload->key) = 'null' THEN 'NULL'
          WHEN jsonb_typeof(p_payload->key) = 'string' THEN quote_literal(p_payload->>key)
          WHEN jsonb_typeof(p_payload->key) IN ('number', 'boolean') THEN p_payload->>key
          ELSE quote_literal((p_payload->key)::text) || '::jsonb'
        END, ', '
      )
    INTO v_columns, v_values
    FROM jsonb_object_keys(p_payload) AS key
    WHERE key NOT IN (
      SELECT column_name FROM information_schema.columns 
      WHERE table_schema = 'public' AND table_name = p_target_table AND is_generated = 'ALWAYS'
    );
    
    EXECUTE format('INSERT INTO %I (%s) VALUES (%s)', p_target_table, v_columns, v_values);
    UPDATE state_mutations SET target_id = v_target_id WHERE id = v_mutation_id;
    
  ELSIF p_mutation_type = 'UPDATE' THEN
    IF v_target_id IS NULL THEN
      IF v_span_id IS NOT NULL THEN
        PERFORM complete_harness_span(v_span_id, NULL, 'error', 'UPDATE requires id in payload');
      END IF;
      RAISE EXCEPTION 'UPDATE requires id in payload';
    END IF;
    
    SELECT string_agg(
      quote_ident(key) || ' = ' ||
      CASE 
        WHEN jsonb_typeof(p_payload->key) = 'null' THEN 'NULL'
        WHEN jsonb_typeof(p_payload->key) = 'string' THEN quote_literal(p_payload->>key)
        WHEN jsonb_typeof(p_payload->key) IN ('number', 'boolean') THEN p_payload->>key
        ELSE quote_literal((p_payload->key)::text) || '::jsonb'
      END, ', '
    ) INTO v_values
    FROM jsonb_object_keys(p_payload) AS key
    WHERE key != 'id' AND key NOT IN (
      SELECT column_name FROM information_schema.columns 
      WHERE table_schema = 'public' AND table_name = p_target_table AND is_generated = 'ALWAYS'
    );
    
    IF v_values IS NOT NULL THEN
      EXECUTE format('UPDATE %I SET %s WHERE id = $1', p_target_table, v_values) USING v_target_id;
    END IF;
    
  ELSIF p_mutation_type = 'DELETE' THEN
    IF v_target_id IS NULL THEN
      IF v_span_id IS NOT NULL THEN
        PERFORM complete_harness_span(v_span_id, NULL, 'error', 'DELETE requires id in payload');
      END IF;
      RAISE EXCEPTION 'DELETE requires id in payload';
    END IF;
    
    EXECUTE format('DELETE FROM %I WHERE id = $1', p_target_table) USING v_target_id;
  END IF;

  -- Clear bypass flag
  PERFORM set_config('app.state_write_bypass', 'false', true);

  -- Complete the span successfully
  IF v_span_id IS NOT NULL THEN
    PERFORM complete_harness_span(
      v_span_id,
      jsonb_build_object(
        'mutation_id', v_mutation_id,
        'target_id', v_target_id,
        'duration_ms', EXTRACT(EPOCH FROM (clock_timestamp() - v_start_time)) * 1000
      ),
      'completed'
    );
  END IF;

  RETURN v_mutation_id;
EXCEPTION WHEN OTHERS THEN
  -- Complete span with error
  IF v_span_id IS NOT NULL THEN
    PERFORM complete_harness_span(v_span_id, NULL, 'error', SQLERRM);
  END IF;
  -- Clear bypass flag on error
  PERFORM set_config('app.state_write_bypass', 'false', true);
  RAISE;
END;
$_$;


--
-- Name: store_conversation_messages(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.store_conversation_messages(p_conversation_id uuid, p_messages jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  msg jsonb;
  seq int := 0;
BEGIN
  FOR msg IN SELECT * FROM jsonb_array_elements(p_messages)
  LOOP
    seq := seq + 1;
    INSERT INTO messages (
      conversation_id,
      role,
      content,
      sequence,
      created_at
    ) VALUES (
      p_conversation_id,
      (msg->>'role')::message_role,
      msg->>'content',
      seq,
      NOW()
    )
    ON CONFLICT DO NOTHING;
  END LOOP;
END;
$$;


--
-- Name: submit_interrogation_answer(uuid, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.submit_interrogation_answer(p_session_id uuid, p_domain text, p_answers jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_session interrogation_sessions;
  v_all_domains TEXT[];
  v_answered_domains TEXT[];
  v_remaining TEXT[];
  v_all_done BOOLEAN;
BEGIN
  SELECT * INTO v_session FROM interrogation_sessions WHERE id = p_session_id;
  
  IF v_session.id IS NULL THEN
    RETURN jsonb_build_object('error', 'Session not found');
  END IF;
  
  IF v_session.status != 'in_progress' THEN
    RETURN jsonb_build_object('error', format('Session is %s, not in_progress', v_session.status));
  END IF;

  -- Check if domain already completed
  IF p_domain = ANY(COALESCE(v_session.domains_completed, ARRAY[]::TEXT[])) THEN
    RETURN jsonb_build_object('error', format('Domain %s already completed', p_domain));
  END IF;

  -- Merge answers into answers_received under the domain key
  UPDATE interrogation_sessions
  SET 
    answers_received = COALESCE(answers_received, '{}'::jsonb) || jsonb_build_object(p_domain, p_answers),
    domains_completed = array_append(
      COALESCE(domains_completed, ARRAY[]::TEXT[]),
      p_domain
    ),
    updated_at = NOW()
  WHERE id = p_session_id;

  -- Get all unique domains from questions
  SELECT ARRAY(
    SELECT DISTINCT q->>'domain' 
    FROM interrogation_sessions s, jsonb_array_elements(s.questions_asked) q
    WHERE s.id = p_session_id
  ) INTO v_all_domains;

  -- Get completed domains
  SELECT domains_completed INTO v_answered_domains
  FROM interrogation_sessions WHERE id = p_session_id;

  -- Compute remaining
  SELECT ARRAY(
    SELECT unnest(v_all_domains) 
    EXCEPT 
    SELECT unnest(v_answered_domains)
  ) INTO v_remaining;

  v_all_done := (array_length(v_remaining, 1) IS NULL OR array_length(v_remaining, 1) = 0);

  -- Auto-complete session when all domains answered
  IF v_all_done THEN
    UPDATE interrogation_sessions
    SET 
      status = 'completed',
      completed_at = NOW(),
      summary = format('Interrogation completed: %s domains answered (%s)', 
        array_length(v_all_domains, 1),
        array_to_string(v_all_domains, ', ')),
      updated_at = NOW()
    WHERE id = p_session_id;
  END IF;

  RETURN jsonb_build_object(
    'session_id', p_session_id,
    'domain_submitted', p_domain,
    'domains_completed', v_answered_domains,
    'domains_remaining', v_remaining,
    'all_answered', v_all_done,
    'session_status', CASE WHEN v_all_done THEN 'completed' ELSE 'in_progress' END
  );
END;
$$;


--
-- Name: sync_object_registry(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_object_registry() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_rec RECORD;
    v_existing_count int;
    v_current_count int;
BEGIN
    -- PHASE 1: Mark all current tables as needing verification
    UPDATE object_registry SET auto_populated = false 
    WHERE object_type = 'table' AND auto_populated = true;

    -- PHASE 2: Sync current tables (CREATE/UPDATE)
    FOR v_rec IN
        SELECT table_schema || '.' || table_name AS full_name,
               table_name AS simple_name,
               table_schema
        FROM information_schema.tables 
        WHERE table_schema NOT IN ('pg_catalog', 'information_schema', 'extensions')
          AND table_type = 'BASE TABLE'
    LOOP
        INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
        VALUES ('table', v_rec.simple_name, 
            jsonb_build_object('schema', v_rec.table_schema, 'row_estimate', 
                (SELECT COALESCE(n_live_tup, 0)::int FROM pg_stat_user_tables 
                 WHERE relname = v_rec.simple_name AND schemaname = v_rec.table_schema)),
            ARRAY['SELECT','INSERT','UPDATE','DELETE','ALTER','DROP'], true, NOW())
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET properties = EXCLUDED.properties,
            auto_populated = true;
    END LOOP;

    -- PHASE 3-8: Sync functions, indexes, triggers, policies (same as before)
    -- Functions
    FOR v_rec IN
        SELECT p.oid::regproc::text AS func_name,
               n.nspname AS schema_name
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
          AND p.prokind = 'f'
    LOOP
        INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
        VALUES ('function', v_rec.func_name, 
            jsonb_build_object('schema', v_rec.schema_name),
            ARRAY['EXECUTE','ALTER','DROP'], true, NOW())
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET auto_populated = true;
    END LOOP;

    -- Indexes
    FOR v_rec IN
        SELECT indexrelname AS idx_name,
               relname AS table_name,
               schemaname
        FROM pg_stat_user_indexes
        WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
    LOOP
        INSERT INTO object_registry (object_type, object_name, parent_id, properties, valid_actions, auto_populated, created_at)
        SELECT 'index', v_rec.idx_name, id, 
            jsonb_build_object('schema', v_rec.schemaname),
            ARRAY['DROP'], true, NOW()
        FROM object_registry 
        WHERE object_type = 'table' AND object_name = v_rec.table_name
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET auto_populated = true;
    END LOOP;

    -- Triggers
    FOR v_rec IN
        SELECT t.tgname AS trigger_name,
               c.relname AS table_name,
               n.nspname AS schema_name
        FROM pg_trigger t
        JOIN pg_class c ON t.tgrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE NOT t.tgisinternal
          AND n.nspname NOT IN ('pg_catalog', 'information_schema')
    LOOP
        INSERT INTO object_registry (object_type, object_name, parent_id, properties, valid_actions, auto_populated, created_at)
        SELECT 'trigger', v_rec.trigger_name, id,
            jsonb_build_object('schema', v_rec.schema_name),
            ARRAY['DROP'], true, NOW()
        FROM object_registry 
        WHERE object_type = 'table' AND object_name = v_rec.table_name
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET auto_populated = true;
    END LOOP;

    -- Policies
    FOR v_rec IN
        SELECT polname AS policy_name,
               c.relname AS table_name,
               n.nspname AS schema_name
        FROM pg_policy pol
        JOIN pg_class c ON pol.polrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
    LOOP
        INSERT INTO object_registry (object_type, object_name, parent_id, properties, valid_actions, auto_populated, created_at)
        SELECT 'policy', v_rec.policy_name, id,
            jsonb_build_object('schema', v_rec.schema_name),
            ARRAY['DROP','ALTER'], true, NOW()
        FROM object_registry 
        WHERE object_type = 'table' AND object_name = v_rec.table_name
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET auto_populated = true;
    END LOOP;

    -- PHASE 9: Refresh materialized view
    REFRESH MATERIALIZED VIEW CONCURRENTLY action_success_rates;
END;
$$;


--
-- Name: sync_object_registry_full(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_object_registry_full() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_table RECORD;
    v_function RECORD;
    v_trigger RECORD;
    v_index RECORD;
    v_policy RECORD;
BEGIN
    -- Sync all tables
    FOR v_table IN 
        SELECT schemaname, tablename 
        FROM pg_tables 
        WHERE schemaname NOT IN ('pg_catalog', 'information_schema', 'extensions')
    LOOP
        INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
        VALUES (
            'table', 
            v_table.schemaname || '.' || v_table.tablename,
            '{}'::jsonb,
            ARRAY['SELECT','INSERT','UPDATE','DELETE','ALTER','DROP'],
            true,
            NOW()
        )
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET auto_populated = true;
    END LOOP;

    -- Sync all functions
    FOR v_function IN 
        SELECT n.nspname, p.proname 
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
        AND p.prokind = 'f'
    LOOP
        INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
        VALUES (
            'function', 
            v_function.proname,
            '{}'::jsonb,
            ARRAY['EXECUTE','ALTER','DROP'],
            true,
            NOW()
        )
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET auto_populated = true;
    END LOOP;

    -- Sync all triggers
    FOR v_trigger IN 
        SELECT t.tgname, c.relname as table_name, n.nspname as schema_name
        FROM pg_trigger t
        JOIN pg_class c ON t.tgrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE NOT t.tgisinternal
        AND n.nspname NOT IN ('pg_catalog', 'information_schema')
    LOOP
        INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
        VALUES (
            'trigger', 
            v_trigger.schema_name || '.' || v_trigger.table_name || '.' || v_trigger.tgname,
            '{}'::jsonb,
            ARRAY['DROP'],
            true,
            NOW()
        )
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET auto_populated = true;
    END LOOP;

    -- Sync all indexes (excluding primary and unique)
    FOR v_index IN 
        SELECT i.relname as index_name, t.relname as table_name, n.nspname as schema_name
        FROM pg_index x
        JOIN pg_class i ON i.oid = x.indexrelid
        JOIN pg_class t ON t.oid = x.indrelid
        JOIN pg_namespace n ON t.relnamespace = n.oid
        WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
        AND NOT x.indisprimary
        AND NOT x.indisunique
    LOOP
        INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
        VALUES (
            'index', 
            v_index.index_name,
            '{}'::jsonb,
            ARRAY['DROP'],
            true,
            NOW()
        )
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET auto_populated = true;
    END LOOP;

    -- Sync all policies
    FOR v_policy IN 
        SELECT polname, polrelid::regclass as table_name
        FROM pg_policy
        WHERE NOT polpermissive
    LOOP
        INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
        VALUES (
            'policy', 
            v_policy.table_name || '.' || v_policy.polname,
            '{}'::jsonb,
            ARRAY['DROP','ALTER'],
            true,
            NOW()
        )
        ON CONFLICT (object_type, object_name) DO UPDATE
        SET auto_populated = true;
    END LOOP;

    -- Refresh materialized view
    REFRESH MATERIALIZED VIEW CONCURRENTLY action_success_rates;
END;
$$;


--
-- Name: sync_object_registry_manual(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_object_registry_manual() RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_count INT := 0;
    v_cmd TEXT;
BEGIN
    -- For manual invocation, we'll do a full sync like populate_object_registry
    -- This is the fallback when event trigger can't be created
    
    -- Just call the event-driven function's core logic in a compatible way
    -- Since we can't call pg_event_trigger_ddl_commands() outside event trigger context,
    -- we'll use the existing populate_object_registry approach
    
    PERFORM populate_object_registry();
    
    -- Get count of synced objects
    SELECT COUNT(*) INTO v_count FROM object_registry WHERE auto_populated = true;
    
    RETURN jsonb_build_object(
        'synced_count', v_count,
        'method', 'manual_full_sync',
        'note', 'Event trigger creation blocked - using manual sync. Contact Supabase admin to enable event triggers.'
    );
END;
$$;


--
-- Name: sync_object_registry_on_ddl(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_object_registry_on_ddl() RETURNS event_trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_cmd RECORD;
    v_obj_type TEXT;
    v_obj_name TEXT;
    v_properties JSONB;
    v_actions TEXT[];
    v_parent_name TEXT;
    v_parent_id UUID;
BEGIN
    FOR v_cmd IN SELECT * FROM pg_event_trigger_ddl_commands() LIMIT 100
    LOOP
        CASE v_cmd.command_tag
            WHEN 'CREATE TABLE' THEN
                v_obj_type := 'table'; v_obj_name := v_cmd.object_identity;
                v_actions := ARRAY['SELECT','INSERT','UPDATE','DELETE','ALTER','DROP'];
                v_properties := jsonb_build_object('row_estimate', 0);
                INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
                VALUES (v_obj_type, v_obj_name, v_properties, v_actions, true, NOW())
                ON CONFLICT (object_type, object_name) DO UPDATE
                SET properties = EXCLUDED.properties, valid_actions = EXCLUDED.valid_actions, auto_populated = true;

            WHEN 'ALTER TABLE' THEN
                v_obj_type := 'table'; v_obj_name := v_cmd.object_identity;
                v_actions := ARRAY['SELECT','INSERT','UPDATE','DELETE','ALTER','DROP'];
                INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
                VALUES (v_obj_type, v_obj_name, '{}'::jsonb, v_actions, true, NOW())
                ON CONFLICT (object_type, object_name) DO UPDATE SET auto_populated = true;

            WHEN 'CREATE FUNCTION' THEN
                v_obj_type := 'function';
                v_obj_name := COALESCE(split_part(v_cmd.object_identity, '.', 2), v_cmd.object_identity);
                v_actions := ARRAY['EXECUTE','ALTER','DROP'];
                v_properties := '{}'::jsonb;
                INSERT INTO object_registry (object_type, object_name, properties, valid_actions, auto_populated, created_at)
                VALUES (v_obj_type, v_obj_name, v_properties, v_actions, true, NOW())
                ON CONFLICT (object_type, object_name) DO UPDATE
                SET properties = EXCLUDED.properties, valid_actions = EXCLUDED.valid_actions, auto_populated = true;

            WHEN 'CREATE TRIGGER' THEN
                v_obj_type := 'trigger'; v_obj_name := v_cmd.object_identity;
                v_actions := ARRAY['DROP'];
                v_parent_name := split_part(v_cmd.object_identity, '.', 1);
                SELECT id INTO v_parent_id FROM object_registry WHERE object_type = 'table' AND object_name = v_parent_name;
                INSERT INTO object_registry (object_type, object_name, parent_id, properties, valid_actions, auto_populated, created_at)
                VALUES (v_obj_type, v_obj_name, v_parent_id, '{}'::jsonb, v_actions, true, NOW())
                ON CONFLICT (object_type, object_name) DO UPDATE
                SET parent_id = COALESCE(EXCLUDED.parent_id, object_registry.parent_id), auto_populated = true;

            WHEN 'CREATE INDEX' THEN
                v_obj_type := 'index'; v_obj_name := v_cmd.object_identity;
                v_actions := ARRAY['DROP'];
                v_parent_name := split_part(v_obj_name, '_', 1);
                SELECT id INTO v_parent_id FROM object_registry WHERE object_type = 'table' AND object_name = v_parent_name;
                INSERT INTO object_registry (object_type, object_name, parent_id, properties, valid_actions, auto_populated, created_at)
                VALUES (v_obj_type, v_obj_name, v_parent_id, '{}'::jsonb, v_actions, true, NOW())
                ON CONFLICT (object_type, object_name) DO UPDATE
                SET parent_id = COALESCE(EXCLUDED.parent_id, object_registry.parent_id), auto_populated = true;

            WHEN 'CREATE POLICY' THEN
                v_obj_type := 'policy'; v_obj_name := v_cmd.object_identity;
                v_actions := ARRAY['DROP','ALTER'];
                v_parent_name := split_part(v_obj_name, '.', 1);
                SELECT id INTO v_parent_id FROM object_registry WHERE object_type = 'table' AND object_name = v_parent_name;
                INSERT INTO object_registry (object_type, object_name, parent_id, properties, valid_actions, auto_populated, created_at)
                VALUES (v_obj_type, v_obj_name, v_parent_id, '{}'::jsonb, v_actions, true, NOW())
                ON CONFLICT (object_type, object_name) DO UPDATE
                SET parent_id = COALESCE(EXCLUDED.parent_id, object_registry.parent_id), auto_populated = true;

            WHEN 'DROP TABLE' THEN
                UPDATE object_registry SET auto_populated = false WHERE object_type = 'table' AND object_name = v_cmd.object_identity;
            WHEN 'DROP FUNCTION' THEN
                v_obj_name := COALESCE(split_part(v_cmd.object_identity, '.', 2), v_cmd.object_identity);
                UPDATE object_registry SET auto_populated = false WHERE object_type = 'function' AND object_name = v_obj_name;
            WHEN 'DROP TRIGGER' THEN
                UPDATE object_registry SET auto_populated = false WHERE object_type = 'trigger' AND object_name = v_cmd.object_identity;
            WHEN 'DROP INDEX' THEN
                UPDATE object_registry SET auto_populated = false WHERE object_type = 'index' AND object_name = v_cmd.object_identity;
            WHEN 'DROP POLICY' THEN
                UPDATE object_registry SET auto_populated = false WHERE object_type = 'policy' AND object_name = v_cmd.object_identity;
            ELSE
                NULL;
        END CASE;
    END LOOP;

    -- Refresh materialized view (non-blocking, ignore errors during migrations)
    BEGIN
        REFRESH MATERIALIZED VIEW CONCURRENTLY action_success_rates;
    EXCEPTION WHEN OTHERS THEN
        -- Silently skip refresh if it fails (e.g., during transaction-wrapped migrations)
        NULL;
    END;
END;
$$;


--
-- Name: sync_object_registry_safe(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_object_registry_safe() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY action_success_rates;
END;
$$;


--
-- Name: sync_project_context_to_kb(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_project_context_to_kb() RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_context RECORD;
  v_inserted_count INT := 0;
  v_updated_count INT := 0;
  v_result jsonb;
BEGIN
  -- Get the latest project_context
  SELECT * INTO v_context
  FROM project_context
  ORDER BY updated_at DESC
  LIMIT 1;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'No project_context found'
    );
  END IF;
  
  -- Insert or update Current Focus
  INSERT INTO agent_knowledge_base (category, topic, content, applicable_roles, applicable_tags, severity, active)
  VALUES (
    'project_context',
    v_context.project_name || ' Current Focus',
    'Current focus: ' || v_context.current_focus,
    ARRAY['executor'],
    ARRAY['server-side-agent', 'supabase'],
    'important',  -- Changed from 'medium'
    true
  )
  ON CONFLICT (topic) DO UPDATE
  SET content = EXCLUDED.content,
      updated_at = NOW();
      
  GET DIAGNOSTICS v_inserted_count = ROW_COUNT;
  
  -- Insert or update Architecture
  INSERT INTO agent_knowledge_base (category, topic, content, applicable_roles, applicable_tags, severity, active)
  VALUES (
    'project_context',
    v_context.project_name || ' Architecture',
    'Architecture components: ' || (v_context.architecture->>'components')::text || '. MCP connections: ' || (v_context.architecture->'connections'->>'mcp')::text,
    ARRAY['executor'],
    ARRAY['server-side-agent', 'supabase'],
    'important',  -- Changed from 'medium'
    true
  )
  ON CONFLICT (topic) DO UPDATE
  SET content = EXCLUDED.content,
      updated_at = NOW();
  
  -- Insert or update Last Session
  INSERT INTO agent_knowledge_base (category, topic, content, applicable_roles, applicable_tags, severity, active)
  VALUES (
    'project_context',
    v_context.project_name || ' Last Session',
    'Last session summary: ' || v_context.last_session_summary,
    ARRAY['executor'],
    ARRAY['server-side-agent', 'supabase'],
    'reference',  -- Changed from 'medium'
    true
  )
  ON CONFLICT (topic) DO UPDATE
  SET content = EXCLUDED.content,
      updated_at = NOW();
  
  -- Insert or update Key Decisions (concatenate top 5)
  INSERT INTO agent_knowledge_base (category, topic, content, applicable_roles, applicable_tags, severity, active)
  VALUES (
    'project_context',
    v_context.project_name || ' Key Decisions',
    'Recent architectural decisions: ' || (
      SELECT string_agg(
        (d->>'date') || ': ' || (d->>'decision') || ' (Rationale: ' || (d->>'rationale') || ')',
        E'\n'
      )
      FROM jsonb_array_elements(v_context.decisions) d
      LIMIT 5
    ),
    ARRAY['executor'],
    ARRAY['server-side-agent', 'supabase'],
    'critical',  -- Changed from 'high'
    true
  )
  ON CONFLICT (topic) DO UPDATE
  SET content = EXCLUDED.content,
      updated_at = NOW();
  
  RETURN jsonb_build_object(
    'success', true,
    'synced', true,
    'project', v_context.project_name
  );
END;
$$;


--
-- Name: FUNCTION sync_project_context_to_kb(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.sync_project_context_to_kb() IS 'Syncs latest project_context to agent_knowledge_base for builder agent consumption';


--
-- Name: sync_promoted_lessons_to_kb(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_promoted_lessons_to_kb() RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_synced integer := 0;
  v_skipped integer := 0;
  v_lesson record;
  v_kb_category text;
  v_roles text[];
  v_topic text;
BEGIN
  FOR v_lesson IN
    SELECT l.id, l.pattern, l.rule, l.category, l.severity, l.promoted_at
    FROM lessons l
    WHERE l.promoted_at IS NOT NULL
      -- Only sync actionable lessons, not auto-error-logging
      AND l.rule NOT LIKE 'Work order execution failed%'
      AND l.rule NOT LIKE 'Decision gate blocked%'
      AND l.rule NOT LIKE 'Investigate and resolve%'
      -- Don't re-sync if already in KB
      AND NOT EXISTS (
        SELECT 1 FROM agent_knowledge_base akb
        WHERE akb.topic = 'lesson_' || l.id::text
      )
    ORDER BY 
      CASE l.severity WHEN 'critical' THEN 1 WHEN 'high' THEN 2 WHEN 'error' THEN 3 ELSE 4 END,
      l.promoted_at DESC
    LIMIT 30
  LOOP
    -- Map lesson category to KB category
    v_kb_category := CASE v_lesson.category
      WHEN 'state_machine' THEN 'enforcement'
      WHEN 'hallucination' THEN 'best_practice'
      WHEN 'scope_creep' THEN 'process'
      WHEN 'tool_misuse' THEN 'best_practice'
      WHEN 'format_violation' THEN 'best_practice'
      WHEN 'context_loss' THEN 'operational'
      WHEN 'incorrect_assumption' THEN 'best_practice'
      WHEN 'security' THEN 'enforcement'
      WHEN 'performance' THEN 'operational'
      WHEN 'authorization' THEN 'enforcement'
      WHEN 'intake_gate' THEN 'process'
      ELSE v_lesson.category  -- execution, approval_flow, general map directly
    END;

    -- Map lesson category to applicable agent roles
    v_roles := CASE v_lesson.category
      WHEN 'execution' THEN ARRAY['executor', 'builder']
      WHEN 'state_machine' THEN ARRAY['executor', 'builder', 'ops']
      WHEN 'approval_flow' THEN ARRAY['executor', 'builder', 'ops']
      WHEN 'scope_creep' THEN ARRAY['executor', 'builder', 'qa-gate']
      WHEN 'hallucination' THEN ARRAY['executor', 'builder', 'qa-gate']
      WHEN 'security' THEN ARRAY['executor', 'builder']
      WHEN 'performance' THEN ARRAY['executor', 'builder']
      ELSE ARRAY['executor', 'builder']
    END;

    -- Use lesson ID as topic for deduplication
    v_topic := 'lesson_' || v_lesson.id::text;

    INSERT INTO agent_knowledge_base (
      id, category, topic, content, applicable_roles, applicable_tags, severity, active
    ) VALUES (
      gen_random_uuid(),
      v_kb_category,
      v_topic,
      '[' || v_lesson.severity || '] ' || v_lesson.pattern || ': ' || v_lesson.rule,
      v_roles,
      ARRAY[]::text[],
      v_lesson.severity,
      true
    )
    ON CONFLICT DO NOTHING;

    v_synced := v_synced + 1;
  END LOOP;

  RETURN jsonb_build_object(
    'synced', v_synced,
    'skipped', v_skipped,
    'timestamp', now()
  );
END;
$$;


--
-- Name: sync_spec_to_tables(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_spec_to_tables(p_spec_id integer) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_spec jsonb;
  v_version text;
  v_elem jsonb;
  v_sm_count int := 0;
  v_er_count int := 0;
  v_status text;
  v_eff_arr jsonb;
  v_eff jsonb;
BEGIN
  SELECT spec, version INTO v_spec, v_version
  FROM kernel_spec WHERE id = p_spec_id;
  
  IF v_spec IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Spec not found for id: ' || p_spec_id);
  END IF;

  -- Sync wo_state_machine: delete all, re-insert from spec transitions
  DELETE FROM wo_state_machine;

  FOR v_elem IN SELECT value FROM jsonb_array_elements(v_spec->'transitions')
  LOOP
    INSERT INTO wo_state_machine (from_status, event, to_status, guard_function, effects, enabled)
    VALUES (
      (v_elem->>'from_status')::work_order_status,
      v_elem->>'event',
      (v_elem->>'to_status')::work_order_status,
      v_elem->>'guard',
      COALESCE(v_elem->'effects', '[]'::jsonb),
      COALESCE((v_elem->>'enabled')::boolean, true)
    );
    v_sm_count := v_sm_count + 1;
  END LOOP;

  -- Sync wo_effect_registry: delete all, re-insert from spec effects (object keyed by status)
  DELETE FROM wo_effect_registry;

  FOR v_status IN SELECT jsonb_object_keys(v_spec->'effects')
  LOOP
    v_eff_arr := v_spec->'effects'->v_status;
    FOR v_eff IN SELECT value FROM jsonb_array_elements(v_eff_arr)
    LOOP
      INSERT INTO wo_effect_registry (
        trigger_on_status, effect_type, handler, execution_order, enabled, config
      )
      VALUES (
        v_status::work_order_status,
        v_eff->>'type',
        COALESCE(v_eff->>'handler', 'sql_call'),
        COALESCE((v_eff->>'order')::int, 10),
        true,
        COALESCE(v_eff->'config', '{}'::jsonb)
      );
      v_er_count := v_er_count + 1;
    END LOOP;
  END LOOP;

  RETURN jsonb_build_object(
    'success', true,
    'spec_version', v_version,
    'state_machine_rows', v_sm_count,
    'effect_registry_rows', v_er_count
  );
END;
$$;


--
-- Name: test_advance_pipeline(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.test_advance_pipeline(p_pipeline_run_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_result JSONB;
BEGIN
    v_result := public.advance_pipeline_phase(p_pipeline_run_id, NULL::uuid);
    RETURN v_result;
END;
$$;


--
-- Name: test_mcts_statistical_validity(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.test_mcts_statistical_validity() RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_test_wo_id UUID;
    v_high_ids UUID[];
    v_low_ids UUID[];
    v_result JSONB;
    v_test_results JSONB := '{"tests": []}'::jsonb;
    v_pass_count INT := 0;
    v_fail_count INT := 0;
    v_ci_100 NUMERIC; v_ci_500 NUMERIC; v_ci_2500 NUMERIC;
    v_ratio_1 NUMERIC; v_ratio_2 NUMERIC;
    v_expected_ratio_1 NUMERIC; v_expected_ratio_2 NUMERIC;
    v_mean_rate NUMERIC; v_theoretical NUMERIC; v_wilson_a NUMERIC; v_deviation NUMERIC;
    v_high_rate NUMERIC; v_low_rate NUMERIC; v_z_disc NUMERIC; v_p_disc NUMERIC; v_se_disc NUMERIC;
    v_run_results NUMERIC[]; v_stability_mean NUMERIC; v_stability_std NUMERIC; v_cv NUMERIC;
    v_test_detail JSONB; v_i INT;
BEGIN
    PERFORM set_config('app.wo_transition_active', 'true', true);
    
    INSERT INTO work_orders (slug, name, objective, status, priority, created_by, source, approved_at, completed_at, acceptance_criteria)
    VALUES ('__test_mcts_validity', '__test_mcts_validity', 'Statistical validation of MCTS', 'done', 'p3_low', 'engineering', 'test_suite', now(), now(), '1. Run MCTS statistical validation tests')
    RETURNING id INTO v_test_wo_id;
    
    WITH ins AS (
        INSERT INTO object_registry (object_type, object_name, valid_actions, auto_populated)
        VALUES ('table', '__test_mcts_high_a', ARRAY['ALTER'], false),
               ('table', '__test_mcts_high_b', ARRAY['ALTER'], false)
        RETURNING id, object_name
    ) SELECT array_agg(id ORDER BY object_name) INTO v_high_ids FROM ins;
    
    WITH ins AS (
        INSERT INTO object_registry (object_type, object_name, valid_actions, auto_populated)
        VALUES ('table', '__test_mcts_low_a', ARRAY['ALTER'], false),
               ('table', '__test_mcts_low_b', ARRAY['ALTER'], false)
        RETURNING id, object_name
    ) SELECT array_agg(id ORDER BY object_name) INTO v_low_ids FROM ins;
    
    INSERT INTO wo_mutations (work_order_id, tool_name, object_type, object_id, action, success, agent_name)
    SELECT v_test_wo_id, 'apply_migration', 'table', '__test_mcts_high_a', 'DDL', (gs <= 450), 'ilmarinen'
    FROM generate_series(1, 500) gs;
    INSERT INTO wo_mutations (work_order_id, tool_name, object_type, object_id, action, success, agent_name)
    SELECT v_test_wo_id, 'apply_migration', 'table', '__test_mcts_high_b', 'DDL', (gs <= 450), 'ilmarinen'
    FROM generate_series(1, 500) gs;
    INSERT INTO wo_mutations (work_order_id, tool_name, object_type, object_id, action, success, agent_name)
    SELECT v_test_wo_id, 'apply_migration', 'table', '__test_mcts_low_a', 'DDL', (gs <= 100), 'ilmarinen'
    FROM generate_series(1, 500) gs;
    INSERT INTO wo_mutations (work_order_id, tool_name, object_type, object_id, action, success, agent_name)
    SELECT v_test_wo_id, 'apply_migration', 'table', '__test_mcts_low_b', 'DDL', (gs <= 100), 'ilmarinen'
    FROM generate_series(1, 500) gs;
    
    REFRESH MATERIALIZED VIEW object_action_rates;
    REFRESH MATERIALIZED VIEW action_type_rates;
    
    SELECT wilson_lower INTO v_wilson_a
    FROM object_action_rates 
    WHERE target_identifier = '__test_mcts_high_a' AND tool_name = 'apply_migration' AND action = 'DDL';
    
    -- TEST 1: sqrt(N) Convergence
    SELECT mcts_plan_actions(v_high_ids, 'convergence', 100, 1, ARRAY['ALTER']) INTO v_result;
    v_ci_100 := (v_result->'plans'->0->'wilson_ci'->>'width')::numeric;
    SELECT mcts_plan_actions(v_high_ids, 'convergence', 500, 1, ARRAY['ALTER']) INTO v_result;
    v_ci_500 := (v_result->'plans'->0->'wilson_ci'->>'width')::numeric;
    SELECT mcts_plan_actions(v_high_ids, 'convergence', 2500, 1, ARRAY['ALTER']) INTO v_result;
    v_ci_2500 := (v_result->'plans'->0->'wilson_ci'->>'width')::numeric;
    
    v_ratio_1 := CASE WHEN v_ci_2500 > 0 THEN v_ci_100 / v_ci_2500 ELSE 0 END;
    v_ratio_2 := CASE WHEN v_ci_500 > 0 THEN v_ci_100 / v_ci_500 ELSE 0 END;
    v_expected_ratio_1 := sqrt(2500.0 / 100.0);
    v_expected_ratio_2 := sqrt(500.0 / 100.0);
    v_test_detail := jsonb_build_object(
        'test_name', 'sqrt_n_convergence',
        'ci_width_at_100', v_ci_100, 'ci_width_at_500', v_ci_500, 'ci_width_at_2500', v_ci_2500,
        'ratio_100_over_2500', round(v_ratio_1, 3), 'expected_ratio', round(v_expected_ratio_1, 3),
        'ratio_100_over_500', round(v_ratio_2, 3), 'expected_ratio_500', round(v_expected_ratio_2, 3),
        'pass', (v_ratio_1 BETWEEN v_expected_ratio_1 * 0.5 AND v_expected_ratio_1 * 2.0)
            AND (v_ratio_2 BETWEEN v_expected_ratio_2 * 0.5 AND v_expected_ratio_2 * 2.0),
        'tolerance', '50-200% of expected ratio'
    );
    IF (v_test_detail->>'pass')::boolean THEN v_pass_count := v_pass_count + 1; ELSE v_fail_count := v_fail_count + 1; END IF;
    v_test_results := jsonb_set(v_test_results, '{tests}', (v_test_results->'tests') || jsonb_build_array(v_test_detail));
    
    -- TEST 2: Known Probability Recovery
    v_theoretical := v_wilson_a * v_wilson_a;
    SELECT mcts_plan_actions(v_high_ids, 'prob_recovery', 5000, 1, ARRAY['ALTER']) INTO v_result;
    v_mean_rate := (v_result->'plans'->0->>'mean_success_rate')::numeric;
    v_deviation := abs(v_mean_rate - v_theoretical);
    v_test_detail := jsonb_build_object(
        'test_name', 'probability_recovery',
        'seeded_per_step_rate', 0.900, 'wilson_lower_per_step', v_wilson_a,
        'theoretical_path_success', round(v_theoretical, 4),
        'measured_mean_5000_sims', v_mean_rate, 'absolute_deviation', round(v_deviation, 4),
        'pass', v_deviation < 0.04,
        'criterion', '|mean - theoretical| < 0.04 at N=5000'
    );
    IF (v_test_detail->>'pass')::boolean THEN v_pass_count := v_pass_count + 1; ELSE v_fail_count := v_fail_count + 1; END IF;
    v_test_results := jsonb_set(v_test_results, '{tests}', (v_test_results->'tests') || jsonb_build_array(v_test_detail));
    
    -- TEST 3: Discrimination
    SELECT mcts_plan_actions(v_high_ids, 'disc HIGH', 2000, 1, ARRAY['ALTER']) INTO v_result;
    v_high_rate := (v_result->'plans'->0->>'mean_success_rate')::numeric;
    SELECT mcts_plan_actions(v_low_ids, 'disc LOW', 2000, 1, ARRAY['ALTER']) INTO v_result;
    v_low_rate := (v_result->'plans'->0->>'mean_success_rate')::numeric;
    
    v_se_disc := sqrt(GREATEST(v_high_rate*(1-v_high_rate), 0.0001)/2000 + GREATEST(v_low_rate*(1-v_low_rate), 0.0001)/2000);
    v_z_disc := CASE WHEN v_se_disc > 0 THEN (v_high_rate - v_low_rate) / v_se_disc ELSE 999 END;
    v_p_disc := GREATEST(2*(1 - (1/(1 + exp(-1.7155*abs(v_z_disc)*(1+0.0348*v_z_disc*v_z_disc))))), 0.0001);
    v_test_detail := jsonb_build_object(
        'test_name', 'discrimination',
        'high_path_rate', v_high_rate, 'low_path_rate', v_low_rate,
        'rate_difference', round(v_high_rate - v_low_rate, 4),
        'z_score', round(v_z_disc, 4), 'p_value', v_p_disc,
        'significant_at_005', v_p_disc < 0.05, 'significant_at_001', v_p_disc < 0.01,
        'pass', v_p_disc < 0.05 AND v_high_rate > v_low_rate,
        'criterion', 'HIGH > LOW at p < 0.05'
    );
    IF (v_test_detail->>'pass')::boolean THEN v_pass_count := v_pass_count + 1; ELSE v_fail_count := v_fail_count + 1; END IF;
    v_test_results := jsonb_set(v_test_results, '{tests}', (v_test_results->'tests') || jsonb_build_array(v_test_detail));
    
    -- TEST 4: Stability
    v_run_results := ARRAY[]::numeric[];
    FOR v_i IN 1..10 LOOP
        SELECT mcts_plan_actions(v_high_ids, 'stability', 1000, 1, ARRAY['ALTER']) INTO v_result;
        v_run_results := array_append(v_run_results, (v_result->'plans'->0->>'mean_success_rate')::numeric);
    END LOOP;
    SELECT avg(val), COALESCE(stddev(val), 0) INTO v_stability_mean, v_stability_std FROM unnest(v_run_results) val;
    v_cv := CASE WHEN v_stability_mean > 0 THEN v_stability_std / v_stability_mean ELSE 999 END;
    v_test_detail := jsonb_build_object(
        'test_name', 'stability', 'num_runs', 10, 'simulations_per_run', 1000,
        'run_results', to_jsonb(v_run_results),
        'mean', round(v_stability_mean, 4), 'std_dev', round(v_stability_std, 4),
        'coefficient_of_variation', round(v_cv, 4),
        'pass', v_cv < 0.15, 'criterion', 'CV < 0.15'
    );
    IF (v_test_detail->>'pass')::boolean THEN v_pass_count := v_pass_count + 1; ELSE v_fail_count := v_fail_count + 1; END IF;
    v_test_results := jsonb_set(v_test_results, '{tests}', (v_test_results->'tests') || jsonb_build_array(v_test_detail));
    
    -- CLEANUP (enable test bypass for mutation tampering guard)
    PERFORM set_config('app.test_cleanup_active', 'true', true);
    DELETE FROM wo_mutations WHERE work_order_id = v_test_wo_id;
    PERFORM set_config('app.test_cleanup_active', 'false', true);
    
    DELETE FROM object_links WHERE source_id = ANY(v_high_ids || v_low_ids) OR target_id = ANY(v_high_ids || v_low_ids);
    DELETE FROM object_registry WHERE object_name LIKE '__test_mcts_%';
    DELETE FROM work_orders WHERE id = v_test_wo_id;
    REFRESH MATERIALIZED VIEW object_action_rates;
    REFRESH MATERIALIZED VIEW action_type_rates;
    
    v_test_results := v_test_results || jsonb_build_object(
        'summary', jsonb_build_object('total_tests', v_pass_count + v_fail_count,
            'passed', v_pass_count, 'failed', v_fail_count,
            'verdict', CASE WHEN v_fail_count = 0 THEN 'ALL_PASS' ELSE 'FAIL' END)
    );
    RETURN v_test_results;
END;
$$;


--
-- Name: test_mutation_pipeline(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.test_mutation_pipeline() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_test_wo_id uuid;
  v_remediation_id uuid;
  v_remediation_obj text;
  v_results jsonb := '{}';
  v_test_slug text := 'WO-TEST-MUT-' || floor(random() * 10000)::text;
BEGIN
  PERFORM set_config('app.state_write_bypass', 'true', true);
  
  INSERT INTO work_orders (id, slug, name, objective, acceptance_criteria, priority, status, created_by, source, tags, requires_approval)
  VALUES (
    gen_random_uuid(), v_test_slug, 'E2E Mutation Pipeline Test', 
    'Test WO for mutation pipeline verification',
    '1. Verify mutation pipeline works end to end',
    'p3_low'::work_order_priority, 
    'review'::work_order_status, 'engineering', 'test_suite',
    ARRAY['test', 'e2e-test'], false
  ) RETURNING id INTO v_test_wo_id;

  INSERT INTO wo_mutations (work_order_id, tool_name, object_type, object_id, action, success, agent_name)
  VALUES 
    (v_test_wo_id, 'execute_sql', 'sql_query', 'CREATE TABLE test_table (id uuid)', 'CREATE', true, 'test'),
    (v_test_wo_id, 'github_edit_file', 'github_file', 'src/index.ts', 'EDIT', true, 'test'),
    (v_test_wo_id, 'execute_sql', 'sql_query', 'ALTER TABLE bad_syntax...', 'ALTER', false, 'test');
  
  UPDATE wo_mutations SET error_class = 'sql_syntax', error_detail = 'ERROR: syntax error near ALTER'
  WHERE work_order_id = v_test_wo_id AND success = false;

  v_results := v_results || jsonb_build_object('step1_mutations_recorded', 
    (SELECT count(*) FROM wo_mutations WHERE work_order_id = v_test_wo_id));

  UPDATE work_orders SET qa_checklist = '[
    {"criterion": "Test criterion 1", "status": "fail", "reason": "Not implemented"},
    {"criterion": "Test criterion 2", "status": "pass", "reason": "OK"}
  ]'::jsonb
  WHERE id = v_test_wo_id;

  SELECT id, objective INTO v_remediation_id, v_remediation_obj
  FROM work_orders
  WHERE parent_id = v_test_wo_id AND 'remediation' = ANY(tags)
  LIMIT 1;

  v_results := v_results || jsonb_build_object(
    'step2_remediation_created', v_remediation_id IS NOT NULL,
    'step3_has_mutation_context', COALESCE(v_remediation_obj LIKE '%Mutation History%', false),
    'step4_has_completed_mutations', COALESCE(v_remediation_obj LIKE '%Completed Mutations%', false),
    'step5_has_failed_mutations', COALESCE(v_remediation_obj LIKE '%Failed Mutations%', false),
    'step6_has_do_not_retry', COALESCE(v_remediation_obj LIKE '%DO NOT RETRY%', false)
  );

  DELETE FROM wo_mutations WHERE work_order_id = v_test_wo_id;
  IF v_remediation_id IS NOT NULL THEN
    DELETE FROM work_order_execution_log WHERE work_order_id IN (v_test_wo_id, v_remediation_id);
    DELETE FROM work_orders WHERE id = v_remediation_id;
  END IF;
  DELETE FROM work_order_execution_log WHERE work_order_id = v_test_wo_id;
  DELETE FROM work_orders WHERE id = v_test_wo_id;

  PERFORM set_config('app.state_write_bypass', 'false', true);

  v_results := v_results || jsonb_build_object('all_passed',
    (v_results->>'step1_mutations_recorded')::int = 3
    AND (v_results->>'step2_remediation_created')::boolean = true
    AND (v_results->>'step3_has_mutation_context')::boolean = true
    AND (v_results->>'step4_has_completed_mutations')::boolean = true
    AND (v_results->>'step5_has_failed_mutations')::boolean = true
    AND (v_results->>'step6_has_do_not_retry')::boolean = true
  );

  RETURN v_results;
END;
$$;


--
-- Name: test_simple_func(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.test_simple_func() RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN 'test';
END;
$$;


--
-- Name: test_wo_0568_simple(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.test_wo_0568_simple() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Just a test
END;
$$;


--
-- Name: test_zombie_func(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.test_zombie_func(p_timeout_minutes integer) RETURNS TABLE(work_order_id uuid, slug text, name text, status text, last_mutation_at timestamp with time zone, minutes_stale integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY SELECT * FROM detect_zombie_work_orders(p_timeout_minutes);
END;
$$;


--
-- Name: test_zombie_return(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.test_zombie_return() RETURNS TABLE(x integer, y text)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY SELECT 1, 'test';
END;
$$;


--
-- Name: track_object_registry_changes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.track_object_registry_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Log changes for debugging
    RETURN NEW;
END;
$$;


--
-- Name: trg_auto_close_review_on_qa_pass(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_auto_close_review_on_qa_pass() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_item jsonb;
  v_all_pass boolean := true;
  v_has_items boolean := false;
  v_blocking_findings_count int := 0;
  v_transition_result jsonb;
BEGIN
  IF NEW.status != 'review' THEN
    RETURN NEW;
  END IF;
  
  -- Only trigger on checklist or qa_review_verified_at changes
  IF OLD.qa_checklist IS NOT DISTINCT FROM NEW.qa_checklist
     AND OLD.qa_review_verified_at IS NOT DISTINCT FROM NEW.qa_review_verified_at THEN
    RETURN NEW;
  END IF;
  
  IF NEW.qa_checklist IS NULL OR jsonb_array_length(NEW.qa_checklist) = 0 THEN
    RETURN NEW;
  END IF;
  
  -- WO-0560: Defer auto-close until qa-review (lie detector) has completed
  IF NEW.qa_review_verified_at IS NULL THEN
    INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
    VALUES (NEW.id, 'qa_validation', 'qa-gate',
      jsonb_build_object(
        'event_type', 'auto_close_deferred',
        'content', format('Auto-close deferred for %s: awaiting qa-review verification', NEW.slug)
      )
    );
    RETURN NEW;
  END IF;
  
  -- Check all checklist items are pass or na
  FOR v_item IN SELECT * FROM jsonb_array_elements(NEW.qa_checklist)
  LOOP
    v_has_items := true;
    IF v_item->>'status' NOT IN ('pass', 'na') THEN
      v_all_pass := false;
      EXIT;
    END IF;
  END LOOP;
  
  -- If not all pass, exit
  IF NOT (v_has_items AND v_all_pass) THEN
    RETURN NEW;
  END IF;
  
  -- Only block on FAIL findings, not warnings
  SELECT count(*) INTO v_blocking_findings_count
  FROM qa_findings
  WHERE work_order_id = NEW.id
    AND finding_type = 'fail'
    AND resolved_at IS NULL;
  
  IF v_blocking_findings_count > 0 THEN
    INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
    VALUES (NEW.id, 'qa_validation', 'qa-gate',
      jsonb_build_object(
        'event_type', 'auto_close_blocked',
        'content', format('Auto-close blocked for %s: %s unresolved fail finding(s)', NEW.slug, v_blocking_findings_count),
        'blocking_findings_count', v_blocking_findings_count
      )
    );
    RETURN NEW;
  END IF;
  
  -- All conditions met: insert audit_log approval record first (satisfies approval gate)
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload, work_order_id)
  VALUES (
    'approval',
    'system',
    NULL,
    'work_order',
    NEW.id,
    'approve',
    jsonb_build_object('source', 'auto_qa_pass', 'checklist_verdict', 'pass'),
    NEW.id
  );
  
  -- Now use update_work_order_state RPC (handles bypass internally)
  SELECT update_work_order_state(
    p_work_order_id := NEW.id,
    p_status := 'done',
    p_completed_at := NOW(),
    p_approved_at := NOW(),
    p_approved_by := 'qa-gate',
    p_summary := COALESCE(NULLIF(NEW.summary, ''), 'Auto-closed: all QA checklist items passed')
  ) INTO v_transition_result;
  
  -- Log the auto-close
  INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
  VALUES (
    NEW.id,
    'execution_complete',
    'qa-gate',
    jsonb_build_object(
      'event_type', 'auto_close_qa_pass',
      'content', format('Auto-closed %s: all %s checklist items passed, no fail findings', NEW.slug, jsonb_array_length(NEW.qa_checklist)),
      'checklist_items', jsonb_array_length(NEW.qa_checklist),
      'rpc_result', v_transition_result
    )
  );
  
  RETURN NEW;
END;
$$;


--
-- Name: trg_auto_generate_backend_docs(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_auto_generate_backend_docs() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Only trigger for DDL changes (CREATE, ALTER, DROP)
  IF NEW.change_type IN ('CREATE', 'ALTER', 'DROP') THEN
    -- Call the auto-generation function asynchronously (won't block the migration)
    PERFORM auto_generate_backend_docs();
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION trg_auto_generate_backend_docs(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.trg_auto_generate_backend_docs() IS 'Auto-generates backend structure documentation when schema changes occur';


--
-- Name: trg_auto_regenerate_backend_docs(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_auto_regenerate_backend_docs() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_doc_id uuid;
BEGIN
  -- Only regenerate if this is a meaningful schema change
  IF NEW.change_type IN ('CREATE', 'ALTER', 'DROP') 
     AND NEW.object_type IN ('table', 'function', 'trigger', 'policy', 'enum') THEN
    
    -- Call the auto-generation function
    BEGIN
      SELECT auto_generate_backend_docs() INTO v_doc_id;
      
      -- Log the regeneration
      INSERT INTO work_order_execution_log (
        work_order_id,
        phase,
        agent_name,
        detail
      )
      SELECT 
        NEW.work_order_id,
        'stream',
        'system',
        jsonb_build_object(
          'event', 'auto_doc_regeneration',
          'trigger', 'schema_change',
          'change_type', NEW.change_type,
          'object_name', NEW.object_name,
          'doc_id', v_doc_id
        )
      WHERE NEW.work_order_id IS NOT NULL;
      
    EXCEPTION WHEN OTHERS THEN
      -- Log error but don't fail the schema change
      RAISE WARNING 'Failed to auto-regenerate backend docs: %', SQLERRM;
    END;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: trg_create_regression_alert(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_create_regression_alert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- If alert_triggered is true and it's a fail status, create alert
  IF NEW.alert_triggered = true AND NEW.status = 'fail' THEN
    INSERT INTO regression_alerts (
      suite_run_id, alert_type, severity, message, details
    ) VALUES (
      NEW.id,
      'score_drop',
      CASE 
        WHEN NEW.score_delta_pct < -20 THEN 'critical'
        WHEN NEW.score_delta_pct < -15 THEN 'high'
        ELSE 'medium'
      END,
      format('Regression detected: Score dropped %.2f%% (from %.2f to %.2f)', 
             NEW.score_delta_pct, NEW.baseline_score, NEW.test_score),
      jsonb_build_object(
        'baseline_score', NEW.baseline_score,
        'test_score', NEW.test_score,
        'delta_pct', NEW.score_delta_pct,
        'suite_definition_id', NEW.suite_definition_id
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: trg_generate_scorecard_on_done(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_generate_scorecard_on_done() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Only generate scorecard when transitioning TO 'done' status
  IF NEW.status = 'done' AND (OLD.status IS NULL OR OLD.status != 'done') THEN
    -- Use pg_background or simply call the function directly
    -- Since this runs in trigger context, we'll use a simple approach
    PERFORM generate_wo_scorecard(NEW.id);
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: trg_sync_lesson_to_kb(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_sync_lesson_to_kb() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Only fire when promoted_at changes from NULL to a value
  IF NEW.promoted_at IS NOT NULL AND (OLD.promoted_at IS NULL OR TG_OP = 'INSERT') THEN
    -- Skip auto-error lessons
    IF NEW.rule NOT LIKE 'Work order execution failed%'
       AND NEW.rule NOT LIKE 'Decision gate blocked%'
       AND NEW.rule NOT LIKE 'Investigate and resolve%' THEN
      
      INSERT INTO agent_knowledge_base (
        id, category, topic, content, applicable_roles, applicable_tags, severity, active
      ) VALUES (
        gen_random_uuid(),
        CASE NEW.category
          WHEN 'state_machine' THEN 'enforcement'
          WHEN 'hallucination' THEN 'best_practice'
          WHEN 'scope_creep' THEN 'process'
          ELSE COALESCE(NEW.category::text, 'best_practice')
        END,
        'lesson_' || NEW.id::text,
        '[' || COALESCE(NEW.severity, 'medium') || '] ' || NEW.pattern || ': ' || NEW.rule,
        CASE NEW.category
          WHEN 'execution' THEN ARRAY['executor', 'builder']
          WHEN 'state_machine' THEN ARRAY['executor', 'builder', 'ops']
          WHEN 'approval_flow' THEN ARRAY['executor', 'builder', 'ops']
          ELSE ARRAY['executor', 'builder']
        END,
        ARRAY[]::text[],
        COALESCE(NEW.severity, 'medium'),
        true
      )
      ON CONFLICT DO NOTHING;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: trg_update_regression_suite_definitions_timestamp(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_update_regression_suite_definitions_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: trg_validate_acceptance_criteria(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trg_validate_acceptance_criteria() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_ac_validation record;
BEGIN
  -- Skip validation for cancelled/failed status changes
  IF TG_OP = 'UPDATE' AND NEW.status IN ('cancelled', 'failed') THEN
    RETURN NEW;
  END IF;
  
  -- Only validate on INSERT (new WO creation)
  IF TG_OP = 'INSERT' THEN
    -- Gate 1: Reject NULL or empty acceptance_criteria
    IF NEW.acceptance_criteria IS NULL OR trim(NEW.acceptance_criteria) = '' THEN
      RAISE EXCEPTION 'acceptance_criteria required: must contain at least 1 numbered or bulleted criterion';
    END IF;

    -- Gate 2: Validate using validate_acceptance_criteria()
    SELECT * INTO v_ac_validation FROM validate_acceptance_criteria(NEW.acceptance_criteria);

    IF v_ac_validation.line_count < 1 THEN
      RAISE EXCEPTION 'acceptance_criteria required: must contain at least 1 numbered or bulleted criterion';
    END IF;

    -- Gate 3: Reject all-filler ACs
    IF NOT v_ac_validation.is_valid THEN
      RAISE EXCEPTION 'acceptance_criteria must contain specific, testable criteria — generic filler rejected';
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: trigger_advance_pipeline_on_phase_done(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_advance_pipeline_on_phase_done() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- NO wo_transition_active check — fires through wo_transition
  IF NEW.pipeline_phase IS NOT NULL
    AND NEW.pipeline_run_id IS NOT NULL
    AND NEW.status = 'done'
    AND OLD.status IS DISTINCT FROM 'done'
  THEN
    PERFORM advance_pipeline_phase(NEW.pipeline_run_id);
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trigger_audit_enforcer(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_audit_enforcer(p_work_order_slug text, p_trigger_event text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_wo_id uuid;
BEGIN
  -- Look up the WO id from slug
  SELECT id INTO v_wo_id FROM work_orders WHERE slug = p_work_order_slug;

  INSERT INTO audit_log (
    target_type,
    target_id,
    action,
    actor_type,
    actor_id,
    event_type,
    payload,
    work_order_id
  ) VALUES (
    'work_order',
    COALESCE(v_wo_id, gen_random_uuid()),
    'Enforcer trigger: ' || p_trigger_event,
    'system',
    'trigger_audit_enforcer',
    'enforcer_triggered',
    jsonb_build_object(
      'work_order_slug', p_work_order_slug,
      'trigger_event', p_trigger_event,
      'timestamp', NOW()
    ),
    v_wo_id
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'message', 'Enforcer trigger logged',
    'work_order_slug', p_work_order_slug,
    'trigger_event', p_trigger_event
  );
END;
$$;


--
-- Name: trigger_auto_qa_evaluation(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_auto_qa_evaluation() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'net'
    AS $$
DECLARE
  v_auth_key TEXT;
  v_lifecycle_verdict JSONB;
BEGIN
  -- NO wo_transition_active check — fires through wo_transition
  
  IF NEW.status = 'review' AND (OLD.status IS DISTINCT FROM 'review') THEN
    UPDATE qa_findings SET resolved_at = now() WHERE work_order_id = NEW.id AND resolved_at IS NULL;

    v_lifecycle_verdict := evaluate_wo_lifecycle(NEW.id, 'qa_verdict');
    INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
    VALUES (NEW.id, 'stream', 'system', 
      jsonb_build_object('event_type', 'lifecycle_gate_check', 'action', 'qa_verdict', 'verdict', v_lifecycle_verdict));

    IF v_lifecycle_verdict->>'verdict' IN ('skip', 'cancel') THEN
      INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
      VALUES (NEW.id, 'stream', 'system',
        jsonb_build_object('event_type', 'auto_qa_skipped', 'reason', v_lifecycle_verdict->>'reason'));
      RETURN NEW;
    END IF;

    SELECT (setting_value#>>'{}')::text INTO v_auth_key FROM system_settings WHERE setting_key = 'supabase_anon_key';
    IF v_auth_key IS NOT NULL THEN
      PERFORM net.http_post(
        url := 'https://phfblljwuvzqzlbzkzpr.supabase.co/functions/v1/qa-review',
        headers := jsonb_build_object('Content-Type', 'application/json', 'Authorization', 'Bearer ' || v_auth_key, 'apikey', v_auth_key),
        body := jsonb_build_object('work_order_id', NEW.id::text)
      );
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trigger_autoroute_new_wo(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_autoroute_new_wo() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Skip re-drafts: if this is an UPDATE changing TO draft FROM a non-draft status
  IF TG_OP = 'UPDATE' AND NEW.status = 'draft' AND (OLD.status IS NULL OR OLD.status != 'draft') THEN
    RETURN NEW;
  END IF;
  
  -- Route draft WOs from trusted sources (works for both INSERT and UPDATE)
  -- WO-0255: Added auto-qa to trusted sources for remediation WO routing
  IF NEW.status = 'draft' AND NEW.source IN ('portal', 'cli', 'api', 'intake_api', 'lesson_promoter', 'daemon', 'auto-qa', 'auto_approval') THEN
    PERFORM autoroute_work_order(NEW.id);
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION trigger_autoroute_new_wo(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.trigger_autoroute_new_wo() IS 'WO-0049: Fixed INSERT guard so trigger fires on INSERT of draft WOs from portal source. 
The re-draft skip guard now correctly applies only to UPDATEs changing TO draft FROM non-draft.';


--
-- Name: trigger_enforcer_on_execution_issue(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_enforcer_on_execution_issue() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_supabase_url TEXT;
  v_service_key TEXT;
  v_is_failure BOOLEAN := FALSE;
BEGIN
  -- Get config
  SELECT value INTO v_supabase_url FROM enforcer_config WHERE key = 'supabase_url';
  SELECT value INTO v_service_key FROM enforcer_config WHERE key = 'service_role_key';
  
  -- Check if this is a QA failure (look in detail jsonb)
  IF NEW.phase = 'qa' AND NEW.detail ? 'status' THEN
    IF NEW.detail->>'status' = 'failed' THEN
      v_is_failure := TRUE;
    END IF;
  END IF;
  
  IF v_is_failure AND v_supabase_url IS NOT NULL AND v_service_key IS NOT NULL THEN
    PERFORM net.http_post(
      url := v_supabase_url || '/functions/v1/audit-enforcer',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || v_service_key,
      'apikey', v_service_key
      ),
      body := jsonb_build_object(
        'trigger_type', 'event_qa_failure',
        'trigger_context', jsonb_build_object(
          'work_order_id', NEW.work_order_id,
          'execution_id', NEW.id,
          'agent_name', NEW.agent_name,
          'phase', NEW.phase
        ),
        'work_order_id', NEW.work_order_id
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: trigger_enforcer_on_wo_event(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_enforcer_on_wo_event() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  IF (TG_OP = 'UPDATE') THEN
    -- Trigger on transitions to review status (for verification)
    IF NEW.status = 'review' AND OLD.status != 'review' THEN
      PERFORM invoke_audit_enforcer('wo_review_transition', NEW.id, 'event_driven');
    END IF;

    -- Trigger on blocked status
    IF NEW.status = 'blocked' AND OLD.status != 'blocked' THEN
      PERFORM invoke_audit_enforcer('wo_blocked', NEW.id, 'event_driven');
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION trigger_enforcer_on_wo_event(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.trigger_enforcer_on_wo_event() IS 'Triggers audit enforcer on work order state transitions';


--
-- Name: trigger_evaluate_auto_approval(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_evaluate_auto_approval() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_result JSONB;
BEGIN
  -- Only evaluate draft WOs that require approval
  IF NEW.status = 'draft' AND COALESCE(NEW.requires_approval, true) THEN
    v_result := evaluate_auto_approval(NEW.id);
    -- Result is logged in auto_approval_log by the RPC
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trigger_project_interrogation(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_project_interrogation() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  PERFORM start_interrogation('new_project', NEW.id);
  RETURN NEW;
END;
$$;


--
-- Name: trigger_reprioritize_queue(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_reprioritize_queue() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_auth_key TEXT;
BEGIN
  -- Get anon key from system_settings
  SELECT (setting_value#>>'{}')::text INTO v_auth_key
  FROM system_settings
  WHERE setting_key = 'supabase_anon_key';

  IF v_auth_key IS NOT NULL THEN
    PERFORM net.http_post(
      url := 'https://phfblljwuvzqzlbzkzpr.supabase.co/functions/v1/work-order-executor/reprioritize',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || v_auth_key,
      'apikey', v_auth_key
      ),
      body := jsonb_build_object('trigger', 'insert')
    );
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: trigger_snapshot_on_wo_done(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_snapshot_on_wo_done() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- NO wo_transition_active check — fires through wo_transition
  IF NEW.status = 'done' AND OLD.status != 'done' THEN
    INSERT INTO state_mutations (mutation_type, target_table, target_id, payload, previous_state, work_order_id)
    VALUES ('SNAPSHOT', 'work_orders', NEW.id,
      jsonb_build_object('slug', NEW.slug, 'name', NEW.name, 'status', NEW.status, 'summary', NEW.summary, 'completed_at', NEW.completed_at),
      jsonb_build_object('status', OLD.status::text), NEW.id);
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION trigger_snapshot_on_wo_done(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.trigger_snapshot_on_wo_done() IS 'Triggers platform health snapshot collection when a work order is marked done';


--
-- Name: update_cancellation_reason(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_cancellation_reason(p_work_order_id uuid, p_reason text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_result JSONB;
BEGIN
  -- Simple update of cancellation_reason field
  UPDATE work_orders
  SET 
    cancellation_reason = p_reason,
    updated_at = NOW()
  WHERE id = p_work_order_id
    AND status = 'cancelled';
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'WO not found or not cancelled'
    );
  END IF;
  
  RETURN jsonb_build_object(
    'success', true,
    'work_order_id', p_work_order_id,
    'cancellation_reason', p_reason
  );
END;
$$;


--
-- Name: FUNCTION update_cancellation_reason(p_work_order_id uuid, p_reason text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.update_cancellation_reason(p_work_order_id uuid, p_reason text) IS 'Updates cancellation_reason for a cancelled WO. Used for backfilling historical data.';


--
-- Name: update_checklist_item(uuid, text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_checklist_item(p_work_order_id uuid, p_item_id text, p_status text, p_evidence jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo RECORD;
  v_checklist jsonb;
  v_item jsonb;
  v_updated_checklist jsonb := '[]'::jsonb;
  v_found BOOLEAN := false;
  v_qa_agent_id UUID;
  v_description TEXT;
BEGIN
  -- Get QA agent
  SELECT id INTO v_qa_agent_id FROM agents WHERE name = 'qa' LIMIT 1;

  -- Get work order
  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Work order not found: %', p_work_order_id;
  END IF;

  -- Validate status
  IF p_status NOT IN ('pass', 'fail', 'na', 'pending') THEN
    RAISE EXCEPTION 'Invalid status: %. Must be pass, fail, na, or pending', p_status;
  END IF;

  -- Update checklist item
  v_checklist := COALESCE(v_wo.qa_checklist, '[]'::jsonb);
  
  FOR v_item IN SELECT * FROM jsonb_array_elements(v_checklist)
  LOOP
    IF v_item->>'id' = p_item_id THEN
      v_found := true;
      v_item := jsonb_set(v_item, '{status}', to_jsonb(p_status));
      v_item := jsonb_set(v_item, '{updated_at}', to_jsonb(now()::text));
      IF p_evidence IS NOT NULL AND p_evidence != '{}'::jsonb THEN
        v_item := jsonb_set(v_item, '{evidence}', p_evidence);
      END IF;
    END IF;
    v_updated_checklist := v_updated_checklist || v_item;
  END LOOP;

  IF NOT v_found THEN
    RAISE EXCEPTION 'Checklist item not found: %', p_item_id;
  END IF;

  -- Update work order
  UPDATE work_orders 
  SET qa_checklist = v_updated_checklist, updated_at = now()
  WHERE id = p_work_order_id;

  -- Build description: use evidence summary if available, else generic
  v_description := CASE 
    WHEN p_evidence->>'summary' IS NOT NULL AND length(p_evidence->>'summary') > 0 
    THEN format('Checklist item %s: %s', p_item_id, left(p_evidence->>'summary', 450))
    ELSE format('Checklist item %s marked as %s', p_item_id, p_status)
  END;

  -- Create qa_finding with rich description
  INSERT INTO qa_findings (
    work_order_id, finding_type, category, description, evidence, agent_id, checklist_item_id
  ) VALUES (
    p_work_order_id,
    p_status,
    'acceptance_criteria',
    v_description,
    jsonb_build_object('item_id', p_item_id, 'status', p_status, 'evidence', p_evidence, 'updated_at', now()),
    v_qa_agent_id,
    p_item_id
  );

  -- Log to audit
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload)
  VALUES (
    'checklist_item_updated', 'agent', v_qa_agent_id::text,
    'work_order', p_work_order_id,
    format('Updated item %s to %s', p_item_id, p_status),
    jsonb_build_object('item_id', p_item_id, 'status', p_status, 'evidence', p_evidence)
  );

  RETURN jsonb_build_object(
    'success', true, 'work_order_id', p_work_order_id,
    'item_id', p_item_id, 'status', p_status, 'evidence', p_evidence
  );
END;
$$;


--
-- Name: update_project_context_timestamp(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_project_context_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;


--
-- Name: update_project_context_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_project_context_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


--
-- Name: update_qa_checklist_item(uuid, text, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_qa_checklist_item(wo_id uuid, item_id text, new_status text, item_notes text DEFAULT NULL::text, tested_by_agent text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  updated_checklist jsonb;
  item jsonb;
  new_item jsonb;
  result jsonb := '[]'::jsonb;
BEGIN
  -- Validate status
  IF new_status NOT IN ('pending', 'pass', 'fail', 'na') THEN
    RAISE EXCEPTION 'Invalid status: %. Must be pending, pass, fail, or na', new_status;
  END IF;
  
  -- Get current checklist
  SELECT qa_checklist INTO updated_checklist
  FROM work_orders
  WHERE id = wo_id;
  
  IF updated_checklist IS NULL THEN
    RAISE EXCEPTION 'Work order % has no QA checklist', wo_id;
  END IF;
  
  -- Build updated checklist
  FOR item IN SELECT * FROM jsonb_array_elements(updated_checklist)
  LOOP
    IF item->>'id' = item_id THEN
      -- Update this item
      new_item := jsonb_build_object(
        'id', item->>'id',
        'name', item->>'name',
        'description', item->>'description',
        'status', new_status,
        'notes', COALESCE(item_notes, item->>'notes'),
        'tested_by', COALESCE(tested_by_agent, item->>'tested_by'),
        'tested_at', CASE 
          WHEN new_status != 'pending' THEN to_char(now(), 'YYYY-MM-DD"T"HH24:MI:SS"Z"')
          ELSE item->>'tested_at'
        END
      );
      result := result || new_item;
    ELSE
      -- Keep item as is
      result := result || item;
    END IF;
  END LOOP;
  
  -- Update work order
  UPDATE work_orders
  SET qa_checklist = result,
      updated_at = now()
  WHERE id = wo_id;
  
  RETURN result;
END;
$$;


--
-- Name: FUNCTION update_qa_checklist_item(wo_id uuid, item_id text, new_status text, item_notes text, tested_by_agent text); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.update_qa_checklist_item(wo_id uuid, item_id text, new_status text, item_notes text, tested_by_agent text) IS 'Updates a single QA checklist item status with notes and tested_by info';


--
-- Name: update_thread_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_thread_stats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE conversation_threads
    SET 
        message_count = message_count + 1,
        total_tokens = total_tokens + COALESCE(NEW.input_tokens, 0) + COALESCE(NEW.output_tokens, 0),
        total_cost_usd = total_cost_usd + COALESCE(NEW.cost_usd, 0),
        last_message_at = NEW.created_at,
        updated_at = now()
    WHERE id = NEW.thread_id;
    RETURN NEW;
END;
$$;


--
-- Name: update_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  new.updated_at = now();
  return new;
end;
$$;


--
-- Name: update_wo_lesson_count(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_wo_lesson_count() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.work_order_id IS NOT NULL THEN
    UPDATE work_orders 
    SET lesson_count = COALESCE(lesson_count, 0) + 1 
    WHERE id = NEW.work_order_id;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: update_work_order_state(uuid, text, timestamp with time zone, text, timestamp with time zone, timestamp with time zone, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_work_order_state(p_work_order_id uuid, p_status text DEFAULT NULL::text, p_approved_at timestamp with time zone DEFAULT NULL::timestamp with time zone, p_approved_by text DEFAULT NULL::text, p_started_at timestamp with time zone DEFAULT NULL::timestamp with time zone, p_completed_at timestamp with time zone DEFAULT NULL::timestamp with time zone, p_summary text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_result jsonb;
  v_current_status text;
  v_current_wo work_orders;
  v_qa_result jsonb;
  v_validation jsonb;
  v_final_completed_at timestamptz;
  v_verdict text;
  v_approval jsonb;
  v_caller text;
BEGIN
  SELECT * INTO v_current_wo FROM work_orders WHERE id = p_work_order_id;
  IF v_current_wo.id IS NULL THEN
    RETURN jsonb_build_object('error', 'Work order not found');
  END IF;

  v_current_status := v_current_wo.status::text;
  v_caller := COALESCE(current_setting('app.wo_executor_agent_name', true), 'unknown');

  -- Log every RPC call for audit trail (AC1)
  INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload, previous_state, new_state)
  VALUES (
    'rpc_call',
    CASE WHEN v_caller IN ('wo-agent', 'work-order-executor', 'auto-qa', 'health-check') THEN 'system' ELSE 'agent' END,
    v_caller, 'work_order', p_work_order_id,
    format('update_work_order_state(%s -> %s)', v_current_status, COALESCE(p_status, v_current_status)),
    jsonb_build_object('caller', v_caller, 'requested_status', p_status, 'wo_slug', v_current_wo.slug),
    jsonb_build_object('status', v_current_status),
    jsonb_build_object('status', COALESCE(p_status, v_current_status))
  );

  IF p_status IS NOT NULL AND p_status != v_current_status THEN
    v_current_wo.status := p_status::work_order_status;
    IF p_approved_at IS NOT NULL THEN v_current_wo.approved_at := p_approved_at; END IF;
    IF p_approved_by IS NOT NULL THEN v_current_wo.approved_by := p_approved_by; END IF;

    v_validation := validate_wo_transition(
      v_current_status::work_order_status, 
      p_status::work_order_status, 
      v_current_wo
    );

    IF NOT (v_validation->>'valid')::boolean THEN
      RETURN jsonb_build_object(
        'error', 'Transition rejected',
        'transition', v_validation->>'transition',
        'errors', v_validation->'errors'
      );
    END IF;

    -- APPROVAL CHECK (AC1-AC4)
    v_approval := check_wo_approval(p_work_order_id, v_current_status, p_status);
    IF NOT (v_approval->>'approved')::boolean THEN
      INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, payload, previous_state, new_state)
      VALUES (
        'transition_blocked_no_approval',
        CASE WHEN v_caller IN ('wo-agent', 'work-order-executor', 'auto-qa', 'health-check') THEN 'system' ELSE 'agent' END,
        v_caller, 'work_order', p_work_order_id,
        format('%s -> %s blocked: %s', v_current_status, p_status, v_approval->>'reason'),
        jsonb_build_object('wo_slug', v_current_wo.slug, 'caller', v_caller, 'approval_result', v_approval),
        jsonb_build_object('status', v_current_status),
        jsonb_build_object('status', p_status)
      );

      RETURN jsonb_build_object(
        'error', format('Approval required: %s', v_approval->>'reason'),
        'transition', format('%s -> %s', v_current_status, p_status),
        'reason', v_approval->>'reason',
        'help', COALESCE(v_approval->>'help', 'Insert approval record into audit_log with actor_type=user before retrying')
      );
    END IF;
  END IF;

  -- QA gate for review -> done
  IF v_current_status = 'review' AND p_status = 'done' THEN
    IF NOT EXISTS (
      SELECT 1 FROM consensus_votes cv
      JOIN agents a ON cv.agent_id = a.id
      WHERE cv.work_order_id = p_work_order_id
      AND a.agent_type = 'reviewer'
      AND cv.vote = 'approve'
    ) THEN
      SELECT qa_review(p_work_order_id) INTO v_qa_result;
      v_verdict := COALESCE(v_qa_result->>'verdict', 'FAIL');
      
      IF v_verdict = 'FAIL' THEN
        RETURN jsonb_build_object(
          'error', 'QA gate failed', 'verdict', v_verdict,
          'fail_count', v_qa_result->'fail_count',
          'findings', v_qa_result->'per_item_verdicts'
        );
      ELSIF v_verdict = 'PENDING' THEN
        RETURN jsonb_build_object(
          'error', 'Auto-QA not yet complete. Wait for auto-QA to finish.',
          'verdict', v_verdict,
          'pending_count', v_qa_result->'pending_count',
          'checklist_summary', v_qa_result->'checklist_summary'
        );
      END IF;

      INSERT INTO consensus_votes (work_order_id, agent_id, vote, reason)
      SELECT p_work_order_id, id, 'approve', 'Automated QA review passed'
      FROM agents WHERE name = 'qa-gate'
      ON CONFLICT (work_order_id, agent_id) DO UPDATE SET vote = 'approve', reason = 'Automated QA review passed';
    END IF;
  END IF;

  IF p_status = 'done' AND p_completed_at IS NULL THEN
    v_final_completed_at := NOW();
  ELSE
    v_final_completed_at := COALESCE(p_completed_at, v_current_wo.completed_at);
  END IF;

  PERFORM set_config('app.wo_trigger_context', 'true', true);
  PERFORM set_config('app.wo_executor_bypass', 'true', true);

  UPDATE work_orders SET
    status = CASE WHEN p_status IS NOT NULL THEN p_status::work_order_status ELSE status END,
    approved_at = COALESCE(p_approved_at, approved_at),
    approved_by = COALESCE(p_approved_by, approved_by),
    started_at = COALESCE(p_started_at, started_at),
    completed_at = v_final_completed_at,
    summary = COALESCE(p_summary, summary),
    updated_at = now()
  WHERE id = p_work_order_id
  RETURNING jsonb_build_object('id', id, 'slug', slug, 'status', status) INTO v_result;

  PERFORM set_config('app.wo_executor_bypass', 'false', true);
  PERFORM set_config('app.wo_trigger_context', '', true);

  IF p_status IS NOT NULL AND p_status != v_current_status THEN
    INSERT INTO audit_log (event_type, actor_type, actor_id, target_type, target_id, action, previous_state, new_state)
    VALUES ('wo_transition', 'system', 'update_work_order_state', 'work_order', p_work_order_id,
      format('%s -> %s', v_current_status, p_status),
      jsonb_build_object('status', v_current_status),
      jsonb_build_object('status', p_status));
  END IF;

  RETURN v_result;
END;
$$;


--
-- Name: daemon_heartbeats; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.daemon_heartbeats (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    daemon_name text NOT NULL,
    status text DEFAULT 'active'::text NOT NULL,
    last_heartbeat timestamp with time zone DEFAULT now() NOT NULL,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE daemon_heartbeats; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.daemon_heartbeats IS 'Tracks daemon status and last heartbeat timestamp for monitoring';


--
-- Name: upsert_daemon_heartbeat(text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.upsert_daemon_heartbeat(p_daemon_name text, p_status text DEFAULT 'active'::text, p_metadata jsonb DEFAULT '{}'::jsonb) RETURNS public.daemon_heartbeats
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_result daemon_heartbeats;
BEGIN
  INSERT INTO daemon_heartbeats (daemon_name, status, last_heartbeat, metadata)
  VALUES (p_daemon_name, p_status, NOW(), p_metadata)
  ON CONFLICT (daemon_name) DO UPDATE SET
    status = EXCLUDED.status,
    last_heartbeat = NOW(),
    metadata = EXCLUDED.metadata,
    updated_at = NOW()
  RETURNING * INTO v_result;
  
  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION upsert_daemon_heartbeat(p_daemon_name text, p_status text, p_metadata jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.upsert_daemon_heartbeat(p_daemon_name text, p_status text, p_metadata jsonb) IS 'Upserts daemon heartbeat with timestamp and metadata';


--
-- Name: upsert_project_document(uuid, text, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.upsert_project_document(p_project_id uuid, p_doc_type text, p_title text, p_content text, p_created_by text DEFAULT 'generate-docs'::text) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_result project_documents;
BEGIN
  INSERT INTO project_documents (project_id, doc_type, title, content, version, status, created_by)
  VALUES (p_project_id, p_doc_type, p_title, p_content, 1, 'generated', p_created_by)
  ON CONFLICT (project_id, doc_type) 
  DO UPDATE SET 
    content = EXCLUDED.content,
    version = project_documents.version + 1,
    status = 'generated',
    updated_by = p_created_by,
    updated_at = NOW()
  RETURNING * INTO v_result;

  RETURN jsonb_build_object(
    'id', v_result.id,
    'doc_type', v_result.doc_type,
    'version', v_result.version,
    'status', v_result.status,
    'chars', LENGTH(v_result.content)
  );
END;
$$;


--
-- Name: validate_acceptance_criteria(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_acceptance_criteria(p_criteria text) RETURNS TABLE(line_count integer, filler_count integer, is_valid boolean)
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  v_line_count int := 0;
  v_filler_count int := 0;
  v_filler_patterns text[] := ARRAY[
    'changes verified',
    'no regressions',
    'evidence logged',
    'objective completed'
  ];
  v_line text;
  v_is_ac_line boolean;
  v_is_filler boolean;
  v_pattern text;
BEGIN
  -- Count AC lines and filler lines
  FOR v_line IN SELECT unnest(string_to_array(p_criteria, E'\n'))
  LOOP
    v_line := trim(v_line);
    
    -- Check if this is an AC line (numbered, bulleted, or AC-prefixed)
    v_is_ac_line := (
      v_line ~ '^\d+[\.):\s]'
      OR v_line ~ '^[-*]\s'
      OR v_line ~ '^AC\d+[:\.]'
    );
    
    IF v_is_ac_line THEN
      v_line_count := v_line_count + 1;
      
      -- Check if this line matches any filler pattern (case-insensitive)
      v_is_filler := false;
      FOREACH v_pattern IN ARRAY v_filler_patterns
      LOOP
        IF lower(v_line) LIKE '%' || v_pattern || '%' THEN
          v_is_filler := true;
          EXIT;
        END IF;
      END LOOP;
      
      IF v_is_filler THEN
        v_filler_count := v_filler_count + 1;
      END IF;
    END IF;
  END LOOP;
  
  -- is_valid: at least 1 AC line, and not ALL of them are filler
  line_count := v_line_count;
  filler_count := v_filler_count;
  is_valid := (v_line_count >= 1 AND v_filler_count < v_line_count);
  
  RETURN NEXT;
END;
$$;


--
-- Name: validate_batch_execution(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_batch_execution(p_batch_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_batch RECORD;
  v_wo_count INTEGER;
  v_p0_count INTEGER;
  v_result JSONB;
BEGIN
  -- Get batch details
  SELECT * INTO v_batch
  FROM wo_batches
  WHERE id = p_batch_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'valid', false,
      'error', 'Batch not found'
    );
  END IF;

  -- Check batch-level approval if required
  IF v_batch.requires_batch_approval AND v_batch.batch_approved_at IS NULL THEN
    RETURN jsonb_build_object(
      'valid', false,
      'error', 'Batch requires approval before execution'
    );
  END IF;

  -- Get WO counts
  SELECT COUNT(*) INTO v_wo_count
  FROM work_orders
  WHERE batch_id = p_batch_id;

  SELECT COUNT(*) INTO v_p0_count
  FROM work_orders
  WHERE batch_id = p_batch_id
    AND priority = 'p0_critical';

  -- Mode-specific validation
  IF v_batch.execution_mode = 'auto' THEN
    -- Auto mode requires P2+ only (no P0 or P1)
    IF v_p0_count > 0 THEN
      RETURN jsonb_build_object(
        'valid', false,
        'error', 'Auto mode cannot process P0 work orders',
        'p0_count', v_p0_count
      );
    END IF;
    
    -- Check for P1 as well
    IF EXISTS (
      SELECT 1 FROM work_orders 
      WHERE batch_id = p_batch_id 
        AND priority = 'p1_high'
    ) THEN
      RETURN jsonb_build_object(
        'valid', false,
        'error', 'Auto mode requires P2+ priority only'
      );
    END IF;
  END IF;

  -- Batch mode requires batch-level approval (already checked above)
  
  -- All checks passed
  RETURN jsonb_build_object(
    'valid', true,
    'batch_id', p_batch_id,
    'execution_mode', v_batch.execution_mode,
    'wo_count', v_wo_count,
    'parallel_slots', v_batch.parallel_slots
  );
END;
$$;


--
-- Name: FUNCTION validate_batch_execution(p_batch_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.validate_batch_execution(p_batch_id uuid) IS 'Validates if a batch can be executed based on mode and approval requirements';


--
-- Name: validate_deployment_readiness(uuid, text[], boolean, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_deployment_readiness(p_work_order_id uuid, p_required_env_vars text[] DEFAULT NULL::text[], p_check_build boolean DEFAULT true, p_check_deployment_logs boolean DEFAULT true) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo_record RECORD;
  v_result JSONB := '{"valid": true, "checks": []}'::JSONB;
  v_checks JSONB := '[]'::JSONB;
  v_missing_env_vars TEXT[] := ARRAY[]::TEXT[];
  v_env_var TEXT;
  v_env_exists BOOLEAN;
  v_build_status TEXT;
  v_critical_errors INTEGER := 0;
  v_deployment_check JSONB;
BEGIN
  -- Fetch work order details
  SELECT * INTO v_wo_record
  FROM work_orders
  WHERE id = p_work_order_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'valid', false,
      'error', 'Work order not found',
      'checks', '[]'::JSONB
    );
  END IF;

  -- Check 1: Validate required environment variables exist in secrets table
  IF p_required_env_vars IS NOT NULL AND array_length(p_required_env_vars, 1) > 0 THEN
    FOREACH v_env_var IN ARRAY p_required_env_vars
    LOOP
      SELECT EXISTS(
        SELECT 1 FROM secrets WHERE key = v_env_var
      ) INTO v_env_exists;

      IF NOT v_env_exists THEN
        v_missing_env_vars := array_append(v_missing_env_vars, v_env_var);
      END IF;
    END LOOP;

    v_checks := v_checks || jsonb_build_object(
      'check', 'environment_variables',
      'passed', array_length(v_missing_env_vars, 1) IS NULL OR array_length(v_missing_env_vars, 1) = 0,
      'missing_vars', COALESCE(to_jsonb(v_missing_env_vars), '[]'::JSONB),
      'checked_at', NOW()
    );

    IF array_length(v_missing_env_vars, 1) > 0 THEN
      v_result := jsonb_set(v_result, '{valid}', 'false'::JSONB);
    END IF;
  END IF;

  -- Check 2: Validate build status from execution logs
  IF p_check_build THEN
    SELECT 
      CASE 
        WHEN detail->>'build_status' = 'success' THEN 'success'
        WHEN detail->>'build_status' = 'failed' THEN 'failed'
        WHEN detail ? 'error' THEN 'failed'
        ELSE 'unknown'
      END INTO v_build_status
    FROM work_order_execution_log
    WHERE work_order_id = p_work_order_id
      AND phase IN ('testing', 'deploying')
      AND (detail ? 'build_status' OR detail ? 'error')
    ORDER BY created_at DESC
    LIMIT 1;

    v_checks := v_checks || jsonb_build_object(
      'check', 'build_validation',
      'passed', COALESCE(v_build_status, 'unknown') = 'success',
      'build_status', COALESCE(v_build_status, 'unknown'),
      'checked_at', NOW()
    );

    IF COALESCE(v_build_status, 'unknown') != 'success' THEN
      v_result := jsonb_set(v_result, '{valid}', 'false'::JSONB);
    END IF;
  END IF;

  -- Check 3: Scan deployment logs for critical errors
  IF p_check_deployment_logs THEN
    SELECT COUNT(*) INTO v_critical_errors
    FROM work_order_execution_log
    WHERE work_order_id = p_work_order_id
      AND phase IN ('deploying', 'completing')
      AND (
        detail->>'status' = 'error' 
        OR detail->>'level' = 'critical'
        OR detail ? 'critical_error'
        OR (detail->>'error' IS NOT NULL AND detail->>'error' != '')
      );

    v_checks := v_checks || jsonb_build_object(
      'check', 'deployment_logs',
      'passed', v_critical_errors = 0,
      'critical_errors_found', v_critical_errors,
      'checked_at', NOW()
    );

    IF v_critical_errors > 0 THEN
      v_result := jsonb_set(v_result, '{valid}', 'false'::JSONB);
    END IF;
  END IF;

  -- Add all checks to result
  v_result := jsonb_set(v_result, '{checks}', v_checks);

  -- Log validation result to execution log
  INSERT INTO work_order_execution_log (
    work_order_id,
    phase,
    agent_name,
    detail,
    iteration
  ) VALUES (
    p_work_order_id,
    'deployment_validation',
    'system',
    jsonb_build_object(
      'validation_result', v_result,
      'validated_at', NOW()
    ),
    1
  );

  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION validate_deployment_readiness(p_work_order_id uuid, p_required_env_vars text[], p_check_build boolean, p_check_deployment_logs boolean); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.validate_deployment_readiness(p_work_order_id uuid, p_required_env_vars text[], p_check_build boolean, p_check_deployment_logs boolean) IS 'Validates deployment readiness by checking: (1) required environment variables exist in secrets table, (2) build succeeded in execution logs, (3) no critical errors in deployment logs. Returns JSONB with validation status and detailed checks. Used as gate between QA pass and final completion.';


--
-- Name: validate_interaction(text, text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_interaction(p_source_type text, p_target_type text, p_interaction_name text, p_context jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_definition record;
  v_result jsonb;
  v_precondition text;
  v_passed boolean;
  v_reasons text[] := '{}';
BEGIN
  -- Look up the interaction definition
  SELECT * INTO v_definition
  FROM interaction_definitions
  WHERE source_type = p_source_type
    AND target_type = p_target_type
    AND interaction_name = p_interaction_name;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'valid', false,
      'reasons', ARRAY['Interaction definition not found: ' || p_interaction_name],
      'interaction_name', p_interaction_name
    );
  END IF;

  -- Check each precondition
  FOR v_precondition IN SELECT jsonb_array_elements_text(v_definition.preconditions)
  LOOP
    -- Evaluate precondition based on name
    v_passed := (
      CASE v_precondition
        -- Known preconditions - in real implementation these would check actual state
        WHEN 'last_mutation_recorded' THEN 
          p_context ? 'last_mutation_id' OR p_context ? 'mutation_count'
        WHEN 'agent_profile_allows_tags' THEN 
          p_context ? 'agent_id'
        WHEN 'complexity_scored' THEN 
          p_context ? 'complexity' OR p_context ? 'execution_rank'
        WHEN 'suppression_flag_checked' THEN 
          p_context ? 'suppression_checked' OR p_context ? 'suppressed' = false
        -- Unknown preconditions default to pass (deferred evaluation)
        ELSE true
      END
    );

    IF NOT v_passed THEN
      v_reasons := array_append(v_reasons, 'Precondition failed: ' || v_precondition);
    END IF;
  END LOOP;

  -- Build result
  v_result := jsonb_build_object(
    'valid', array_length(v_reasons, 1) IS NULL OR array_length(v_reasons, 1) = 0,
    'reasons', v_reasons,
    'interaction_name', p_interaction_name,
    'source_type', p_source_type,
    'target_type', p_target_type,
    'failure_behavior', v_definition.failure_behavior
  );

  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION validate_interaction(p_source_type text, p_target_type text, p_interaction_name text, p_context jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.validate_interaction(p_source_type text, p_target_type text, p_interaction_name text, p_context jsonb) IS 'Validates whether an interaction can proceed based on its preconditions.
Returns JSONB with: valid (bool), reasons (array of failure reasons), interaction_name, failure_behavior';


--
-- Name: validate_pre_ready_gate(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_pre_ready_gate() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_child_count INT;
  v_ac_count INT;
  v_ac_lines TEXT[];
  v_ac_line TEXT;
  v_has_specificity BOOLEAN := FALSE;
  v_agent_routing_tags TEXT[];
  v_agent_tools TEXT[];
  v_misaligned_tags TEXT[];
BEGIN
  -- Skip when called from wo_transition (it handles validation via evaluate_transition)
  IF current_setting('app.wo_validation_bypass', true) = 'true' THEN
    RETURN NEW;
  END IF;

  IF (NEW.status IN ('ready', 'in_progress')) AND (OLD.status IS NULL OR OLD.status NOT IN ('ready', 'in_progress')) THEN
    
    IF NEW.status = 'ready' AND NEW.complexity IN ('large', 'unknown') THEN
      SELECT COUNT(*) INTO v_child_count FROM work_orders WHERE parent_id = NEW.id AND status != 'cancelled';
      IF v_child_count = 0 THEN
        RAISE EXCEPTION 'ERR_DECOMPOSITION_REQUIRED: Work order % with complexity=% must be decomposed', NEW.slug, NEW.complexity
          USING HINT = 'Use create_draft_work_order() with parent_id';
      END IF;
    END IF;
    
    v_ac_count := count_acceptance_criteria(NEW.acceptance_criteria);
    IF v_ac_count < 1 THEN
      INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
      VALUES (NEW.id, 'stream', 'validate_pre_ready_gate',
        jsonb_build_object('warning', 'AC_COUNT_LOW', 'message', v_ac_count || ' acceptance criteria', 'wo_slug', NEW.slug));
    END IF;
    
    IF NEW.acceptance_criteria IS NOT NULL AND trim(NEW.acceptance_criteria) != '' THEN
      v_ac_lines := string_to_array(NEW.acceptance_criteria, E'\n');
      FOREACH v_ac_line IN ARRAY v_ac_lines LOOP
        IF trim(v_ac_line) = '' THEN CONTINUE; END IF;
        IF v_ac_line ~* '\(|\.ts|\.sql|\.tsx|\.py|\.js|\.json|CREATE|UPDATE|DELETE|INSERT|DROP|DEPLOY|REMOVE|ADD|ALTER|verify|test|confirm|check|_[a-z]|[a-z]_' THEN
          v_has_specificity := TRUE; EXIT;
        END IF;
      END LOOP;
      
      IF NOT v_has_specificity AND v_ac_count > 0 THEN
        INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
        VALUES (NEW.id, 'stream', 'validate_pre_ready_gate',
          jsonb_build_object('warning', 'AC_SPECIFICITY_LOW', 'wo_slug', NEW.slug));
      END IF;
    END IF;
    
    IF NEW.assigned_to IS NOT NULL THEN
      SELECT routing_tags, tools_allowed INTO v_agent_routing_tags, v_agent_tools FROM agents WHERE id = NEW.assigned_to;
      v_misaligned_tags := ARRAY[]::TEXT[];
      IF ('supabase' = ANY(NEW.tags) OR 'migration' = ANY(NEW.tags)) AND NOT ('execute_sql' = ANY(v_agent_tools) OR 'apply_migration' = ANY(v_agent_tools)) THEN
        v_misaligned_tags := array_append(v_misaligned_tags, 'supabase/migration');
      END IF;
      IF array_length(v_misaligned_tags, 1) > 0 THEN
        INSERT INTO work_order_execution_log (work_order_id, phase, agent_name, detail)
        VALUES (NEW.id, 'stream', 'validate_pre_ready_gate',
          jsonb_build_object('warning', 'TOOL_ALIGNMENT_MISMATCH', 'wo_slug', NEW.slug, 'wo_tags', NEW.tags));
      END IF;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: FUNCTION validate_pre_ready_gate(); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.validate_pre_ready_gate() IS 'Pre-ready gate validation: checks complexity decomposition (blocking) and AC quality (warnings). 
Validates: AC count, AC specificity, tool alignment, objective length. 
Warnings logged to execution_log but do not block transitions.';


--
-- Name: validate_remediation_qa_tools(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_remediation_qa_tools(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_is_remediation boolean;
  v_has_findings boolean;
  v_resolve_calls int;
  v_update_calls int;
  v_result jsonb;
BEGIN
  -- Check if this is a remediation WO
  SELECT 'remediation' = ANY(tags) INTO v_is_remediation
  FROM work_orders 
  WHERE id = p_work_order_id;
  
  -- If not remediation, skip validation
  IF NOT v_is_remediation THEN
    RETURN jsonb_build_object(
      'valid', true,
      'reason', 'Not a remediation WO',
      'is_remediation', false
    );
  END IF;
  
  -- Check if there are unresolved QA findings for this WO or its parent
  SELECT EXISTS (
    SELECT 1 FROM qa_findings 
    WHERE work_order_id = p_work_order_id 
      AND resolved_at IS NULL
      AND finding_type = 'fail'
  ) INTO v_has_findings;
  
  -- If no findings, validation passes
  IF NOT v_has_findings THEN
    RETURN jsonb_build_object(
      'valid', true,
      'reason', 'No unresolved QA findings',
      'is_remediation', true,
      'has_findings', false
    );
  END IF;
  
  -- Count actual tool calls in execution log
  SELECT 
    COUNT(DISTINCT CASE WHEN detail->>'tool_name' = 'resolve_qa_findings' THEN 1 END),
    COUNT(DISTINCT CASE WHEN detail->>'tool_name' = 'update_qa_checklist' THEN 1 END)
  INTO v_resolve_calls, v_update_calls
  FROM work_order_execution_log
  WHERE work_order_id = p_work_order_id
    AND detail->>'tool_name' IN ('resolve_qa_findings', 'update_qa_checklist')
    AND detail->>'success' = 'true';
  
  -- Validation fails if findings exist but tools weren't called
  IF v_resolve_calls = 0 OR v_update_calls = 0 THEN
    RETURN jsonb_build_object(
      'valid', false,
      'reason', format('Remediation WO has unresolved findings but missing tool calls: resolve_qa_findings=%s, update_qa_checklist=%s', v_resolve_calls, v_update_calls),
      'is_remediation', true,
      'has_findings', true,
      'resolve_calls', v_resolve_calls,
      'update_calls', v_update_calls,
      'error_code', 'ERR_QA_TOOLS_NOT_CALLED'
    );
  END IF;
  
  -- All checks passed
  RETURN jsonb_build_object(
    'valid', true,
    'reason', 'QA tools were called',
    'is_remediation', true,
    'has_findings', true,
    'resolve_calls', v_resolve_calls,
    'update_calls', v_update_calls
  );
END;
$$;


--
-- Name: FUNCTION validate_remediation_qa_tools(p_work_order_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.validate_remediation_qa_tools(p_work_order_id uuid) IS 'Validates that remediation WOs with QA findings actually called resolve_qa_findings and update_qa_checklist tools. Returns jsonb with valid flag and details.';


--
-- Name: validate_request(text, text, jsonb, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_request(p_endpoint text, p_method text, p_body jsonb, p_headers jsonb DEFAULT '{}'::jsonb) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  v_schema RECORD;
  v_errors JSONB := '[]'::jsonb;
  v_required TEXT;
  v_prop_name TEXT;
  v_prop_schema JSONB;
  v_prop_value JSONB;
BEGIN
  -- Find schema
  SELECT * INTO v_schema FROM request_schemas 
  WHERE endpoint = p_endpoint AND method = p_method AND enabled = true;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'valid', false,
      'error', 'Unknown endpoint or method',
      'endpoint', p_endpoint,
      'method', p_method
    );
  END IF;
  
  -- Check auth if required
  IF v_schema.requires_auth AND NOT (p_headers ? 'authorization') THEN
    RETURN jsonb_build_object(
      'valid', false,
      'error', 'Authorization required',
      'endpoint', p_endpoint
    );
  END IF;
  
  -- Validate required fields
  IF v_schema.schema ? 'required' THEN
    FOR v_required IN SELECT jsonb_array_elements_text(v_schema.schema->'required')
    LOOP
      IF NOT p_body ? v_required THEN
        v_errors := v_errors || jsonb_build_object('field', v_required, 'error', 'required');
      END IF;
    END LOOP;
  END IF;
  
  -- Basic type validation for properties
  IF v_schema.schema ? 'properties' THEN
    FOR v_prop_name, v_prop_schema IN SELECT * FROM jsonb_each(v_schema.schema->'properties')
    LOOP
      IF p_body ? v_prop_name THEN
        v_prop_value := p_body->v_prop_name;
        
        -- Type check
        IF v_prop_schema->>'type' = 'string' AND jsonb_typeof(v_prop_value) != 'string' THEN
          v_errors := v_errors || jsonb_build_object('field', v_prop_name, 'error', 'must be string');
        ELSIF v_prop_schema->>'type' = 'number' AND jsonb_typeof(v_prop_value) NOT IN ('number') THEN
          v_errors := v_errors || jsonb_build_object('field', v_prop_name, 'error', 'must be number');
        ELSIF v_prop_schema->>'type' = 'object' AND jsonb_typeof(v_prop_value) != 'object' THEN
          v_errors := v_errors || jsonb_build_object('field', v_prop_name, 'error', 'must be object');
        END IF;
        
        -- Enum check
        IF v_prop_schema ? 'enum' THEN
          IF NOT v_prop_value <@ (v_prop_schema->'enum') THEN
            v_errors := v_errors || jsonb_build_object(
              'field', v_prop_name, 
              'error', format('must be one of: %s', v_prop_schema->'enum')
            );
          END IF;
        END IF;
        
        -- MaxLength check
        IF v_prop_schema ? 'maxLength' AND jsonb_typeof(v_prop_value) = 'string' THEN
          IF length(v_prop_value#>>'{}') > (v_prop_schema->>'maxLength')::int THEN
            v_errors := v_errors || jsonb_build_object('field', v_prop_name, 'error', 'exceeds maxLength');
          END IF;
        END IF;
      END IF;
    END LOOP;
  END IF;
  
  RETURN jsonb_build_object(
    'valid', jsonb_array_length(v_errors) = 0,
    'errors', v_errors,
    'rate_limit', v_schema.rate_limit_per_minute
  );
END;
$$;


--
-- Name: validate_request_signature(text, timestamp with time zone, text, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_request_signature(p_request_id text, p_timestamp timestamp with time zone, p_payload_hash text, p_signature text, p_max_age_seconds integer DEFAULT 300) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_expected TEXT;
BEGIN
  -- Check timestamp is not too old (prevent replay attacks)
  IF p_timestamp < now() - (p_max_age_seconds || ' seconds')::interval THEN
    PERFORM log_bypass_attempt('invalid_signature', 'warning', 
      jsonb_build_object('reason', 'timestamp_expired', 'request_id', p_request_id));
    RETURN FALSE;
  END IF;
  
  -- Generate expected signature
  v_expected := generate_request_signature(p_request_id, p_timestamp, p_payload_hash);
  
  -- Constant-time comparison
  IF v_expected = p_signature THEN
    RETURN TRUE;
  ELSE
    PERFORM log_bypass_attempt('invalid_signature', 'warning',
      jsonb_build_object('reason', 'signature_mismatch', 'request_id', p_request_id));
    RETURN FALSE;
  END IF;
END;
$$;


--
-- Name: validate_scaffold_contracts(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_scaffold_contracts(p_pipeline_run_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_output_contracts RECORD;
  v_input_contracts RECORD;
  v_link RECORD;
  v_errors JSONB := '[]'::JSONB;
  v_contract_count INT := 0;
  v_output_keys TEXT[];
  v_input_keys TEXT[];
  v_key TEXT;
  v_output_obj RECORD;
  v_input_obj RECORD;
  v_prop_exists BOOLEAN;
BEGIN
  -- Count total contracts for this pipeline run
  SELECT COUNT(*) INTO v_contract_count
  FROM scaffold_contracts
  WHERE pipeline_run_id = p_pipeline_run_id;

  -- If no contracts, return valid
  IF v_contract_count = 0 THEN
    RETURN jsonb_build_object(
      'valid', true,
      'errors', '[]'::JSONB,
      'contract_count', 0
    );
  END IF;

  -- Iterate through output contracts
  FOR v_output_contracts IN
    SELECT sc.id AS contract_id, sc.object_id, sc.output_schema, sc.preconditions
    FROM scaffold_contracts sc
    WHERE sc.pipeline_run_id = p_pipeline_run_id
      AND sc.contract_type = 'output'
  LOOP
    -- Find objects that link TO this output object (consumers)
    -- These are objects where source_id links to target_id = output.object_id
    FOR v_link IN
      SELECT ol.source_id, ol.target_id
      FROM object_links ol
      WHERE ol.target_id = v_output_contracts.object_id
        AND ol.link_type = 'consumes'
    LOOP
      -- Check if the consuming object has an input contract
      SELECT sc.id, sc.input_schema, sc.preconditions
        INTO v_input_contracts
        FROM scaffold_contracts sc
        WHERE sc.pipeline_run_id = p_pipeline_run_id
          AND sc.object_id = v_link.source_id
          AND sc.contract_type = 'input'
        LIMIT 1;

      IF FOUND AND v_input_contracts.input_schema IS NOT NULL AND v_output_contracts.output_schema IS NOT NULL THEN
        -- Get object names for error messages
        SELECT o.object_name INTO v_output_obj
        FROM object_registry o WHERE o.id = v_output_contracts.object_id;

        SELECT o.object_name INTO v_input_obj
        FROM object_registry o WHERE o.id = v_link.source_id;

        -- Compare output_schema keys against input_schema keys
        v_output_keys := ARRAY(SELECT jsonb_object_keys(v_output_contracts.output_schema));
        v_input_keys := ARRAY(SELECT jsonb_object_keys(v_input_contracts.input_schema));

        FOREACH v_key IN ARRAY v_output_keys LOOP
          -- Check if key exists in input schema
          IF v_key != ALL(v_input_keys) THEN
            v_errors := v_errors || jsonb_build_array(
              jsonb_build_object(
                'source_object', COALESCE(v_output_obj.object_name, v_output_contracts.object_id::TEXT),
                'target_object', COALESCE(v_input_obj.object_name, v_link.source_id::TEXT),
                'mismatch_detail', 'Output key "' || v_key || '" not found in input schema'
              )
            );
          ELSE
            -- Check type compatibility
            IF v_output_contracts.output_schema->>v_key != v_input_contracts.input_schema->>v_key THEN
              v_errors := v_errors || jsonb_build_array(
                jsonb_build_object(
                  'source_object', COALESCE(v_output_obj.object_name, v_output_contracts.object_id::TEXT),
                  'target_object', COALESCE(v_input_obj.object_name, v_link.source_id::TEXT),
                  'mismatch_detail', 'Type mismatch for key "' || v_key || '": output has "' || 
                    COALESCE(v_output_contracts.output_schema->>v_key, 'null') || 
                    '", input expects "' || COALESCE(v_input_contracts.input_schema->>v_key, 'null') || '"'
                )
              );
            END IF;
          END IF;
        END LOOP;
      END IF;

      -- Check preconditions reference valid object properties
      IF v_output_contracts.preconditions IS NOT NULL THEN
        FOR v_key IN SELECT jsonb_object_keys(v_output_contracts.preconditions) LOOP
          -- Check if property exists in the source object's properties
          SELECT EXISTS(
            SELECT 1 FROM object_registry o
            WHERE o.id = v_output_contracts.object_id
              AND o.properties ? v_key
          ) INTO v_prop_exists;

          IF NOT v_prop_exists THEN
            SELECT o.object_name INTO v_output_obj
            FROM object_registry o WHERE o.id = v_output_contracts.object_id;

            v_errors := v_errors || jsonb_build_array(
              jsonb_build_object(
                'source_object', COALESCE(v_output_obj.object_name, v_output_contracts.object_id::TEXT),
                'target_object', NULL,
                'mismatch_detail', 'Precondition references unknown property "' || v_key || '" in object ' || 
                  COALESCE(v_output_obj.object_name, v_output_contracts.object_id::TEXT)
              )
            );
          END IF;
        END LOOP;
      END IF;
    END LOOP;
  END LOOP;

  RETURN jsonb_build_object(
    'valid', jsonb_array_length(v_errors) = 0,
    'errors', v_errors,
    'contract_count', v_contract_count
  );
END;
$$;


--
-- Name: validate_session(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_session(p_token text) RETURNS TABLE(valid boolean, user_id text, source text, session_id uuid)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    TRUE as valid,
    s.user_id,
    s.source,
    s.id as session_id
  FROM active_sessions s
  WHERE s.session_token = p_token
    AND s.expires_at > now();
    
  IF NOT FOUND THEN
    RETURN QUERY SELECT FALSE, NULL::TEXT, NULL::TEXT, NULL::UUID;
  END IF;
  
  -- Update last activity
  UPDATE active_sessions SET last_activity = now() WHERE session_token = p_token;
END;
$$;


--
-- Name: validate_spec(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_spec(p_spec jsonb) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_errors text[] := ARRAY[]::text[];
  v_states jsonb; v_transitions jsonb;
  v_elem jsonb; v_from text; v_to text;
  v_all_states text[];
BEGIN
  v_states := p_spec->'states';
  v_transitions := p_spec->'transitions';

  IF v_states IS NULL THEN v_errors := array_append(v_errors, 'Missing states'); END IF;
  IF v_transitions IS NULL THEN v_errors := array_append(v_errors, 'Missing transitions'); END IF;

  IF array_length(v_errors, 1) > 0 THEN
    RETURN jsonb_build_object('valid', false, 'errors', to_jsonb(v_errors));
  END IF;

  SELECT array_agg(key) INTO v_all_states FROM jsonb_object_keys(v_states) AS key;

  FOR v_elem IN SELECT value FROM jsonb_array_elements(v_transitions) LOOP
    v_from := v_elem->>'from_status';
    v_to := v_elem->>'to_status';
    IF v_from IS NOT NULL AND NOT v_from = ANY(v_all_states) THEN
      v_errors := array_append(v_errors, 'Unknown from_status: ' || v_from);
    END IF;
    IF v_to IS NOT NULL AND NOT v_to = ANY(v_all_states) THEN
      v_errors := array_append(v_errors, 'Unknown to_status: ' || v_to);
    END IF;
  END LOOP;

  RETURN jsonb_build_object('valid', array_length(v_errors, 1) IS NULL, 'errors', to_jsonb(COALESCE(v_errors, ARRAY[]::text[])));
END;
$$;


--
-- Name: validate_wo_freshness(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_wo_freshness(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo_created_at TIMESTAMPTZ;
  v_wo_tags TEXT[];
  v_stale BOOLEAN := FALSE;
  v_conflicts TEXT[] := ARRAY[]::TEXT[];
  v_conflicting_wos TEXT[] := ARRAY[]::TEXT[];
  v_recommendation TEXT := 'proceed';
  v_result JSONB;
  v_schema_changes_count INT;
  v_state_mutations_count INT;
  v_completed_wos_count INT;
BEGIN
  -- Get work order created_at and tags
  SELECT created_at, tags
  INTO v_wo_created_at, v_wo_tags
  FROM work_orders
  WHERE id = p_work_order_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'error', 'Work order not found',
      'stale', FALSE,
      'conflicts', ARRAY[]::TEXT[],
      'conflicting_wos', ARRAY[]::TEXT[],
      'recommendation', 'cancel'
    );
  END IF;

  -- Check for schema_changes since WO creation
  SELECT COUNT(*)
  INTO v_schema_changes_count
  FROM schema_changes
  WHERE created_at > v_wo_created_at;

  IF v_schema_changes_count > 0 THEN
    v_stale := TRUE;
    v_conflicts := array_append(v_conflicts, 
      format('Schema changes detected: %s changes since WO creation', v_schema_changes_count));
  END IF;

  -- Check for state_mutations (system_manifest) since WO creation
  SELECT COUNT(*)
  INTO v_state_mutations_count
  FROM state_mutations
  WHERE created_at > v_wo_created_at
    AND target_table = 'system_manifest';

  IF v_state_mutations_count > 0 THEN
    v_stale := TRUE;
    v_conflicts := array_append(v_conflicts,
      format('System manifest mutations detected: %s changes since WO creation', v_state_mutations_count));
  END IF;

  -- Check for completed work orders with overlapping tags
  IF v_wo_tags IS NOT NULL AND array_length(v_wo_tags, 1) > 0 THEN
    SELECT 
      COUNT(*),
      ARRAY_AGG(DISTINCT slug)
    INTO 
      v_completed_wos_count,
      v_conflicting_wos
    FROM work_orders
    WHERE status = 'done'
      AND completed_at > v_wo_created_at
      AND tags && v_wo_tags; -- Array overlap operator

    IF v_completed_wos_count > 0 THEN
      v_stale := TRUE;
      v_conflicts := array_append(v_conflicts,
        format('Completed work orders with shared tags: %s WOs completed since creation', v_completed_wos_count));
    END IF;
  END IF;

  -- Determine recommendation based on staleness
  IF v_stale THEN
    IF array_length(v_conflicts, 1) >= 3 THEN
      v_recommendation := 'cancel';
    ELSIF v_schema_changes_count > 0 OR v_state_mutations_count > 0 THEN
      v_recommendation := 'update';
    ELSE
      v_recommendation := 'update';
    END IF;
  END IF;

  -- Build result JSON
  v_result := jsonb_build_object(
    'stale', v_stale,
    'conflicts', v_conflicts,
    'conflicting_wos', COALESCE(v_conflicting_wos, ARRAY[]::TEXT[]),
    'recommendation', v_recommendation,
    'check_timestamp', NOW(),
    'wo_created_at', v_wo_created_at,
    'schema_changes_count', v_schema_changes_count,
    'state_mutations_count', v_state_mutations_count,
    'completed_wos_count', COALESCE(v_completed_wos_count, 0)
  );

  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION validate_wo_freshness(p_work_order_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.validate_wo_freshness(p_work_order_id uuid) IS 'Validates if a work order is stale by checking for schema changes, state mutations, and completed work orders with overlapping tags since the WO was created';


--
-- Name: validate_work_order_objective(uuid, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validate_work_order_objective(p_work_order_id uuid, p_objective text DEFAULT NULL::text, p_acceptance_criteria text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_objective text;
  v_acceptance_criteria text;
  v_confidence text := 'high';
  v_issues jsonb := '[]'::jsonb;
  v_warnings jsonb := '[]'::jsonb;
  v_referenced_components text[];
  v_referenced_tables text[];
  v_component_name text;
  v_table_name text;
  v_column_pattern text;
  v_schema_context text;
  v_explanation text := '';
BEGIN
  -- Get WO data if not provided
  IF p_objective IS NULL THEN
    SELECT objective, acceptance_criteria
    INTO v_objective, v_acceptance_criteria
    FROM work_orders
    WHERE id = p_work_order_id;
    
    IF NOT FOUND THEN
      RETURN jsonb_build_object(
        'valid', false,
        'confidence', 'low',
        'issues', jsonb_build_array('Work order not found'),
        'warnings', '[]'::jsonb,
        'explanation', 'WO does not exist in database'
      );
    END IF;
  ELSE
    v_objective := p_objective;
    v_acceptance_criteria := COALESCE(p_acceptance_criteria, '');
  END IF;

  -- Combine objective + ACs for full text analysis
  v_schema_context := v_objective || ' ' || v_acceptance_criteria;

  -- ============================================
  -- CHECK 1: Referenced components in system_manifest
  -- ============================================
  -- Extract component names (rough heuristic: words after "in", "from", "to", "using")
  -- Match against system_manifest.name
  v_referenced_components := regexp_matches(
    v_schema_context,
    '\b(?:in|from|to|using|update|modify|deploy|fix|validate)\s+([a-z0-9_-]+(?:[-_][a-z0-9]+)*)',
    'gi'
  );

  IF array_length(v_referenced_components, 1) > 0 THEN
    FOREACH v_component_name IN ARRAY v_referenced_components LOOP
      -- Check if component exists in system_manifest
      IF NOT EXISTS (
        SELECT 1 FROM system_manifest
        WHERE lower(name) = lower(v_component_name)
        AND status = 'active'
      ) THEN
        -- Check if it's a well-known term (not a component reference)
        IF v_component_name NOT IN ('all', 'any', 'each', 'every', 'table', 'database', 'schema', 'work', 'order', 'function', 'endpoint', 'api', 'system', 'daemon', 'agent', 'code', 'test', 'build') THEN
          v_issues := v_issues || jsonb_build_object(
            'type', 'component_missing',
            'component', v_component_name,
            'message', format('Referenced component "%s" not found in system_manifest', v_component_name)
          );
          v_confidence := 'medium';
        END IF;
      END IF;
    END LOOP;
  END IF;

  -- ============================================
  -- CHECK 2: Referenced tables/columns against schema
  -- ============================================
  -- Extract table references (common patterns: "work_orders", "audit_log", etc.)
  v_referenced_tables := regexp_matches(
    v_schema_context,
    '\b([a-z_]+(?:_[a-z]+)*)\s+(?:table|column|field|row)',
    'gi'
  );

  IF array_length(v_referenced_tables, 1) > 0 THEN
    FOREACH v_table_name IN ARRAY v_referenced_tables LOOP
      -- Check if table exists
      IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_schema = 'public'
        AND table_name = v_table_name
      ) THEN
        v_issues := v_issues || jsonb_build_object(
          'type', 'table_missing',
          'table', v_table_name,
          'message', format('Referenced table "%s" does not exist in schema', v_table_name)
        );
        v_confidence := 'low';
      END IF;
    END LOOP;
  END IF;

  -- ============================================
  -- CHECK 3: Detect contradictions
  -- ============================================
  -- Pattern: "validate|test|verify X" when X does not exist
  IF v_schema_context ~* '\b(validate|test|verify|check|inspect)\s+([a-z0-9_-]+)' THEN
    v_component_name := (regexp_matches(v_schema_context, '\b(?:validate|test|verify|check|inspect)\s+([a-z0-9_-]+)', 'i'))[1];
    
    IF v_component_name IS NOT NULL THEN
      -- Check if the thing being validated exists
      IF NOT EXISTS (
        SELECT 1 FROM system_manifest
        WHERE lower(name) LIKE '%' || lower(v_component_name) || '%'
        AND status = 'active'
      ) THEN
        v_warnings := v_warnings || jsonb_build_object(
          'type', 'potential_contradiction',
          'pattern', format('Objective mentions validating/testing "%s" but component not found', v_component_name),
          'message', 'May be attempting to validate non-existent component'
        );
        -- Don't downgrade confidence here — might be creating it
      END IF;
    END IF;
  END IF;

  -- Pattern: "fix|resolve|update X" when X doesn't exist is suspicious
  IF v_schema_context ~* '\b(fix|resolve|update|modify|enhance)\s+([a-z0-9_-]+)' THEN
    v_component_name := (regexp_matches(v_schema_context, '\b(?:fix|resolve|update|modify|enhance)\s+([a-z0-9_-]+)', 'i'))[1];
    
    IF v_component_name IS NOT NULL AND v_component_name NOT IN ('bug', 'issue', 'error', 'problem', 'all', 'any') THEN
      IF NOT EXISTS (
        SELECT 1 FROM system_manifest
        WHERE lower(name) LIKE '%' || lower(v_component_name) || '%'
        AND status = 'active'
      ) THEN
        v_issues := v_issues || jsonb_build_object(
          'type', 'contradiction',
          'pattern', format('Objective mentions fixing "%s" but component not found in system_manifest', v_component_name),
          'message', 'Cannot fix/update something that does not exist'
        );
        v_confidence := 'low';
      END IF;
    END IF;
  END IF;

  -- ============================================
  -- CHECK 4: Column references
  -- ============================================
  -- Look for "column X" or "field X" patterns and validate against schema
  IF v_schema_context ~* '\b(column|field)\s+"?([a-z_]+)"?' THEN
    v_column_pattern := (regexp_matches(v_schema_context, '\b(?:column|field)\s+"?([a-z_]+)"?', 'i'))[1];
    
    IF v_column_pattern IS NOT NULL THEN
      -- This is a rough check — would need table context to be precise
      v_warnings := v_warnings || jsonb_build_object(
        'type', 'column_reference',
        'column', v_column_pattern,
        'message', 'Column reference detected. Executor should verify against actual table schema.'
      );
    END IF;
  END IF;

  -- ============================================
  -- BUILD EXPLANATION
  -- ============================================
  IF v_confidence = 'high' THEN
    v_explanation := 'Objective appears valid. All referenced components and tables exist, no contradictions detected.';
  ELSIF v_confidence = 'medium' THEN
    v_explanation := 'Objective has minor issues. Some referenced components not found, but may be valid if creating new components.';
  ELSE
    v_explanation := 'Objective has significant issues. Referenced non-existent components for modification/validation, or missing critical tables.';
  END IF;

  RETURN jsonb_build_object(
    'valid', (v_confidence != 'low'),
    'confidence', v_confidence,
    'issues', v_issues,
    'warnings', v_warnings,
    'explanation', v_explanation,
    'checks_performed', jsonb_build_array(
      'component_existence',
      'table_existence',
      'contradiction_detection',
      'column_references'
    )
  );
END;
$$;


--
-- Name: verify_event_chain(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.verify_event_chain(p_stream_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_event record;
  v_expected_hash text;
  v_hash_input text;
  v_chain_length int := 0;
  v_breaks jsonb := '[]'::jsonb;
  v_prev_hash text := NULL;
BEGIN
  FOR v_event IN 
    SELECT * FROM wo_event_stream 
    WHERE stream_id = p_stream_id 
    ORDER BY version ASC
  LOOP
    v_chain_length := v_chain_length + 1;

    -- Verify previous_hash links correctly
    IF v_event.version = 1 THEN
      IF v_event.previous_hash IS NOT NULL THEN
        v_breaks := v_breaks || jsonb_build_object(
          'version', v_event.version, 'issue', 'genesis event has non-null previous_hash');
      END IF;
    ELSE
      IF v_event.previous_hash IS DISTINCT FROM v_prev_hash THEN
        v_breaks := v_breaks || jsonb_build_object(
          'version', v_event.version, 'issue', 'previous_hash mismatch',
          'expected', v_prev_hash, 'actual', v_event.previous_hash);
      END IF;
    END IF;

    -- Recompute hash and verify
    v_hash_input := COALESCE(v_event.previous_hash, 'genesis') || '|' || 
      v_event.event_type || '|' || p_stream_id::text || '|' || 
      v_event.version::text || '|' || v_event.payload::text;
    v_expected_hash := encode(extensions.digest(v_hash_input, 'sha256'), 'hex');

    IF v_event.hash != v_expected_hash THEN
      v_breaks := v_breaks || jsonb_build_object(
        'version', v_event.version, 'issue', 'hash mismatch',
        'expected', v_expected_hash, 'actual', v_event.hash);
    END IF;

    v_prev_hash := v_event.hash;
  END LOOP;

  RETURN jsonb_build_object(
    'valid', jsonb_array_length(v_breaks) = 0,
    'chain_length', v_chain_length,
    'breaks', v_breaks
  );
END;
$$;


--
-- Name: verify_evidence_chain(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.verify_evidence_chain(p_stream_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_event record;
  v_expected_hash text;
  v_hash_input text;
  v_chain_length int := 0;
  v_breaks jsonb := '[]'::jsonb;
  v_prev_hash text := NULL;
  v_events_with_evidence int := 0;
  v_events_with_complete_evidence int := 0;
  v_expected_state_hash_before text;
  v_expected_state_hash_after text;
BEGIN
  FOR v_event IN 
    SELECT * FROM wo_event_stream 
    WHERE stream_id = p_stream_id 
    ORDER BY version ASC
  LOOP
    v_chain_length := v_chain_length + 1;

    -- 1. Verify previous_hash links correctly
    IF v_event.version = 1 THEN
      IF v_event.previous_hash IS NOT NULL THEN
        v_breaks := v_breaks || jsonb_build_object(
          'version', v_event.version, 'issue', 'genesis event has non-null previous_hash');
      END IF;
    ELSE
      IF v_event.previous_hash IS DISTINCT FROM v_prev_hash THEN
        v_breaks := v_breaks || jsonb_build_object(
          'version', v_event.version, 'issue', 'previous_hash mismatch',
          'expected', v_prev_hash, 'actual', v_event.previous_hash);
      END IF;
    END IF;

    -- 2. Recompute hash and verify
    v_hash_input := COALESCE(v_event.previous_hash, 'genesis') || '|' || 
      v_event.event_type || '|' || p_stream_id::text || '|' || 
      v_event.version::text || '|' || v_event.payload::text;
    v_expected_hash := encode(extensions.digest(v_hash_input, 'sha256'), 'hex');

    IF v_event.hash != v_expected_hash THEN
      v_breaks := v_breaks || jsonb_build_object(
        'version', v_event.version, 'issue', 'hash mismatch',
        'expected', v_expected_hash, 'actual', v_event.hash);
    END IF;

    -- 3. Evidence coverage tracking
    IF v_event.evidence IS NOT NULL AND v_event.evidence != '{}'::jsonb THEN
      v_events_with_evidence := v_events_with_evidence + 1;

      -- Check for complete evidence (all 4 required fields)
      IF v_event.evidence ? 'precondition_results'
         AND v_event.evidence ? 'postcondition_results'
         AND v_event.evidence ? 'state_hash_before'
         AND v_event.evidence ? 'state_hash_after' THEN
        v_events_with_complete_evidence := v_events_with_complete_evidence + 1;

        -- 4. Verify state hashes match state snapshots
        v_expected_state_hash_before := encode(
          extensions.digest(v_event.state_before::text, 'sha256'), 'hex');
        v_expected_state_hash_after := encode(
          extensions.digest(v_event.state_after::text, 'sha256'), 'hex');

        IF v_event.evidence->>'state_hash_before' != v_expected_state_hash_before THEN
          v_breaks := v_breaks || jsonb_build_object(
            'version', v_event.version, 'issue', 'state_hash_before tampered',
            'expected', v_expected_state_hash_before,
            'actual', v_event.evidence->>'state_hash_before');
        END IF;

        IF v_event.evidence->>'state_hash_after' != v_expected_state_hash_after THEN
          v_breaks := v_breaks || jsonb_build_object(
            'version', v_event.version, 'issue', 'state_hash_after tampered',
            'expected', v_expected_state_hash_after,
            'actual', v_event.evidence->>'state_hash_after');
        END IF;
      END IF;
    END IF;

    v_prev_hash := v_event.hash;
  END LOOP;

  RETURN jsonb_build_object(
    'valid', jsonb_array_length(v_breaks) = 0,
    'chain_length', v_chain_length,
    'breaks', v_breaks,
    'evidence_coverage', CASE 
      WHEN v_chain_length = 0 THEN 0.0
      ELSE round((v_events_with_complete_evidence::numeric / v_chain_length), 4)
    END,
    'events_with_evidence', v_events_with_evidence,
    'events_with_complete_evidence', v_events_with_complete_evidence
  );
END;
$$;


--
-- Name: verify_execution_chain(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.verify_execution_chain(p_work_order_id uuid) RETURNS TABLE(is_valid boolean, total_entries bigint, checked_entries bigint, broken_at_entry_id uuid, error_message text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  entry RECORD;
  expected_prev_hash TEXT := NULL;
  prev_hash_for_calc TEXT := '';
  calculated_hash TEXT;
  hash_input TEXT;
  entry_count BIGINT := 0;
  checked_count BIGINT := 0;
BEGIN
  -- Count total entries
  SELECT COUNT(*) INTO entry_count
  FROM work_order_execution_log
  WHERE work_order_id = p_work_order_id;
  
  -- Iterate through entries in iteration order
  FOR entry IN
    SELECT id, phase, agent_name, detail, prev_hash, entry_hash, created_at, iteration
    FROM work_order_execution_log
    WHERE work_order_id = p_work_order_id
    ORDER BY iteration ASC
  LOOP
    -- Skip entries with NULL hashes (backward compatibility)
    IF entry.entry_hash IS NULL THEN
      CONTINUE;
    END IF;
    
    checked_count := checked_count + 1;
    
    -- Check prev_hash matches expected
    IF expected_prev_hash IS NULL AND entry.prev_hash IS NOT NULL THEN
      RETURN QUERY SELECT FALSE, entry_count, checked_count, entry.id, 
        'First entry should have NULL prev_hash'::TEXT;
      RETURN;
    END IF;
    
    IF expected_prev_hash IS NOT NULL AND entry.prev_hash != expected_prev_hash THEN
      RETURN QUERY SELECT FALSE, entry_count, checked_count, entry.id,
        format('prev_hash mismatch: expected %s, got %s', expected_prev_hash, entry.prev_hash);
      RETURN;
    END IF;
    
    -- Recalculate hash to verify integrity
    hash_input := 
      p_work_order_id::TEXT || '|' ||
      entry.phase || '|' ||
      COALESCE(entry.agent_name, '') || '|' ||
      COALESCE(entry.detail::TEXT, '{}') || '|' ||
      prev_hash_for_calc || '|' ||
      entry.created_at::TEXT;
    
    calculated_hash := encode(digest(hash_input, 'sha256'), 'hex');
    
    IF calculated_hash != entry.entry_hash THEN
      RETURN QUERY SELECT FALSE, entry_count, checked_count, entry.id,
        format('entry_hash mismatch: calculated %s, stored %s', calculated_hash, entry.entry_hash);
      RETURN;
    END IF;
    
    -- Update expected prev_hash for next iteration
    expected_prev_hash := entry.entry_hash;
    prev_hash_for_calc := entry.entry_hash;
  END LOOP;
  
  -- All checks passed
  RETURN QUERY SELECT TRUE, entry_count, checked_count, NULL::UUID, NULL::TEXT;
END;
$$;


--
-- Name: FUNCTION verify_execution_chain(p_work_order_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.verify_execution_chain(p_work_order_id uuid) IS 'Verifies the cryptographic hash chain integrity for a work order execution log. Returns validation result with details.';


--
-- Name: verify_mutations(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.verify_mutations(p_work_order_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_mutation RECORD;
  v_query_result INTEGER;
  v_total_checked INTEGER := 0;
  v_total_verified INTEGER := 0;
  v_total_failed INTEGER := 0;
  v_failed_details jsonb := '[]'::jsonb;
  v_result jsonb;
BEGIN
  -- Fix #3: Validate NULL input
  IF p_work_order_id IS NULL THEN
    RETURN jsonb_build_object(
      'error', 'work_order_id cannot be NULL',
      'total_checked', 0,
      'total_verified', 0,
      'total_failed', 0
    );
  END IF;

  -- Loop through all unverified mutations for this work order
  FOR v_mutation IN 
    SELECT id, tool_name, object_type, object_id, action, verification_query
    FROM wo_mutations
    WHERE work_order_id = p_work_order_id
      AND verified = false
      AND verification_query IS NOT NULL
  LOOP
    v_total_checked := v_total_checked + 1;
    
    BEGIN
      -- Execute the verification query dynamically
      -- The query should return row count if the mutation exists
      EXECUTE 'SELECT COUNT(*)::integer FROM (' || v_mutation.verification_query || ') AS verification_subquery'
      INTO v_query_result;
      
      -- If query returns rows, the mutation is verified
      IF v_query_result > 0 THEN
        UPDATE wo_mutations
        SET verified = true
        WHERE id = v_mutation.id;
        
        v_total_verified := v_total_verified + 1;
      ELSE
        UPDATE wo_mutations
        SET verified = false
        WHERE id = v_mutation.id;
        
        v_total_failed := v_total_failed + 1;
        
        -- Add to failed details
        v_failed_details := v_failed_details || jsonb_build_object(
          'mutation_id', v_mutation.id,
          'tool_name', v_mutation.tool_name,
          'object_type', v_mutation.object_type,
          'object_id', v_mutation.object_id,
          'action', v_mutation.action,
          'verification_query', v_mutation.verification_query,
          'reason', 'Query returned no rows'
        );
      END IF;
      
    EXCEPTION WHEN OTHERS THEN
      -- If verification query fails, mark as unverified and record error
      UPDATE wo_mutations
      SET verified = false
      WHERE id = v_mutation.id;
      
      v_total_failed := v_total_failed + 1;
      
      -- Add to failed details with error
      v_failed_details := v_failed_details || jsonb_build_object(
        'mutation_id', v_mutation.id,
        'tool_name', v_mutation.tool_name,
        'object_type', v_mutation.object_type,
        'object_id', v_mutation.object_id,
        'action', v_mutation.action,
        'verification_query', v_mutation.verification_query,
        'reason', 'Query execution failed: ' || SQLERRM
      );
    END;
  END LOOP;
  
  -- Build result summary
  v_result := jsonb_build_object(
    'total_checked', v_total_checked,
    'total_verified', v_total_verified,
    'total_failed', v_total_failed,
    'failed_details', v_failed_details
  );
  
  RETURN v_result;
END;
$$;


--
-- Name: FUNCTION verify_mutations(p_work_order_id uuid); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.verify_mutations(p_work_order_id uuid) IS 'Verify unverified mutations for a work order by executing stored verification queries';


--
-- Name: verify_projection_consistency(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.verify_projection_consistency(p_stream_id uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_reconstructed jsonb;
  v_actual jsonb;
  v_divergences jsonb := '[]'::jsonb;
  v_key text;
BEGIN
  v_reconstructed := reconstruct_wo_state(p_stream_id);
  
  IF v_reconstructed ? 'error' THEN
    RETURN jsonb_build_object('consistent', false, 'error', v_reconstructed->>'error');
  END IF;

  SELECT jsonb_build_object(
    'status', status, 'assigned_to', assigned_to,
    'approved_at', approved_at, 'started_at', started_at,
    'completed_at', completed_at, 'retry_count', retry_count,
    'qa_review_verified_at', qa_review_verified_at
  ) INTO v_actual FROM work_orders WHERE id = p_stream_id;

  IF v_actual IS NULL THEN
    RETURN jsonb_build_object('consistent', false, 'error', 'Work order not found');
  END IF;

  -- Compare each tracked field
  FOR v_key IN SELECT unnest(ARRAY['status', 'assigned_to', 'approved_at', 'started_at', 
    'completed_at', 'retry_count', 'qa_review_verified_at'])
  LOOP
    IF (v_reconstructed->>v_key) IS DISTINCT FROM (v_actual->>v_key) THEN
      v_divergences := v_divergences || jsonb_build_object(
        'field', v_key, 
        'event_value', v_reconstructed->>v_key, 
        'table_value', v_actual->>v_key
      );
    END IF;
  END LOOP;

  RETURN jsonb_build_object(
    'consistent', jsonb_array_length(v_divergences) = 0,
    'divergences', v_divergences
  );
END;
$$;


--
-- Name: walk_dependency_chain(uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.walk_dependency_chain(p_root_wo_id uuid, p_max_depth integer DEFAULT 10) RETURNS TABLE(wo_id uuid, wo_slug text, wo_status public.work_order_status, depth integer, blocking_deps uuid[], is_blocked boolean)
    LANGUAGE sql STABLE
    AS $$
WITH RECURSIVE dep_chain AS (
  -- Base case: start with WOs that depend on the root
  SELECT 
    wo.id,
    wo.slug,
    wo.status,
    1 as depth,
    wo.depends_on,
    ARRAY[wo.id] as path
  FROM work_orders wo
  WHERE p_root_wo_id = ANY(wo.depends_on)
  
  UNION ALL
  
  -- Recursive case: find WOs that depend on current level
  SELECT 
    wo.id,
    wo.slug,
    wo.status,
    dc.depth + 1,
    wo.depends_on,
    dc.path || wo.id
  FROM work_orders wo
  INNER JOIN dep_chain dc ON dc.id = ANY(wo.depends_on)
  WHERE dc.depth < p_max_depth
    AND NOT wo.id = ANY(dc.path)
)
SELECT 
  dc.id as wo_id,
  dc.slug as wo_slug,
  dc.status as wo_status,
  dc.depth,
  ARRAY(
    SELECT dep_id 
    FROM unnest(dc.depends_on) dep_id
    WHERE (SELECT status FROM work_orders WHERE id = dep_id) NOT IN ('done', 'cancelled')
  ) as blocking_deps,
  EXISTS(
    SELECT 1 
    FROM unnest(dc.depends_on) dep_id
    WHERE (SELECT status FROM work_orders WHERE id = dep_id) NOT IN ('done', 'cancelled')
  ) as is_blocked
FROM dep_chain dc
ORDER BY depth, slug;
$$;


--
-- Name: wo_enforcer(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.wo_enforcer(p_work_order_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_wo work_orders;
  v_error_msg TEXT;
  v_trace_id TEXT;
BEGIN
  -- Get trace context for lesson logging
  v_trace_id := current_setting('app.current_trace_id', true);
  
  SELECT * INTO v_wo FROM work_orders WHERE id = p_work_order_id;
  
  IF v_wo.id IS NULL THEN
    v_error_msg := 'Work order not found: ' || p_work_order_id;
    PERFORM log_harness_error_as_lesson(
      v_error_msg,
      'wo_enforcer validation',
      p_work_order_id,
      v_trace_id,
      'incorrect_assumption'
    );
    RAISE EXCEPTION '%', v_error_msg;
  END IF;
  
  IF v_wo.status NOT IN ('in_progress', 'ready') THEN
    v_error_msg := 'Work order not in executable state: ' || v_wo.status;
    PERFORM log_harness_error_as_lesson(
      v_error_msg,
      'wo_enforcer validation for ' || v_wo.slug,
      p_work_order_id,
      v_trace_id,
      'tool_misuse'
    );
    RAISE EXCEPTION '%', v_error_msg;
  END IF;
  
  -- Log successful validation as trace event if context exists
  IF v_trace_id IS NOT NULL AND v_trace_id != '' THEN
    BEGIN
      INSERT INTO trace_events (trace_id, event_type, name, payload)
      VALUES (v_trace_id, 'log', 'wo_enforcer:validated', 
        jsonb_build_object('work_order_id', p_work_order_id, 'status', v_wo.status));
    EXCEPTION WHEN OTHERS THEN
      -- Ignore trace event failures
      NULL;
    END;
  END IF;
  
  RETURN TRUE;
END;
$$;


--
-- Name: wo_insert(text, text, public.work_order_priority, text, text[], uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.wo_insert(p_name text, p_objective text, p_priority public.work_order_priority DEFAULT 'p2_medium'::public.work_order_priority, p_source text DEFAULT 'direct'::text, p_tags text[] DEFAULT '{}'::text[], p_parent_id uuid DEFAULT NULL::uuid, p_spawn_type text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_wo_id uuid;
  v_slug text;
  v_agent_id uuid;
  v_agent_name text;
  v_ac_validation record;
  v_complexity_result jsonb;
  v_has_local_tag boolean := false;
  v_has_frontend_tag boolean := false;
  v_skip_detection boolean := false;
  v_local_tags text[] := ARRAY['local-filesystem', 'rollback', 'portal-frontend', 'git-delivery'];
  v_frontend_tags text[] := ARRAY['frontend', 'ui', 'portal', 'html', 'dashboard', 'css'];
  v_error text;
BEGIN
  -- Guard: Validate acceptance_criteria presence (trg_validate_acceptance_criteria logic)
  -- Since objective is provided, we'll use it as acceptance_criteria proxy
  -- In production, caller should provide acceptance_criteria separately
  
  -- Determine routing (trg_auto_route_portal_insert logic)
  v_skip_detection := ('remediation' = ANY(p_tags)) OR (p_source IN ('auto-qa', 'api'));
  
  -- Check for frontend tags
  SELECT EXISTS (SELECT 1 FROM unnest(p_tags) t WHERE t = ANY(v_frontend_tags)) INTO v_has_frontend_tag;
  
  -- Check for local-filesystem tags
  IF NOT v_skip_detection THEN
    SELECT EXISTS (SELECT 1 FROM unnest(p_tags) t WHERE t = ANY(v_local_tags)) INTO v_has_local_tag;
  END IF;
  
  -- Route to appropriate agent
  IF v_has_frontend_tag AND NOT v_has_local_tag THEN
    v_agent_name := 'frontend';
  ELSIF v_has_local_tag AND NOT v_skip_detection THEN
    v_agent_name := 'builder';
  ELSE
    -- Use complexity scoring
    v_complexity_result := score_wo_complexity(p_objective, NULL);
    v_agent_name := v_complexity_result->>'recommended_agent';
  END IF;
  
  -- Get agent ID
  SELECT id INTO v_agent_id FROM agents WHERE name = v_agent_name AND status = 'active';
  
  -- Generate slug
  v_slug := 'WO-' || to_char(now(), 'YYYYMMDD') || '-' || substr(md5(random()::text), 1, 4);
  
  -- Insert work order
  INSERT INTO work_orders (
    slug,
    name,
    objective,
    priority,
    source,
    tags,
    parent_id,
    spawn_type,
    status,
    assigned_to,
    approved_at
  ) VALUES (
    v_slug,
    p_name,
    p_objective,
    p_priority,
    COALESCE(current_setting('app.wo_source', true), p_source, 'direct'),
    p_tags,
    p_parent_id,
    p_spawn_type,
    'draft',
    v_agent_id,
    -- Auto-approve: P1/P2/P3 and auto-qa source
    CASE 
      WHEN p_priority IN ('p1_high', 'p2_medium', 'p3_low') THEN now()
      WHEN p_source = 'auto-qa' THEN now()
      ELSE NULL
    END
  )
  RETURNING id INTO v_wo_id;
  
  -- Emit auto_advance_new_wo event to outbox
  INSERT INTO wo_events (
    work_order_id,
    event_type,
    previous_status,
    new_status,
    payload,
    actor,
    depth,
    status
  ) VALUES (
    v_wo_id,
    'auto_advance_new_wo',
    NULL,
    'draft',
    jsonb_build_object(
      'name', p_name,
      'objective', p_objective,
      'priority', p_priority,
      'source', p_source,
      'tags', p_tags,
      'parent_id', p_parent_id,
      'spawn_type', p_spawn_type,
      'routed_to', v_agent_name,
      'auto_approved', CASE 
        WHEN p_priority IN ('p1_high', 'p2_medium', 'p3_low') THEN true
        WHEN p_source = 'auto-qa' THEN true
        ELSE false
      END
    ),
    'system',
    0,
    'pending'
  );
  
  -- Log state mutation
  INSERT INTO state_mutations (mutation_type, target_table, target_id, payload)
  VALUES ('INSERT', 'work_orders', v_wo_id,
    jsonb_build_object(
      'action', 'wo_insert',
      'name', p_name,
      'source', p_source,
      'routed_to', v_agent_name,
      'auto_approved', CASE 
        WHEN p_priority IN ('p1_high', 'p2_medium', 'p3_low') THEN true
        WHEN p_source = 'auto-qa' THEN true
        ELSE false
      END
    )
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'work_order_id', v_wo_id,
    'slug', v_slug,
    'status', 'draft',
    'assigned_to', v_agent_name,
    'auto_approved', CASE 
      WHEN p_priority IN ('p1_high', 'p2_medium', 'p3_low') THEN true
      WHEN p_source = 'auto-qa' THEN true
      ELSE false
    END
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object(
    'success', false,
    'error', SQLERRM
  );
END;
$$;


--
-- Name: wo_transition(uuid, text, jsonb, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.wo_transition(p_wo_id uuid, p_event text, p_payload jsonb DEFAULT '{}'::jsonb, p_actor text DEFAULT 'system'::text, p_depth integer DEFAULT 0) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'extensions'
    AS $$
DECLARE
  v_wo record; v_wo_after record;
  v_result jsonb; v_new_status text; v_event_id uuid;
  v_effects_written int;
  v_prev_hash text; v_version int; v_hash_input text; v_hash text;
  v_state_before jsonb; v_state_after jsonb;
  v_wo_jsonb jsonb;
  v_spec_transitions jsonb;
  v_transition_spec jsonb;
  v_preconditions jsonb;
  v_postconditions jsonb;
  v_precond_names text[];
  v_postcond_names text[];
  v_precond_result jsonb;
  v_postcond_result jsonb;
  v_evidence jsonb;
  -- K007: mutation summary
  v_mutation_summary jsonb;
BEGIN
  SELECT * INTO v_wo FROM work_orders WHERE id = p_wo_id FOR UPDATE;
  IF v_wo.id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Work order not found');
  END IF;

  v_state_before := jsonb_build_object(
    'status', v_wo.status, 'assigned_to', v_wo.assigned_to,
    'approved_at', v_wo.approved_at, 'started_at', v_wo.started_at,
    'completed_at', v_wo.completed_at, 'retry_count', v_wo.retry_count,
    'qa_review_verified_at', v_wo.qa_review_verified_at
  );

  v_result := evaluate_transition(v_wo.status, p_event,
    p_payload || jsonb_build_object('work_order_id', p_wo_id, 'complexity', v_wo.complexity,
      'retry_count', COALESCE(v_wo.retry_count, 0), 'max_retries', COALESCE(v_wo.max_retries, 2),
      'enforcer_verified', v_wo.enforcer_verified), p_depth);

  IF NOT (v_result->>'ok')::boolean THEN
    RETURN jsonb_build_object('success', false, 'error', v_result->>'error', 'evaluation', v_result);
  END IF;

  v_new_status := v_result->>'new_status';

  -- K006: Evaluate preconditions from kernel spec
  v_wo_jsonb := row_to_json(v_wo)::jsonb;

  SELECT spec->'transitions' INTO v_spec_transitions
  FROM kernel_spec ORDER BY id DESC LIMIT 1;

  IF v_spec_transitions IS NOT NULL THEN
    SELECT value INTO v_transition_spec
    FROM jsonb_array_elements(v_spec_transitions)
    WHERE value->>'from_status' = v_wo.status::text
      AND value->>'event' = p_event
    LIMIT 1;

    IF v_transition_spec IS NOT NULL THEN
      v_preconditions := v_transition_spec->'preconditions';
      v_postconditions := v_transition_spec->'postconditions';
    END IF;
  END IF;

  IF v_preconditions IS NOT NULL AND jsonb_typeof(v_preconditions) = 'array'
     AND jsonb_array_length(v_preconditions) > 0 THEN
    SELECT array_agg(elem) INTO v_precond_names
    FROM jsonb_array_elements_text(v_preconditions) AS elem;

    v_precond_result := evaluate_invariants(v_wo_jsonb, v_precond_names);

    IF NOT (v_precond_result->>'passed')::boolean THEN
      RETURN jsonb_build_object(
        'success', false,
        'error', 'Preconditions failed',
        'details', v_precond_result->'results'
      );
    END IF;
  END IF;

  SET LOCAL app.wo_transition_nonce = '';
  PERFORM set_config('app.wo_transition_nonce', gen_random_uuid()::text, true);

  UPDATE work_orders SET
    status = v_new_status::work_order_status, updated_at = now(),
    started_at = CASE WHEN v_new_status = 'in_progress' AND started_at IS NULL THEN now() ELSE started_at END,
    completed_at = CASE WHEN v_new_status = 'done' THEN now() ELSE completed_at END,
    approved_at = CASE WHEN v_new_status = 'ready' AND approved_at IS NULL THEN now() ELSE approved_at END,
    retry_count = CASE WHEN (v_result->'effects') @> '[{"type":"increment_retry_count"}]' THEN COALESCE(retry_count, 0) + 1 ELSE retry_count END,
    qa_review_verified_at = CASE WHEN p_event = 'qa_passed' THEN now() WHEN p_event = 'qa_failed' THEN NULL ELSE qa_review_verified_at END
  WHERE id = p_wo_id;

  SELECT * INTO v_wo_after FROM work_orders WHERE id = p_wo_id;
  v_state_after := jsonb_build_object(
    'status', v_wo_after.status, 'assigned_to', v_wo_after.assigned_to,
    'approved_at', v_wo_after.approved_at, 'started_at', v_wo_after.started_at,
    'completed_at', v_wo_after.completed_at, 'retry_count', v_wo_after.retry_count,
    'qa_review_verified_at', v_wo_after.qa_review_verified_at
  );

  IF v_postconditions IS NOT NULL AND jsonb_typeof(v_postconditions) = 'array'
     AND jsonb_array_length(v_postconditions) > 0 THEN
    SELECT array_agg(elem) INTO v_postcond_names
    FROM jsonb_array_elements_text(v_postconditions) AS elem;

    v_postcond_result := evaluate_invariants(row_to_json(v_wo_after)::jsonb, v_postcond_names);

    IF NOT (v_postcond_result->>'passed')::boolean THEN
      RAISE EXCEPTION 'Postconditions failed: %', v_postcond_result->'results';
    END IF;
  END IF;

  -- K007: mutation_summary for submit_for_review transitions
  IF p_event = 'submit_for_review' THEN
    SELECT jsonb_build_object(
      'total', count(*),
      'successful', count(*) FILTER (WHERE success = true),
      'failed', count(*) FILTER (WHERE success = false)
    ) INTO v_mutation_summary
    FROM wo_mutations WHERE work_order_id = p_wo_id;
  END IF;

  -- K006+K007: Build evidence
  v_evidence := jsonb_build_object(
    'precondition_results', COALESCE(v_precond_result->'results', '[]'::jsonb),
    'postcondition_results', COALESCE(v_postcond_result->'results', '[]'::jsonb),
    'state_hash_before', encode(extensions.digest(v_state_before::text, 'sha256'), 'hex'),
    'state_hash_after', encode(extensions.digest(v_state_after::text, 'sha256'), 'hex')
  );

  IF v_mutation_summary IS NOT NULL THEN
    v_evidence := v_evidence || jsonb_build_object('mutation_summary', v_mutation_summary);
  END IF;

  -- K004: Hash-chained event stream
  SELECT hash INTO v_prev_hash FROM wo_event_stream
    WHERE stream_id = p_wo_id ORDER BY version DESC LIMIT 1;
  v_version := COALESCE(
    (SELECT max(version) FROM wo_event_stream WHERE stream_id = p_wo_id), 0
  ) + 1;
  v_hash_input := COALESCE(v_prev_hash, 'genesis') || '|' || p_event || '|' ||
    p_wo_id::text || '|' || v_version::text || '|' || p_payload::text;
  v_hash := encode(extensions.digest(v_hash_input, 'sha256'), 'hex');

  INSERT INTO wo_event_stream (stream_id, version, event_type, actor, payload,
    state_before, state_after, hash, previous_hash, evidence)
  VALUES (p_wo_id, v_version, p_event, p_actor, p_payload,
    v_state_before, v_state_after, v_hash, v_prev_hash, v_evidence);

  INSERT INTO wo_events (work_order_id, event_type, previous_status, new_status, payload, actor, depth, status)
  VALUES (p_wo_id, p_event, v_wo.status::text, v_new_status, p_payload, p_actor, p_depth, 'pending')
  RETURNING id INTO v_event_id;

  INSERT INTO audit_log (event_type, actor_type, action, target_type, target_id, previous_state, new_state, work_order_id, payload)
  VALUES ('wo_state_change', 'system', p_event, 'work_order', p_wo_id,
    jsonb_build_object('status', v_wo.status), jsonb_build_object('status', v_new_status), p_wo_id, p_payload);

  INSERT INTO wo_mutations (work_order_id, tool_name, object_type, object_id, action, success, context, agent_name)
  VALUES (p_wo_id, 'wo_transition', 'work_order', p_wo_id::text, p_event, true,
    jsonb_build_object('previous_status', v_wo.status, 'new_status', v_new_status, 'actor', p_actor), p_actor);

  INSERT INTO wo_effects (work_order_id, effect_type, payload, status)
  SELECT p_wo_id, er.effect_type,
    p_payload || jsonb_build_object(
      'handler', er.handler, 'config', er.config, 'event', p_event,
      'previous_status', v_wo.status::text, 'new_status', v_new_status,
      'wo_id', p_wo_id, 'wo_slug', v_wo.slug, 'wo_name', v_wo.name, 'actor', p_actor
    ), 'pending'
  FROM wo_effect_registry er
  WHERE er.trigger_on_status = v_new_status::work_order_status AND er.enabled = true
  ORDER BY er.execution_order;

  GET DIAGNOSTICS v_effects_written = ROW_COUNT;

  RETURN jsonb_build_object('success', true, 'work_order_id', p_wo_id,
    'previous_status', v_wo.status::text, 'new_status', v_new_status,
    'effects', v_result->'effects', 'event_id', v_event_id,
    'effects_enqueued', v_effects_written);

EXCEPTION WHEN OTHERS THEN
  INSERT INTO wo_mutations (work_order_id, tool_name, object_type, object_id, action, success, error_detail, context, agent_name)
  VALUES (p_wo_id, 'wo_transition', 'work_order', p_wo_id::text, p_event, false, SQLERRM,
    jsonb_build_object('previous_status', v_wo.status, 'new_status', v_new_status, 'actor', p_actor), p_actor);
  RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;


--
-- Name: write_team_context(uuid, text, text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.write_team_context(p_work_order_id uuid, p_context_type text, p_content text, p_author_agent text DEFAULT 'builder'::text, p_metadata jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_root_wo_id uuid;
  v_current_id uuid;
  v_parent_id uuid;
  v_result_id uuid;
  v_depth int := 0;
BEGIN
  -- Validate context_type
  IF p_context_type NOT IN ('plan', 'finding', 'decision', 'file_list', 'schema_change') THEN
    RAISE EXCEPTION 'Invalid context_type: %. Must be one of: plan, finding, decision, file_list, schema_change', p_context_type;
  END IF;

  -- Walk up parent_id chain to find root WO
  v_current_id := p_work_order_id;
  LOOP
    SELECT parent_id INTO v_parent_id FROM work_orders WHERE id = v_current_id;
    IF v_parent_id IS NULL THEN
      v_root_wo_id := v_current_id;
      EXIT;
    END IF;
    v_current_id := v_parent_id;
    v_depth := v_depth + 1;
    -- Safety: prevent infinite loops (max 20 levels deep)
    IF v_depth > 20 THEN
      v_root_wo_id := v_current_id;
      EXIT;
    END IF;
  END LOOP;

  -- Insert the team context entry
  INSERT INTO team_context (root_wo_id, source_wo_id, author_agent, context_type, content, metadata)
  VALUES (v_root_wo_id, p_work_order_id, p_author_agent, p_context_type, p_content, p_metadata)
  RETURNING id INTO v_result_id;

  RETURN v_result_id;
END;
$$;


--
-- Name: FUNCTION write_team_context(p_work_order_id uuid, p_context_type text, p_content text, p_author_agent text, p_metadata jsonb); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION public.write_team_context(p_work_order_id uuid, p_context_type text, p_content text, p_author_agent text, p_metadata jsonb) IS 'Write a team context entry. Automatically resolves root WO by walking parent_id chain.';


--
-- Name: wo_mutations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wo_mutations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    tool_name text NOT NULL,
    object_type text NOT NULL,
    object_id text NOT NULL,
    action text NOT NULL,
    success boolean NOT NULL,
    error_class text,
    error_detail text,
    verification_query text,
    verified boolean DEFAULT false,
    context jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    agent_name text NOT NULL,
    CONSTRAINT wo_mutations_error_class_check CHECK ((error_class = ANY (ARRAY['sql_syntax'::text, 'rls_violation'::text, 'schema_mismatch'::text, 'encoding_error'::text, 'github_match_failure'::text, 'github_api_error'::text, 'timeout'::text, 'enforcement_blocked'::text, 'unknown'::text])))
);


--
-- Name: action_success_rates; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.action_success_rates AS
 SELECT tool_name,
    object_type,
    action,
    count(*) AS total_attempts,
    count(*) FILTER (WHERE success) AS successes,
    round(((count(*) FILTER (WHERE success))::numeric / (GREATEST(count(*), (1)::bigint))::numeric), 3) AS success_rate
   FROM public.wo_mutations
  GROUP BY tool_name, object_type, action
  WITH NO DATA;


--
-- Name: action_type_rates; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.action_type_rates AS
 SELECT tool_name,
    action,
    count(*) AS total_attempts,
    count(*) FILTER (WHERE success) AS successes,
    round(((count(*) FILTER (WHERE success))::numeric / (GREATEST(count(*), (1)::bigint))::numeric), 4) AS success_rate,
    round(
        CASE
            WHEN (count(*) > 0) THEN (((((count(*) FILTER (WHERE success))::numeric / (count(*))::numeric) + (1.9208 / ((2 * count(*)))::numeric)) - (1.96 * sqrt((((((count(*) FILTER (WHERE success))::numeric / (count(*))::numeric) * ((1)::numeric - ((count(*) FILTER (WHERE success))::numeric / (count(*))::numeric))) + (0.9604 / (count(*))::numeric)) / (count(*))::numeric)))) / ((1)::numeric + (3.8416 / (count(*))::numeric)))
            ELSE (0)::numeric
        END, 4) AS wilson_lower,
    round(
        CASE
            WHEN (count(*) > 0) THEN (((((count(*) FILTER (WHERE success))::numeric / (count(*))::numeric) + (1.9208 / ((2 * count(*)))::numeric)) + (1.96 * sqrt((((((count(*) FILTER (WHERE success))::numeric / (count(*))::numeric) * ((1)::numeric - ((count(*) FILTER (WHERE success))::numeric / (count(*))::numeric))) + (0.9604 / (count(*))::numeric)) / (count(*))::numeric)))) / ((1)::numeric + (3.8416 / (count(*))::numeric)))
            ELSE (1)::numeric
        END, 4) AS wilson_upper
   FROM public.wo_mutations
  WHERE ((action IS NOT NULL) AND (action <> ''::text))
  GROUP BY tool_name, action
 HAVING (count(*) >= 3)
  WITH NO DATA;


--
-- Name: decisions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.decisions (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    type public.decision_type NOT NULL,
    status public.decision_status DEFAULT 'active'::public.decision_status,
    subject text NOT NULL,
    choice text NOT NULL,
    rationale text,
    context_summary text,
    alternatives_considered jsonb DEFAULT '[]'::jsonb,
    made_by text DEFAULT 'oliver'::text,
    made_at timestamp with time zone DEFAULT now(),
    org public.org_type,
    source_conversation_id uuid,
    source_message_id uuid,
    superseded_by uuid,
    supersedes uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: active_decisions; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.active_decisions AS
 SELECT id,
    type,
    status,
    subject,
    choice,
    rationale,
    context_summary,
    alternatives_considered,
    made_by,
    made_at,
    org,
    source_conversation_id,
    source_message_id,
    superseded_by,
    supersedes,
    created_at,
    updated_at
   FROM public.decisions
  WHERE (status = 'active'::public.decision_status);


--
-- Name: active_sessions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.active_sessions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    session_token text NOT NULL,
    user_id text NOT NULL,
    source text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone NOT NULL,
    last_activity timestamp with time zone DEFAULT now(),
    metadata jsonb DEFAULT '{}'::jsonb,
    CONSTRAINT active_sessions_source_check CHECK ((source = ANY (ARRAY['portal'::text, 'cli'::text, 'api'::text])))
);


--
-- Name: TABLE active_sessions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.active_sessions IS 'Valid sessions for METIS portal/CLI/API access';


--
-- Name: agent_daemon_config; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.agent_daemon_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id uuid NOT NULL,
    poll_interval_seconds integer DEFAULT 30 NOT NULL,
    queue_filter jsonb DEFAULT '{}'::jsonb NOT NULL,
    execution_mode text NOT NULL,
    max_concurrent integer DEFAULT 1 NOT NULL,
    active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT agent_daemon_config_execution_mode_check CHECK ((execution_mode = ANY (ARRAY['claude_cli'::text, 'edge_function'::text, 'webhook'::text])))
);


--
-- Name: TABLE agent_daemon_config; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.agent_daemon_config IS 'Configuration for multi-agent daemon framework. Each agent worker polls its queue based on queue_filter and executes work in specified execution_mode.';


--
-- Name: COLUMN agent_daemon_config.agent_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_daemon_config.agent_id IS 'Reference to agents table';


--
-- Name: COLUMN agent_daemon_config.poll_interval_seconds; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_daemon_config.poll_interval_seconds IS 'How often this agent worker polls for new work';


--
-- Name: COLUMN agent_daemon_config.queue_filter; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_daemon_config.queue_filter IS 'JSONB filter criteria for work queue (e.g., {status: ready, assigned_to: agent_id})';


--
-- Name: COLUMN agent_daemon_config.execution_mode; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_daemon_config.execution_mode IS 'How work is executed: claude_cli, edge_function, or webhook';


--
-- Name: COLUMN agent_daemon_config.max_concurrent; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_daemon_config.max_concurrent IS 'Maximum concurrent work items this agent can handle';


--
-- Name: COLUMN agent_daemon_config.active; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_daemon_config.active IS 'Whether this agent worker is active';


--
-- Name: agent_escalation_tiers; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.agent_escalation_tiers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_name text NOT NULL,
    tier_order integer NOT NULL,
    model text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: agent_execution_profiles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.agent_execution_profiles (
    agent_name text NOT NULL,
    mission text NOT NULL,
    pace text NOT NULL,
    error_style text NOT NULL,
    scope_boundaries jsonb DEFAULT '{}'::jsonb NOT NULL,
    escalation_rules jsonb DEFAULT '{}'::jsonb NOT NULL,
    budget_guidance jsonb DEFAULT '{}'::jsonb NOT NULL,
    tool_categories text[] DEFAULT '{}'::text[] NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    model text DEFAULT 'claude-opus-4-6'::text,
    max_tokens integer DEFAULT 16384,
    escalation_tiers jsonb DEFAULT '[]'::jsonb,
    custom_instructions text,
    CONSTRAINT agent_execution_profiles_error_style_check CHECK ((error_style = ANY (ARRAY['retry-then-escalate'::text, 'fail-fast'::text, 'absorb-and-continue'::text]))),
    CONSTRAINT agent_execution_profiles_pace_check CHECK ((pace = ANY (ARRAY['aggressive'::text, 'measured'::text, 'conservative'::text])))
);


--
-- Name: TABLE agent_execution_profiles; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.agent_execution_profiles IS 'Per-agent behavioral parameters incorporating external best practices and internal operational rules. Replaces generic execution rules with sophisticated agent-specific guidance.';


--
-- Name: COLUMN agent_execution_profiles.max_tokens; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_execution_profiles.max_tokens IS 'Max output tokens per API call. Should reflect model capability. Default 16384.';


--
-- Name: COLUMN agent_execution_profiles.escalation_tiers; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_execution_profiles.escalation_tiers IS 'Ordered list of escalation tiers: [{tier: 0, model: "minimax/minimax-m2.5"}, {tier: 1, model: "claude-sonnet-4-5-20250929"}, {tier: 2, model: "claude-opus-4-6"}]';


--
-- Name: COLUMN agent_execution_profiles.custom_instructions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_execution_profiles.custom_instructions IS 'Free-text instructions injected into the agent system prompt. Contains agent-specific context, patterns, constraints, and domain knowledge. Assembled by context.ts buildAgentContext().';


--
-- Name: agent_knowledge_base; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.agent_knowledge_base (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    category text NOT NULL,
    topic text NOT NULL,
    content text NOT NULL,
    applicable_roles text[] DEFAULT '{general}'::text[],
    applicable_tags text[] DEFAULT '{general}'::text[],
    severity text DEFAULT 'important'::text NOT NULL,
    active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT agent_knowledge_base_category_check CHECK ((category = ANY (ARRAY['schema_gotcha'::text, 'deployment'::text, 'enforcement'::text, 'testing'::text, 'qa_pattern'::text, 'rpc_signature'::text, 'enum_values'::text, 'operational'::text, 'agent_routing'::text, 'remediation'::text, 'process'::text, 'project_context'::text, 'failure_archetype'::text, 'best_practice'::text]))),
    CONSTRAINT agent_knowledge_base_severity_check CHECK ((severity = ANY (ARRAY['critical'::text, 'important'::text, 'reference'::text])))
);


--
-- Name: TABLE agent_knowledge_base; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.agent_knowledge_base IS 'Structured institutional knowledge for agent context loading. Filtered by role + WO tags.';


--
-- Name: COLUMN agent_knowledge_base.applicable_roles; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_knowledge_base.applicable_roles IS 'Which agent roles see this: {general}=all, {executor}=builder/ilmarinen, {evaluator}=qa-gate, {observer}=ops, {reviewer}=reviewer';


--
-- Name: COLUMN agent_knowledge_base.applicable_tags; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_knowledge_base.applicable_tags IS 'WO-tag overlap filter like directives. {general}=always loaded.';


--
-- Name: COLUMN agent_knowledge_base.severity; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agent_knowledge_base.severity IS 'critical=always loaded, important=loaded if role matches, reference=loaded only if tags match';


--
-- Name: agent_memory; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.agent_memory (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id text NOT NULL,
    memory_type text NOT NULL,
    key text NOT NULL,
    value jsonb NOT NULL,
    updated_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone,
    CONSTRAINT agent_memory_memory_type_check CHECK ((memory_type = ANY (ARRAY['pattern'::text, 'gotcha'::text, 'preference'::text, 'fact'::text])))
);


--
-- Name: agent_performance; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.agent_performance AS
 WITH agent_stats AS (
         SELECT wo_mutations.agent_name,
            count(*) AS total_mutations,
            count(*) FILTER (WHERE (wo_mutations.success = true)) AS success_count,
            count(DISTINCT wo_mutations.work_order_id) AS distinct_work_orders,
            mode() WITHIN GROUP (ORDER BY wo_mutations.tool_name) AS most_used_tool,
            mode() WITHIN GROUP (ORDER BY wo_mutations.error_class) FILTER (WHERE (wo_mutations.error_class IS NOT NULL)) AS most_common_error
           FROM public.wo_mutations
          WHERE (wo_mutations.created_at >= (now() - '7 days'::interval))
          GROUP BY wo_mutations.agent_name
        )
 SELECT agent_name,
    total_mutations,
    round((((success_count)::numeric / (NULLIF(total_mutations, 0))::numeric) * (100)::numeric), 2) AS success_rate,
    round(((total_mutations)::numeric / (NULLIF(distinct_work_orders, 0))::numeric), 2) AS avg_mutations_per_wo,
    most_used_tool,
    most_common_error
   FROM agent_stats
  ORDER BY total_mutations DESC;


--
-- Name: agent_quotas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.agent_quotas (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id uuid,
    quota_type text NOT NULL,
    limit_value integer NOT NULL,
    current_value integer DEFAULT 0,
    window_start timestamp with time zone DEFAULT now(),
    enabled boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT agent_quotas_quota_type_check CHECK ((quota_type = ANY (ARRAY['requests_per_minute'::text, 'requests_per_hour'::text, 'llm_tokens_per_day'::text, 'mutations_per_hour'::text])))
);


--
-- Name: agents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.agents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    agent_type text NOT NULL,
    status text DEFAULT 'active'::text,
    description text,
    config jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    role text,
    escalation_target uuid,
    routing_tags text[] DEFAULT '{}'::text[],
    execution_mode text DEFAULT 'manual'::text,
    max_concurrent_wos integer DEFAULT 1,
    tools_allowed text[],
    model text DEFAULT 'claude-opus-4-6'::text,
    CONSTRAINT agents_agent_type_check CHECK ((agent_type = ANY (ARRAY['leader'::text, 'executor'::text, 'reviewer'::text, 'specialist'::text, 'evaluator'::text, 'observer'::text, 'orchestrator'::text]))),
    CONSTRAINT agents_execution_mode_check CHECK ((execution_mode = ANY (ARRAY['server_side'::text, 'local_cli'::text, 'automated'::text, 'portal'::text, 'manual'::text]))),
    CONSTRAINT agents_role_check CHECK ((role = ANY (ARRAY['executor'::text, 'evaluator'::text, 'observer'::text, 'orchestrator'::text, 'specialist'::text, 'reviewer'::text]))),
    CONSTRAINT agents_status_check CHECK ((status = ANY (ARRAY['active'::text, 'paused'::text, 'offline'::text])))
);


--
-- Name: COLUMN agents.role; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agents.role IS 'Squad role: executor, evaluator, observer, orchestrator, specialist, reviewer';


--
-- Name: COLUMN agents.escalation_target; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agents.escalation_target IS 'Agent to escalate unresolvable issues to';


--
-- Name: COLUMN agents.routing_tags; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agents.routing_tags IS 'Tags that determine which WOs get routed to this agent';


--
-- Name: COLUMN agents.execution_mode; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agents.execution_mode IS 'How this agent executes: server_side, local_cli, automated, portal, manual';


--
-- Name: COLUMN agents.max_concurrent_wos; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agents.max_concurrent_wos IS 'Maximum concurrent WOs this agent can handle';


--
-- Name: COLUMN agents.model; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.agents.model IS 'Anthropic model ID used for this agent. Can be overridden per-WO via client_info.model_override.';


--
-- Name: allowed_actions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.allowed_actions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    action_name text NOT NULL,
    description text,
    required_params jsonb DEFAULT '[]'::jsonb,
    optional_params jsonb DEFAULT '[]'::jsonb,
    requires_work_order boolean DEFAULT true,
    allowed_agents uuid[] DEFAULT '{}'::uuid[],
    rate_limit_per_minute integer DEFAULT 60,
    enabled boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: approval_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.approval_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    gate_id uuid,
    work_order_id uuid,
    request_type text NOT NULL,
    request_summary text NOT NULL,
    request_detail jsonb DEFAULT '{}'::jsonb,
    status text DEFAULT 'pending'::text,
    requested_by text NOT NULL,
    requested_at timestamp with time zone DEFAULT now(),
    decided_by text,
    decided_at timestamp with time zone,
    decision_notes text,
    expires_at timestamp with time zone,
    notified_at timestamp with time zone,
    CONSTRAINT approval_queue_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text, 'auto_approved'::text, 'expired'::text])))
);


--
-- Name: TABLE approval_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.approval_queue IS 'Pending and historical approval requests';


--
-- Name: audit_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.audit_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_type text NOT NULL,
    actor_type text NOT NULL,
    actor_id text,
    target_type text,
    target_id uuid,
    action text NOT NULL,
    payload jsonb DEFAULT '{}'::jsonb,
    previous_state jsonb,
    new_state jsonb,
    work_order_id uuid,
    session_id text,
    ip_address inet,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT audit_log_actor_type_check CHECK ((actor_type = ANY (ARRAY['agent'::text, 'user'::text, 'system'::text, 'llm'::text])))
);


--
-- Name: auto_approval_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.auto_approval_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    risk_score numeric(5,2) NOT NULL,
    risk_dimensions jsonb DEFAULT '{}'::jsonb NOT NULL,
    decision text NOT NULL,
    denial_reasons text[],
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT auto_approval_log_decision_check CHECK ((decision = ANY (ARRAY['approved'::text, 'denied'::text, 'escalated'::text, 'dry_run'::text])))
);


--
-- Name: backlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.backlog (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    summary text,
    type text,
    status text DEFAULT 'inbox'::text,
    priority text DEFAULT 'unranked'::text,
    source text,
    source_context text,
    tags text[],
    project text DEFAULT 'master_layer'::text,
    notion_id text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone
);


--
-- Name: wo_batches; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wo_batches (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    project_brief_id uuid,
    status text DEFAULT 'draft'::text NOT NULL,
    created_by text DEFAULT 'engineering'::text NOT NULL,
    approved_by text,
    approved_at timestamp with time zone,
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    metadata jsonb DEFAULT '{}'::jsonb,
    execution_mode public.execution_mode DEFAULT 'step'::public.execution_mode NOT NULL,
    requires_batch_approval boolean DEFAULT true NOT NULL,
    batch_approved_by text,
    batch_approved_at timestamp with time zone,
    execution_started_at timestamp with time zone,
    execution_completed_at timestamp with time zone,
    parallel_slots integer DEFAULT 3,
    execution_config jsonb DEFAULT '{}'::jsonb,
    CONSTRAINT wo_batches_status_check CHECK ((status = ANY (ARRAY['draft'::text, 'approved'::text, 'in_progress'::text, 'completed'::text, 'cancelled'::text])))
);


--
-- Name: TABLE wo_batches; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.wo_batches IS 'Batch/sprint groupings for work orders. Enables hierarchical organization: Project > Batch > WOs > Sub-WOs';


--
-- Name: COLUMN wo_batches.status; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.wo_batches.status IS 'Batch lifecycle: draft, approved, in_progress, completed, cancelled';


--
-- Name: COLUMN wo_batches.execution_mode; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.wo_batches.execution_mode IS 'Execution mode: step (one WO at a time, manual approval), batch (sprint-style concurrent execution with dependency ordering), auto (fully autonomous creation, approval, and execution)';


--
-- Name: COLUMN wo_batches.requires_batch_approval; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.wo_batches.requires_batch_approval IS 'Whether this batch requires explicit approval before execution';


--
-- Name: COLUMN wo_batches.parallel_slots; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.wo_batches.parallel_slots IS 'Maximum number of independent WOs that can execute concurrently within this batch';


--
-- Name: COLUMN wo_batches.execution_config; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.wo_batches.execution_config IS 'Mode-specific execution configuration (e.g., guardrails, auto-decomposition settings)';


--
-- Name: work_orders; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.work_orders (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    slug text NOT NULL,
    name text NOT NULL,
    created_by public.agent_type DEFAULT 'you'::public.agent_type NOT NULL,
    assigned_to_legacy public.agent_type,
    status public.work_order_status DEFAULT 'draft'::public.work_order_status NOT NULL,
    priority public.work_order_priority DEFAULT 'p2_medium'::public.work_order_priority NOT NULL,
    complexity public.work_order_complexity DEFAULT 'unknown'::public.work_order_complexity,
    summary text,
    objective text NOT NULL,
    constraints text,
    acceptance_criteria text,
    escalation_conditions text,
    max_iterations integer DEFAULT 10,
    tags text[] DEFAULT '{}'::text[],
    project_brief_id uuid,
    backlog_source_id uuid,
    notion_page_id text,
    notion_synced_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    started_at timestamp with time zone,
    completed_at timestamp with time zone,
    history jsonb DEFAULT '[]'::jsonb,
    collaboration_mode text DEFAULT 'single'::text,
    assigned_to uuid,
    requires_approval boolean DEFAULT true,
    approved_at timestamp with time zone,
    approved_by text,
    duplicate_check jsonb,
    duplicate_acknowledged boolean DEFAULT false,
    source text DEFAULT 'unknown'::text,
    request_id text,
    request_signature text,
    client_info jsonb DEFAULT '{}'::jsonb,
    lesson_count integer DEFAULT 0,
    qa_checklist jsonb DEFAULT '[]'::jsonb,
    verification_status text DEFAULT 'unverified'::text,
    design_doc_id uuid,
    enforcer_verified boolean DEFAULT false,
    enforcer_verified_at timestamp with time zone,
    enforcer_run_id uuid,
    enforcer_last_check_at timestamp with time zone,
    depends_on uuid[],
    last_qa_run_at timestamp with time zone,
    execution_rank integer DEFAULT 500,
    pre_execution_snapshot jsonb,
    parent_id uuid,
    batch_id uuid,
    cancellation_reason text,
    qa_review_verified_at timestamp with time zone,
    dispatch_attempts integer DEFAULT 0,
    last_dispatch_at timestamp with time zone,
    last_dispatch_error text,
    spawn_type text,
    retry_count integer DEFAULT 0,
    max_retries integer DEFAULT 2,
    pipeline_phase text,
    pipeline_run_id uuid,
    target_files text[] DEFAULT '{}'::text[],
    council_deliberation_id uuid,
    CONSTRAINT work_orders_collaboration_mode_check CHECK ((collaboration_mode = ANY (ARRAY['single'::text, 'sequential'::text, 'parallel'::text]))),
    CONSTRAINT work_orders_completed_at_required_when_done CHECK (((status <> 'done'::public.work_order_status) OR (completed_at IS NOT NULL))),
    CONSTRAINT work_orders_source_check CHECK ((source = ANY (ARRAY['portal'::text, 'cli'::text, 'api'::text, 'mcp_bridge'::text, 'direct'::text, 'unknown'::text, 'test_suite'::text, 'intake_api'::text, 'lesson_promoter'::text, 'daemon'::text, 'auto_approval'::text, 'auto_qa'::text, 'auto-qa'::text, 'remediation'::text, 'engineering'::text, 'manifold'::text]))),
    CONSTRAINT work_orders_spawn_type_check CHECK ((spawn_type = ANY (ARRAY['retry'::text, 'decomposition'::text, 'prerequisite'::text]))),
    CONSTRAINT work_orders_verification_status_check CHECK ((verification_status = ANY (ARRAY['unverified'::text, 'in_progress'::text, 'verified'::text, 'failed'::text, 'skipped'::text])))
);


--
-- Name: COLUMN work_orders.source; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.source IS 'Origin of work order: portal, cli, api, mcp_bridge, direct, unknown';


--
-- Name: COLUMN work_orders.qa_checklist; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.qa_checklist IS 'QA checklist items as JSONB array. Structure: [{"id": "mobile_usability", "name": "Mobile Usability", "status": "pending|pass|fail|na", "notes": "...", "tested_by": "agent_id", "tested_at": "timestamp"}]';


--
-- Name: COLUMN work_orders.design_doc_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.design_doc_id IS 'Reference to design document in project_documents. Required for feature/architecture WOs before ready status.';


--
-- Name: COLUMN work_orders.enforcer_verified; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.enforcer_verified IS 'Gates review→done transition - set by audit enforcer only';


--
-- Name: COLUMN work_orders.depends_on; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.depends_on IS 'Array of work order IDs that must be in done status before this WO can be picked up from engineering queue';


--
-- Name: COLUMN work_orders.last_qa_run_at; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.last_qa_run_at IS 'Timestamp of most recent auto-QA invocation - used to deduplicate concurrent runs (skip if < 30 seconds ago)';


--
-- Name: COLUMN work_orders.pre_execution_snapshot; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.pre_execution_snapshot IS 'Snapshot of database state before work order execution for rollback support';


--
-- Name: COLUMN work_orders.parent_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.parent_id IS 'UUID reference to parent work order. Source of truth for WO tree relationships. Parent tags preserved for backwards compatibility.';


--
-- Name: COLUMN work_orders.batch_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.batch_id IS 'Optional FK to wo_batches. Groups WOs into sprints/batches for batch approval and tracking';


--
-- Name: COLUMN work_orders.cancellation_reason; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.cancellation_reason IS 'Structured reason why this WO was cancelled. Used for tracking cancellation patterns and reducing waste.';


--
-- Name: COLUMN work_orders.pipeline_phase; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.pipeline_phase IS 'Current Manifold pipeline phase: spec, plan, scaffold, build, verify, harden, integrate';


--
-- Name: COLUMN work_orders.pipeline_run_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_orders.pipeline_run_id IS 'FK to pipeline_runs coordinating this WO pipeline lifecycle';


--
-- Name: batch_status; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.batch_status AS
 SELECT b.id,
    b.name,
    b.description,
    b.status AS batch_status,
    b.project_brief_id,
    b.created_by,
    b.approved_by,
    b.approved_at,
    b.started_at,
    b.completed_at,
    b.created_at,
    b.updated_at,
    count(w.id) AS total_wos,
    count(w.id) FILTER (WHERE (w.status = 'done'::public.work_order_status)) AS done_count,
    count(w.id) FILTER (WHERE (w.status = 'failed'::public.work_order_status)) AS failed_count,
    count(w.id) FILTER (WHERE (w.status = 'blocked'::public.work_order_status)) AS blocked_count,
    count(w.id) FILTER (WHERE (w.status = 'in_progress'::public.work_order_status)) AS in_progress_count,
    count(w.id) FILTER (WHERE (w.status = ANY (ARRAY['draft'::public.work_order_status, 'ready'::public.work_order_status, 'pending_approval'::public.work_order_status]))) AS pending_count,
    count(w.id) FILTER (WHERE (w.status = 'cancelled'::public.work_order_status)) AS cancelled_count,
        CASE
            WHEN (count(w.id) = 0) THEN (0)::numeric
            ELSE round((((count(w.id) FILTER (WHERE (w.status = 'done'::public.work_order_status)))::numeric / (count(w.id))::numeric) * (100)::numeric), 1)
        END AS completion_pct,
    count(w.id) FILTER (WHERE (w.priority = 'p0_critical'::public.work_order_priority)) AS p0_count,
    count(w.id) FILTER (WHERE (w.priority = 'p1_high'::public.work_order_priority)) AS p1_count,
    count(w.id) FILTER (WHERE (w.priority = 'p2_medium'::public.work_order_priority)) AS p2_count,
    count(w.id) FILTER (WHERE (w.priority = 'p3_low'::public.work_order_priority)) AS p3_count,
    min(w.created_at) AS first_wo_created_at,
    max(w.updated_at) AS last_wo_updated_at,
    max(w.completed_at) AS last_wo_completed_at,
        CASE
            WHEN (count(w.id) FILTER (WHERE (w.status = 'failed'::public.work_order_status)) > 0) THEN 'failing'::text
            WHEN (count(w.id) FILTER (WHERE (w.status = 'blocked'::public.work_order_status)) > 0) THEN 'blocked'::text
            WHEN (count(w.id) FILTER (WHERE (w.status = 'in_progress'::public.work_order_status)) > 0) THEN 'active'::text
            WHEN ((count(w.id) FILTER (WHERE (w.status = 'done'::public.work_order_status)) = count(w.id)) AND (count(w.id) > 0)) THEN 'completed'::text
            ELSE 'pending'::text
        END AS health_status
   FROM (public.wo_batches b
     LEFT JOIN public.work_orders w ON ((w.batch_id = b.id)))
  GROUP BY b.id, b.name, b.description, b.status, b.project_brief_id, b.created_by, b.approved_by, b.approved_at, b.started_at, b.completed_at, b.created_at, b.updated_at;


--
-- Name: VIEW batch_status; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.batch_status IS 'Real-time batch progress tracking with WO counts, completion percentage, and health status';


--
-- Name: bypass_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.bypass_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    event_type text NOT NULL,
    source_ip text,
    user_agent text,
    session_id text,
    request_path text,
    request_body jsonb,
    detected_at timestamp with time zone DEFAULT now(),
    severity text DEFAULT 'info'::text,
    resolved boolean DEFAULT false,
    resolution_notes text,
    CONSTRAINT bypass_log_event_type_check CHECK ((event_type = ANY (ARRAY['direct_wo_create'::text, 'direct_sql'::text, 'mcp_unsigned'::text, 'missing_session'::text, 'invalid_signature'::text, 'suspicious_pattern'::text]))),
    CONSTRAINT bypass_log_severity_check CHECK ((severity = ANY (ARRAY['info'::text, 'warning'::text, 'critical'::text])))
);


--
-- Name: TABLE bypass_log; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.bypass_log IS 'Tracks attempts to bypass METIS architecture enforcement';


--
-- Name: cancellation_rate_tracking; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.cancellation_rate_tracking AS
 WITH weekly_stats AS (
         SELECT date_trunc('week'::text, work_orders.created_at) AS week_start,
            count(*) FILTER (WHERE (work_orders.status = 'cancelled'::public.work_order_status)) AS cancelled,
            count(*) AS total_wos,
            round(((100.0 * (count(*) FILTER (WHERE (work_orders.status = 'cancelled'::public.work_order_status)))::numeric) / (NULLIF(count(*), 0))::numeric), 1) AS cancel_pct,
            count(*) FILTER (WHERE ((work_orders.status = 'cancelled'::public.work_order_status) AND (work_orders.cancellation_reason IS NOT NULL))) AS reason_captured,
            count(*) FILTER (WHERE ((work_orders.complexity = ANY (ARRAY['large'::public.work_order_complexity, 'unknown'::public.work_order_complexity])) AND (work_orders.status = 'cancelled'::public.work_order_status))) AS complex_cancelled,
            count(*) FILTER (WHERE ((work_orders.complexity = ANY (ARRAY['large'::public.work_order_complexity, 'unknown'::public.work_order_complexity])) AND (work_orders.depends_on IS NOT NULL))) AS complex_decomposed
           FROM public.work_orders
          WHERE ((work_orders.source <> 'test_suite'::text) AND (work_orders.created_at > (now() - '90 days'::interval)))
          GROUP BY (date_trunc('week'::text, work_orders.created_at))
        )
 SELECT week_start,
    cancelled,
    total_wos,
    cancel_pct,
    reason_captured,
    complex_cancelled,
    complex_decomposed,
        CASE
            WHEN (cancel_pct < (15)::numeric) THEN '✓ TARGET MET (< 15%)'::text
            WHEN (cancel_pct < (20)::numeric) THEN '△ BELOW 20%'::text
            ELSE '✗ ABOVE 20%'::text
        END AS status
   FROM weekly_stats
  ORDER BY week_start DESC;


--
-- Name: VIEW cancellation_rate_tracking; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.cancellation_rate_tracking IS 'Tracks WO cancellation rate over time to measure effectiveness of WO-0069 decomposition gate. Target: <20% within 2 weeks, <15% within 4 weeks.';


--
-- Name: clarification_requests; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.clarification_requests (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    question text NOT NULL,
    context text,
    options jsonb,
    urgency text DEFAULT 'normal'::text,
    status text DEFAULT 'pending'::text,
    response text,
    responded_at timestamp with time zone,
    responded_by text,
    expires_at timestamp with time zone DEFAULT (now() + '24:00:00'::interval),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT clarification_requests_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'answered'::text, 'expired'::text, 'cancelled'::text]))),
    CONSTRAINT clarification_requests_urgency_check CHECK ((urgency = ANY (ARRAY['low'::text, 'normal'::text, 'high'::text])))
);


--
-- Name: consensus_votes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.consensus_votes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    agent_id uuid NOT NULL,
    vote text NOT NULL,
    reason text,
    evidence jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT consensus_votes_vote_check CHECK ((vote = ANY (ARRAY['approve'::text, 'reject'::text, 'abstain'::text])))
);


--
-- Name: conversation_threads; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.conversation_threads (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id text,
    project_id uuid,
    title text,
    summary text,
    status text DEFAULT 'active'::text,
    initial_context jsonb DEFAULT '{}'::jsonb,
    message_count integer DEFAULT 0,
    total_tokens integer DEFAULT 0,
    total_cost_usd numeric(10,6) DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    last_message_at timestamp with time zone,
    metadata jsonb DEFAULT '{}'::jsonb,
    CONSTRAINT conversation_threads_status_check CHECK ((status = ANY (ARRAY['active'::text, 'archived'::text, 'deleted'::text])))
);


--
-- Name: conversations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.conversations (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    source public.conversation_source NOT NULL,
    external_id text,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    ended_at timestamp with time zone,
    participants text[] DEFAULT '{}'::text[],
    intent_tags text[] DEFAULT '{}'::text[],
    title text,
    summary text,
    org public.org_type,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    embedding public.vector(384),
    retrieval_count integer DEFAULT 0,
    last_retrieved_at timestamp with time zone
);


--
-- Name: conversations_ranked; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.conversations_ranked AS
 SELECT id,
    source,
    external_id,
    started_at,
    ended_at,
    participants,
    intent_tags,
    title,
    summary,
    org,
    metadata,
    created_at,
    updated_at,
    embedding,
    retrieval_count,
    last_retrieved_at,
        CASE
            WHEN (retrieval_count > 5) THEN 'hot'::text
            WHEN (retrieval_count > 0) THEN 'warm'::text
            ELSE 'cold'::text
        END AS tier,
    (EXTRACT(epoch FROM (now() - created_at)) / 86400.0) AS days_old
   FROM public.conversations c;


--
-- Name: council_presets; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.council_presets (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    gate_type text NOT NULL,
    council_models jsonb DEFAULT '[]'::jsonb NOT NULL,
    chairman_model text NOT NULL,
    chairman_system_prompt text,
    evaluation_criteria jsonb DEFAULT '{}'::jsonb,
    context_injection jsonb DEFAULT '{}'::jsonb,
    model_params jsonb DEFAULT '{}'::jsonb,
    max_parallel integer DEFAULT 4,
    timeout_seconds integer DEFAULT 120,
    enabled boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT council_presets_gate_type_check CHECK ((gate_type = ANY (ARRAY['plan'::text, 'review'::text, 'custom'::text])))
);


--
-- Name: decision_gates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.decision_gates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    trigger_type text NOT NULL,
    conditions jsonb DEFAULT '{}'::jsonb,
    requires_approval boolean DEFAULT true,
    auto_approve_after_minutes integer,
    notify_channels text[],
    default_assignee text,
    escalation_path text[],
    active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT decision_gates_trigger_type_check CHECK ((trigger_type = ANY (ARRAY['work_order_create'::text, 'work_order_execute'::text, 'state_mutation'::text, 'cost_threshold'::text, 'risk_level'::text, 'scope_change'::text, 'external_api'::text])))
);


--
-- Name: TABLE decision_gates; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.decision_gates IS 'Defines what actions require human approval vs auto-execute';


--
-- Name: system_directives; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.system_directives (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    scope text DEFAULT 'global'::text,
    thread_id uuid,
    directive_type text NOT NULL,
    name text NOT NULL,
    content text NOT NULL,
    enforcement text DEFAULT 'hard'::text,
    violation_message text,
    priority integer DEFAULT 100,
    active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by text,
    enforcement_mode text DEFAULT 'context_only'::text,
    check_key text,
    context_filter text DEFAULT 'all'::text,
    applicable_tags text[] DEFAULT ARRAY['general'::text],
    CONSTRAINT system_directives_context_filter_check CHECK ((context_filter = ANY (ARRAY['all'::text, 'portal_only'::text, 'executor_only'::text]))),
    CONSTRAINT system_directives_directive_type_check CHECK ((directive_type = ANY (ARRAY['constraint'::text, 'rule'::text, 'context'::text, 'persona'::text, 'tool_policy'::text]))),
    CONSTRAINT system_directives_enforcement_check CHECK ((enforcement = ANY (ARRAY['hard'::text, 'soft'::text, 'log_only'::text]))),
    CONSTRAINT system_directives_enforcement_mode_check CHECK ((enforcement_mode = ANY (ARRAY['context_only'::text, 'pre_check'::text, 'gate_check'::text, 'post_check'::text, 'db_constraint'::text]))),
    CONSTRAINT system_directives_scope_check CHECK ((scope = ANY (ARRAY['global'::text, 'project'::text, 'thread'::text])))
);


--
-- Name: COLUMN system_directives.context_filter; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.system_directives.context_filter IS 'Filters directives by execution context: all (default, loads everywhere), portal_only (portal-chat only), executor_only (work-order-executor and agents only)';


--
-- Name: directive_enforcement_status; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.directive_enforcement_status AS
 SELECT name,
    directive_type,
    enforcement,
    enforcement_mode,
    check_key,
    active,
        CASE
            WHEN (enforcement_mode = 'context_only'::text) THEN '❌ LLM context only'::text
            WHEN (check_key IS NOT NULL) THEN (((('✅ '::text || enforcement_mode) || ' ('::text) || check_key) || ')'::text)
            ELSE '⚠️ Mode set but no check_key'::text
        END AS enforcement_status
   FROM public.system_directives
  WHERE (active = true)
  ORDER BY enforcement_mode, name;


--
-- Name: directive_versions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.directive_versions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    directive_id uuid NOT NULL,
    version_number integer DEFAULT 1 NOT NULL,
    previous_content text,
    new_content text,
    previous_enforcement text,
    new_enforcement text,
    change_reason text,
    changed_by text DEFAULT 'system'::text NOT NULL,
    lesson_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: directives; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.directives AS
 SELECT id,
    project_id,
    scope,
    thread_id,
    directive_type,
    name,
    content,
    enforcement,
    violation_message,
    priority,
    active,
    created_at,
    updated_at,
    created_by,
    enforcement_mode,
    check_key
   FROM public.system_directives;


--
-- Name: edge_function_tool_registry; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.edge_function_tool_registry (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    function_slug text NOT NULL,
    function_name text NOT NULL,
    defer_loading boolean DEFAULT true NOT NULL,
    always_load_reason text,
    usage_frequency text,
    avg_calls_per_day numeric DEFAULT 0,
    last_called_at timestamp with time zone,
    tool_definition_size_bytes integer,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT edge_function_tool_registry_usage_frequency_check CHECK ((usage_frequency = ANY (ARRAY['high'::text, 'medium'::text, 'low'::text, 'rare'::text])))
);


--
-- Name: TABLE edge_function_tool_registry; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.edge_function_tool_registry IS 'Registry tracking which Edge Function tools are always-loaded vs deferred for token optimization (WO-0103)';


--
-- Name: enforcer_canary; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.enforcer_canary (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    canary_type text NOT NULL,
    expected_rejection boolean DEFAULT true NOT NULL,
    was_rejected boolean,
    test_payload jsonb,
    test_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE enforcer_canary; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.enforcer_canary IS 'Canary tests to verify enforcement triggers are working';


--
-- Name: enforcer_findings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.enforcer_findings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    enforcer_run_id uuid NOT NULL,
    work_order_id text,
    finding_type text NOT NULL,
    severity text NOT NULL,
    status text NOT NULL,
    description text NOT NULL,
    evidence jsonb DEFAULT '{}'::jsonb NOT NULL,
    remediation_wo_id text,
    verified_at timestamp with time zone,
    verified_by text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT enforcer_findings_finding_type_check CHECK ((finding_type = ANY (ARRAY['schema_drift'::text, 'audit_discrepancy'::text, 'deployment_mismatch'::text, 'canary_failure'::text, 'state_transition_violation'::text, 'missing_audit_entry'::text, 'orphaned_mutation'::text, 'version_mismatch'::text, 'rls_violation'::text]))),
    CONSTRAINT enforcer_findings_severity_check CHECK ((severity = ANY (ARRAY['critical'::text, 'high'::text, 'medium'::text, 'low'::text, 'info'::text]))),
    CONSTRAINT enforcer_findings_status_check CHECK ((status = ANY (ARRAY['open'::text, 'investigating'::text, 'remediated'::text, 'false_positive'::text])))
);


--
-- Name: TABLE enforcer_findings; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.enforcer_findings IS 'Stores independent verification findings - write access restricted to enforcer role only';


--
-- Name: enforcer_runs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.enforcer_runs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    run_timestamp timestamp with time zone DEFAULT now() NOT NULL,
    trigger_type text NOT NULL,
    trigger_event text,
    status text NOT NULL,
    findings_count integer DEFAULT 0,
    critical_findings_count integer DEFAULT 0,
    execution_duration_ms integer,
    error_message text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    trigger_wo_id uuid,
    run_type text DEFAULT 'manual'::text NOT NULL,
    completed_at timestamp with time zone,
    summary jsonb,
    CONSTRAINT enforcer_runs_status_check CHECK ((status = ANY (ARRAY['running'::text, 'completed'::text, 'failed'::text]))),
    CONSTRAINT enforcer_runs_trigger_type_check CHECK ((trigger_type = ANY (ARRAY['scheduled'::text, 'event_driven'::text, 'manual'::text])))
);


--
-- Name: TABLE enforcer_runs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.enforcer_runs IS 'Tracks audit enforcer execution runs';


--
-- Name: COLUMN enforcer_runs.trigger_wo_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.enforcer_runs.trigger_wo_id IS 'Work order that triggered this enforcer run, if any';


--
-- Name: COLUMN enforcer_runs.run_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.enforcer_runs.run_type IS 'Type of run: manual, scheduled, triggered';


--
-- Name: COLUMN enforcer_runs.completed_at; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.enforcer_runs.completed_at IS 'When the enforcer run completed';


--
-- Name: COLUMN enforcer_runs.summary; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.enforcer_runs.summary IS 'Summary of checks performed (total, passed, failed, critical)';


--
-- Name: entities; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.entities (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    type public.entity_type NOT NULL,
    name text NOT NULL,
    aliases text[] DEFAULT '{}'::text[],
    properties jsonb DEFAULT '{}'::jsonb,
    org public.org_type,
    source_conversation_id uuid,
    confidence double precision DEFAULT 1.0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT entities_confidence_check CHECK (((confidence >= (0)::double precision) AND (confidence <= (1)::double precision)))
);


--
-- Name: error_definitions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.error_definitions (
    code text NOT NULL,
    message_template text NOT NULL,
    severity public.error_severity DEFAULT 'error'::public.error_severity NOT NULL,
    category public.error_category NOT NULL,
    suggested_action text,
    retry_allowed boolean DEFAULT false NOT NULL,
    retry_delay_seconds integer,
    documentation_url text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE error_definitions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.error_definitions IS 'WO-0006: Structured error taxonomy for consistent error handling across the system';


--
-- Name: COLUMN error_definitions.code; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.error_definitions.code IS 'Human-readable error code (e.g., ERR_AC_MISSING)';


--
-- Name: COLUMN error_definitions.message_template; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.error_definitions.message_template IS 'Error message template with {placeholder} support';


--
-- Name: COLUMN error_definitions.retry_allowed; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.error_definitions.retry_allowed IS 'Whether this error type supports retry operations';


--
-- Name: error_events; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.error_events (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    severity text NOT NULL,
    source_function text NOT NULL,
    error_code text,
    message text NOT NULL,
    context jsonb DEFAULT '{}'::jsonb,
    work_order_id uuid,
    agent_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT error_events_severity_check CHECK ((severity = ANY (ARRAY['info'::text, 'warning'::text, 'error'::text, 'critical'::text])))
);


--
-- Name: TABLE error_events; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.error_events IS 'Centralized error tracking for silent failures across RPC calls, edge functions, and other system components';


--
-- Name: COLUMN error_events.severity; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.error_events.severity IS 'Error severity level: info, warning, error, critical';


--
-- Name: COLUMN error_events.source_function; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.error_events.source_function IS 'Function or component that generated the error (e.g., wo-agent, RPC name, edge function name)';


--
-- Name: COLUMN error_events.error_code; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.error_events.error_code IS 'Structured error code for categorization and spike detection';


--
-- Name: COLUMN error_events.context; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.error_events.context IS 'Additional context about the error (stack trace, request params, etc.)';


--
-- Name: error_patterns; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.error_patterns AS
 WITH last_7d AS (
         SELECT wo_mutations.error_class,
            count(*) AS occurrence_count,
            count(DISTINCT wo_mutations.tool_name) AS distinct_tools_affected,
            count(DISTINCT wo_mutations.work_order_id) AS distinct_work_orders,
            mode() WITHIN GROUP (ORDER BY wo_mutations.object_id) AS most_common_object_id
           FROM public.wo_mutations
          WHERE ((wo_mutations.created_at >= (now() - '7 days'::interval)) AND (wo_mutations.error_class IS NOT NULL))
          GROUP BY wo_mutations.error_class
        ), last_24h AS (
         SELECT wo_mutations.error_class,
            count(*) AS trending_24h
           FROM public.wo_mutations
          WHERE ((wo_mutations.created_at >= (now() - '24:00:00'::interval)) AND (wo_mutations.error_class IS NOT NULL))
          GROUP BY wo_mutations.error_class
        )
 SELECT l7.error_class,
    l7.occurrence_count,
    l7.distinct_tools_affected,
    l7.distinct_work_orders,
    l7.most_common_object_id,
    COALESCE(l24.trending_24h, (0)::bigint) AS trending_24h
   FROM (last_7d l7
     LEFT JOIN last_24h l24 ON ((l7.error_class = l24.error_class)))
  ORDER BY l7.occurrence_count DESC;


--
-- Name: error_trends; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.error_trends AS
 SELECT date_trunc('hour'::text, created_at) AS hour,
    source_function,
    severity,
    error_code,
    count(*) AS occurrence_count,
    count(DISTINCT work_order_id) AS affected_wos,
    max(message) AS sample_message
   FROM public.error_events
  WHERE (created_at >= (now() - '24:00:00'::interval))
  GROUP BY (date_trunc('hour'::text, created_at)), source_function, severity, error_code
  ORDER BY (date_trunc('hour'::text, created_at)) DESC, (count(*)) DESC;


--
-- Name: VIEW error_trends; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.error_trends IS 'WO-0266: 24-hour error trends grouped by hour, source, severity, and error code';


--
-- Name: evidence_bundles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.evidence_bundles (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    generated_at timestamp with time zone DEFAULT now() NOT NULL,
    bundle_version text DEFAULT 'v1'::text NOT NULL,
    execution_summary jsonb DEFAULT '{}'::jsonb NOT NULL,
    qa_results jsonb DEFAULT '{}'::jsonb NOT NULL,
    verification_log jsonb DEFAULT '[]'::jsonb NOT NULL,
    enforcer_result jsonb DEFAULT '{}'::jsonb NOT NULL,
    cost_metrics jsonb DEFAULT '{}'::jsonb NOT NULL,
    tool_calls jsonb DEFAULT '[]'::jsonb NOT NULL,
    code_changes jsonb DEFAULT '[]'::jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE evidence_bundles; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.evidence_bundles IS 'Auto-assembled execution artifacts for completed work orders - the core sellable proof-of-work bundle';


--
-- Name: COLUMN evidence_bundles.execution_summary; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.evidence_bundles.execution_summary IS 'Execution duration, phases, agent info - {duration_seconds, started_at, completed_at, agent_name, phases, total_log_entries}';


--
-- Name: COLUMN evidence_bundles.qa_results; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.evidence_bundles.qa_results IS 'QA checklist status and findings - {checklist_complete, total_items, passed, failed, na, findings}';


--
-- Name: COLUMN evidence_bundles.verification_log; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.evidence_bundles.verification_log IS 'Manual and automated verification steps - [{timestamp, verification_type, passed, evidence}]';


--
-- Name: COLUMN evidence_bundles.enforcer_result; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.evidence_bundles.enforcer_result IS 'Enforcer validation results - {verified, verified_at, run_id, findings}';


--
-- Name: COLUMN evidence_bundles.cost_metrics; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.evidence_bundles.cost_metrics IS 'Token usage and cost data - {total_tokens, total_cost_usd, model_usage}';


--
-- Name: COLUMN evidence_bundles.tool_calls; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.evidence_bundles.tool_calls IS 'Trace of all tool executions - [{timestamp, tool_name, parameters, success, result_summary}]';


--
-- Name: COLUMN evidence_bundles.code_changes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.evidence_bundles.code_changes IS 'Database and code modifications - [{type, name, description, sql_summary}]';


--
-- Name: facts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.facts (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    category public.fact_category NOT NULL,
    subject_entity_id uuid,
    subject_text text,
    predicate text NOT NULL,
    object_text text NOT NULL,
    object_entity_id uuid,
    confidence double precision DEFAULT 1.0,
    valid_from timestamp with time zone DEFAULT now(),
    valid_until timestamp with time zone,
    source_conversation_id uuid,
    source_message_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT facts_check CHECK (((subject_entity_id IS NOT NULL) OR (subject_text IS NOT NULL))),
    CONSTRAINT facts_confidence_check CHECK (((confidence >= (0)::double precision) AND (confidence <= (1)::double precision)))
);


--
-- Name: implementations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.implementations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    branch_name text,
    commit_shas text[] DEFAULT '{}'::text[],
    pr_url text,
    status public.implementation_status DEFAULT 'started'::public.implementation_status NOT NULL,
    iterations integer DEFAULT 0,
    test_results jsonb,
    deployment_url text,
    approach_taken text,
    blockers_encountered text[] DEFAULT '{}'::text[],
    escalation_reason text,
    notion_page_id text,
    notion_synced_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deployed_at timestamp with time zone
);


--
-- Name: intake_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.intake_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    source text DEFAULT 'unknown'::text NOT NULL,
    title text,
    description text,
    urgency text DEFAULT 'normal'::text,
    requester text,
    classification text NOT NULL,
    routed_to text NOT NULL,
    work_order_id uuid,
    work_order_slug text,
    response text,
    client_info jsonb DEFAULT '{}'::jsonb,
    error text,
    latency_ms integer,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT intake_log_classification_check CHECK ((classification = ANY (ARRAY['question'::text, 'build'::text, 'research'::text, 'admin'::text])))
);


--
-- Name: TABLE intake_log; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.intake_log IS 'Audit trail for all requests through the METIS intake API';


--
-- Name: interaction_definitions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.interaction_definitions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    source_type text NOT NULL,
    target_type text NOT NULL,
    interaction_name text NOT NULL,
    preconditions jsonb DEFAULT '[]'::jsonb NOT NULL,
    postconditions jsonb DEFAULT '[]'::jsonb NOT NULL,
    failure_behavior text DEFAULT 'log'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT interaction_definitions_failure_behavior_check CHECK ((failure_behavior = ANY (ARRAY['block'::text, 'warn'::text, 'log'::text])))
);


--
-- Name: TABLE interaction_definitions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.interaction_definitions IS 'Registry of valid interactions between system objects (WO-agent, agent-tool, WO-trigger, tool-mutation) with preconditions and postconditions';


--
-- Name: COLUMN interaction_definitions.source_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.interaction_definitions.source_type IS 'Type of the source object (e.g., agent, wo, trigger)';


--
-- Name: COLUMN interaction_definitions.target_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.interaction_definitions.target_type IS 'Type of the target object (e.g., tool, agent, wo)';


--
-- Name: COLUMN interaction_definitions.interaction_name; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.interaction_definitions.interaction_name IS 'Unique name identifying this interaction type';


--
-- Name: COLUMN interaction_definitions.preconditions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.interaction_definitions.preconditions IS 'JSON array of precondition names that must be satisfied';


--
-- Name: COLUMN interaction_definitions.postconditions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.interaction_definitions.postconditions IS 'JSON array of postcondition names that should be guaranteed after execution';


--
-- Name: COLUMN interaction_definitions.failure_behavior; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.interaction_definitions.failure_behavior IS 'What to do when interaction fails: block, warn, or log';


--
-- Name: interface_implementations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.interface_implementations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    interface_id uuid NOT NULL,
    object_id uuid NOT NULL,
    compliance_status text DEFAULT 'pending'::text NOT NULL,
    last_checked_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: interrogation_sessions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.interrogation_sessions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    thread_id uuid,
    work_order_id uuid,
    trigger_type text NOT NULL,
    status text DEFAULT 'in_progress'::text,
    questions_asked jsonb DEFAULT '[]'::jsonb,
    answers_received jsonb DEFAULT '{}'::jsonb,
    domains_completed text[] DEFAULT '{}'::text[],
    summary text,
    generated_docs jsonb DEFAULT '{}'::jsonb,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    completed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT interrogation_sessions_status_check CHECK ((status = ANY (ARRAY['in_progress'::text, 'completed'::text, 'abandoned'::text, 'superseded'::text]))),
    CONSTRAINT interrogation_sessions_trigger_type_check CHECK ((trigger_type = ANY (ARRAY['new_project'::text, 'user_command'::text, 'complex_wo'::text, 'manual'::text, 'auto_intake_gate'::text])))
);


--
-- Name: kernel_spec; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.kernel_spec (
    id integer NOT NULL,
    version text NOT NULL,
    spec jsonb NOT NULL,
    spec_hash text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    created_by text NOT NULL
);


--
-- Name: kernel_spec_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.kernel_spec_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: kernel_spec_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.kernel_spec_id_seq OWNED BY public.kernel_spec.id;


--
-- Name: langfuse_traces; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.langfuse_traces (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    trace_id text NOT NULL,
    thread_id uuid,
    session_id text,
    user_id text,
    name text,
    input jsonb,
    output jsonb,
    metadata jsonb,
    tags text[],
    total_cost_usd numeric(10,6),
    total_tokens integer,
    latency_ms integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: lesson_acknowledgments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.lesson_acknowledgments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    lesson_id uuid NOT NULL,
    decision text NOT NULL,
    rationale text,
    acknowledged_by text NOT NULL,
    acknowledged_at timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT lesson_acknowledgments_decision_check CHECK ((decision = ANY (ARRAY['accepted'::text, 'deferred'::text, 'rejected'::text])))
);


--
-- Name: TABLE lesson_acknowledgments; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.lesson_acknowledgments IS 'Tracks acknowledgment of lessons during WO intake process';


--
-- Name: COLUMN lesson_acknowledgments.decision; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.lesson_acknowledgments.decision IS 'accepted=will apply, deferred=for later, rejected=not applicable';


--
-- Name: lessons; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.lessons (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    occurred_at timestamp with time zone DEFAULT now() NOT NULL,
    pattern text NOT NULL,
    context text,
    rule text NOT NULL,
    example_bad text,
    example_good text,
    severity text DEFAULT 'warning'::text,
    category text,
    thread_id uuid,
    work_order_id uuid,
    trace_id text,
    reported_by text DEFAULT 'user'::text,
    applied_to_directives boolean DEFAULT false,
    directive_id uuid,
    promoted_at timestamp with time zone,
    promoted_by text,
    reviewed boolean DEFAULT false,
    reviewed_at timestamp with time zone,
    reviewed_by text,
    review_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now(),
    review_status text DEFAULT 'pending'::text,
    CONSTRAINT lessons_category_check CHECK ((category = ANY (ARRAY['hallucination'::text, 'scope_creep'::text, 'tool_misuse'::text, 'format_violation'::text, 'context_loss'::text, 'incorrect_assumption'::text, 'security'::text, 'performance'::text, 'other'::text, 'state_machine'::text, 'authorization'::text, 'approval_flow'::text, 'execution'::text, 'general'::text, 'intake_gate'::text]))),
    CONSTRAINT lessons_review_status_check CHECK ((review_status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text, 'auto_promoted'::text]))),
    CONSTRAINT lessons_severity_check CHECK ((severity = ANY (ARRAY['info'::text, 'warning'::text, 'error'::text, 'critical'::text])))
);


--
-- Name: lesson_acknowledgment_dashboard; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.lesson_acknowledgment_dashboard AS
 WITH total_unapplied AS (
         SELECT count(*) AS count
           FROM public.lessons
          WHERE ((lessons.applied_to_directives = false) OR (lessons.applied_to_directives IS NULL))
        ), acknowledged_stats AS (
         SELECT count(DISTINCT la.lesson_id) AS unique_lessons_acknowledged,
            count(*) AS total_acknowledgments,
            count(*) FILTER (WHERE (la.decision = 'accepted'::text)) AS accepted_count,
            count(*) FILTER (WHERE (la.decision = 'deferred'::text)) AS deferred_count,
            count(*) FILTER (WHERE (la.decision = 'rejected'::text)) AS rejected_count,
            count(DISTINCT la.work_order_id) AS work_orders_with_acks,
            min(la.acknowledged_at) AS first_ack_date,
            max(la.acknowledged_at) AS latest_ack_date
           FROM public.lesson_acknowledgments la
        ), recent_acks AS (
         SELECT la.acknowledged_at,
            la.decision,
            wo.slug AS work_order_slug,
            wo.name AS work_order_name,
            l.pattern AS lesson_pattern,
            l.severity,
            la.rationale
           FROM ((public.lesson_acknowledgments la
             JOIN public.work_orders wo ON ((wo.id = la.work_order_id)))
             JOIN public.lessons l ON ((l.id = la.lesson_id)))
          ORDER BY la.acknowledged_at DESC
         LIMIT 10
        ), weekly_trend AS (
         SELECT date_trunc('week'::text, la.acknowledged_at) AS week_start,
            count(*) AS acks_that_week,
            count(*) FILTER (WHERE (la.decision = 'accepted'::text)) AS accepted_that_week
           FROM public.lesson_acknowledgments la
          WHERE (la.acknowledged_at >= (now() - '28 days'::interval))
          GROUP BY (date_trunc('week'::text, la.acknowledged_at))
          ORDER BY (date_trunc('week'::text, la.acknowledged_at)) DESC
        )
 SELECT tu.count AS total_unapplied_lessons,
    COALESCE(ast.unique_lessons_acknowledged, (0)::bigint) AS unique_lessons_acknowledged,
    COALESCE(ast.total_acknowledgments, (0)::bigint) AS total_acknowledgments,
        CASE
            WHEN (tu.count > 0) THEN round(((100.0 * (COALESCE(ast.unique_lessons_acknowledged, (0)::bigint))::numeric) / (tu.count)::numeric), 1)
            ELSE (0)::numeric
        END AS acknowledgment_rate_pct,
    COALESCE(ast.accepted_count, (0)::bigint) AS accepted_count,
    COALESCE(ast.deferred_count, (0)::bigint) AS deferred_count,
    COALESCE(ast.rejected_count, (0)::bigint) AS rejected_count,
    COALESCE(ast.work_orders_with_acks, (0)::bigint) AS work_orders_with_acknowledgments,
    ast.first_ack_date,
    ast.latest_ack_date,
    ( SELECT jsonb_agg(jsonb_build_object('date', recent_acks.acknowledged_at, 'decision', recent_acks.decision, 'wo_slug', recent_acks.work_order_slug, 'wo_name', recent_acks.work_order_name, 'lesson', recent_acks.lesson_pattern, 'severity', recent_acks.severity, 'rationale', recent_acks.rationale) ORDER BY recent_acks.acknowledged_at DESC) AS jsonb_agg
           FROM recent_acks) AS recent_acknowledgments,
    ( SELECT jsonb_agg(jsonb_build_object('week', weekly_trend.week_start, 'total_acks', weekly_trend.acks_that_week, 'accepted', weekly_trend.accepted_that_week) ORDER BY weekly_trend.week_start DESC) AS jsonb_agg
           FROM weekly_trend) AS weekly_trend,
        CASE
            WHEN ((tu.count > 0) AND (((COALESCE(ast.unique_lessons_acknowledged, (0)::bigint))::double precision / (tu.count)::double precision) >= (0.5)::double precision)) THEN 'GOAL MET: ≥50% acknowledgment rate'::text
            ELSE 'IN PROGRESS: Target 50% in 4 weeks'::text
        END AS goal_status
   FROM (total_unapplied tu
     CROSS JOIN acknowledged_stats ast);


--
-- Name: VIEW lesson_acknowledgment_dashboard; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.lesson_acknowledgment_dashboard IS 'Tracks lesson acknowledgment metrics and progress toward 50% target';


--
-- Name: lesson_application_dashboard; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.lesson_application_dashboard AS
 WITH lesson_stats AS (
         SELECT count(*) AS total_lessons,
            count(*) FILTER (WHERE (lessons.applied_to_directives = true)) AS applied_lessons,
            count(*) FILTER (WHERE (lessons.severity = 'critical'::text)) AS critical_lessons,
            count(*) FILTER (WHERE ((lessons.severity = 'critical'::text) AND (lessons.applied_to_directives = true))) AS critical_applied
           FROM public.lessons
          WHERE (lessons.created_at >= (now() - '28 days'::interval))
        ), ack_stats AS (
         SELECT count(*) AS total_acknowledgments,
            count(*) FILTER (WHERE (lesson_acknowledgments.decision = 'accepted'::text)) AS accepted_count,
            count(*) FILTER (WHERE (lesson_acknowledgments.decision = 'deferred'::text)) AS deferred_count,
            count(*) FILTER (WHERE (lesson_acknowledgments.decision = 'rejected'::text)) AS rejected_count,
            count(DISTINCT lesson_acknowledgments.work_order_id) AS wos_with_acks
           FROM public.lesson_acknowledgments
          WHERE (lesson_acknowledgments.created_at >= (now() - '28 days'::interval))
        ), weekly_trend AS (
         SELECT date_trunc('week'::text, la.created_at) AS week,
            count(*) AS acks_count,
            count(*) FILTER (WHERE (la.decision = 'accepted'::text)) AS accepted
           FROM public.lesson_acknowledgments la
          WHERE (la.created_at >= (now() - '28 days'::interval))
          GROUP BY (date_trunc('week'::text, la.created_at))
          ORDER BY (date_trunc('week'::text, la.created_at)) DESC
        )
 SELECT ls.total_lessons,
    ls.applied_lessons,
    round(((100.0 * (ls.applied_lessons)::numeric) / (NULLIF(ls.total_lessons, 0))::numeric), 1) AS application_rate_pct,
    ls.critical_lessons,
    ls.critical_applied,
    round(((100.0 * (ls.critical_applied)::numeric) / (NULLIF(ls.critical_lessons, 0))::numeric), 1) AS critical_application_rate_pct,
    ast.total_acknowledgments,
    ast.accepted_count,
    ast.deferred_count,
    ast.rejected_count,
    ast.wos_with_acks,
    ( SELECT jsonb_agg(jsonb_build_object('week', weekly_trend.week, 'acks', weekly_trend.acks_count, 'accepted', weekly_trend.accepted)) AS jsonb_agg
           FROM weekly_trend) AS weekly_trend,
        CASE
            WHEN (round(((100.0 * (ls.applied_lessons)::numeric) / (NULLIF(ls.total_lessons, 0))::numeric), 1) >= (50)::numeric) THEN 'TARGET_MET'::text
            WHEN (round(((100.0 * (ls.applied_lessons)::numeric) / (NULLIF(ls.total_lessons, 0))::numeric), 1) >= (30)::numeric) THEN 'ON_TRACK'::text
            ELSE 'BELOW_TARGET'::text
        END AS target_status
   FROM (lesson_stats ls
     CROSS JOIN ack_stats ast);


--
-- Name: VIEW lesson_application_dashboard; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.lesson_application_dashboard IS 'AC5: Dashboard for tracking lesson application rates and acknowledgment activity over 4-week windows';


--
-- Name: llm_provider_config; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.llm_provider_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    model_id text NOT NULL,
    display_name text NOT NULL,
    is_default boolean DEFAULT false,
    is_active boolean DEFAULT true,
    input_cost_per_m numeric NOT NULL,
    output_cost_per_m numeric NOT NULL,
    max_context_tokens integer,
    notes text,
    role_hint text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: llm_usage; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.llm_usage (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid,
    agent_id uuid,
    model_id text NOT NULL,
    input_tokens integer DEFAULT 0,
    output_tokens integer DEFAULT 0,
    input_cost_per_m numeric,
    output_cost_per_m numeric,
    estimated_cost numeric GENERATED ALWAYS AS (((((input_tokens)::numeric / (1000000)::numeric) * input_cost_per_m) + (((output_tokens)::numeric / (1000000)::numeric) * output_cost_per_m))) STORED,
    latency_ms integer,
    success boolean DEFAULT true,
    error_message text,
    openrouter_id text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: manifest_comparison_summary; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.manifest_comparison_summary AS
 WITH comp_results AS (
         SELECT wo.id AS work_order_id,
            wo.name AS work_order_name,
            wo.status,
            wo.updated_at,
            public.compare_manifest_to_mutations(wo.id) AS comparison
           FROM public.work_orders wo
          WHERE (wo.status = ANY (ARRAY['review'::public.work_order_status, 'done'::public.work_order_status, 'failed'::public.work_order_status]))
        )
 SELECT work_order_id,
    work_order_name,
    status,
    (comparison ->> 'verdict'::text) AS verdict,
    ((comparison ->> 'match_confidence'::text))::numeric AS match_confidence,
    ((comparison ->> 'matched'::text))::jsonb AS matched_details,
    ((comparison ->> 'missing'::text))::jsonb AS missing_details,
    ((comparison ->> 'failed'::text))::jsonb AS failed_details,
    ((comparison ->> 'discovered'::text))::jsonb AS discovered_details,
    jsonb_array_length(((comparison ->> 'matched'::text))::jsonb) AS matched_count,
    jsonb_array_length(((comparison ->> 'missing'::text))::jsonb) AS missing_count,
    jsonb_array_length(((comparison ->> 'failed'::text))::jsonb) AS failed_count,
    jsonb_array_length(((comparison ->> 'discovered'::text))::jsonb) AS discovered_count,
    updated_at
   FROM comp_results;


--
-- Name: wo_execution_manifest; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wo_execution_manifest (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    ac_number integer NOT NULL,
    step_order integer NOT NULL,
    expected_tool text NOT NULL,
    expected_action text NOT NULL,
    expected_object_type text NOT NULL,
    expected_object_id text NOT NULL,
    required boolean DEFAULT true NOT NULL,
    alternatives jsonb,
    discovered boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    build_plan jsonb,
    CONSTRAINT check_expected_action CHECK ((expected_action = ANY (ARRAY['read'::text, 'write'::text, 'verify'::text, 'delete'::text]))),
    CONSTRAINT check_expected_object_type CHECK ((expected_object_type = ANY (ARRAY['table'::text, 'function'::text, 'file'::text, 'rpc'::text, 'trigger'::text, 'view'::text, 'index'::text, 'policy'::text])))
);


--
-- Name: manifest_step_summary; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.manifest_step_summary AS
 SELECT work_order_id,
    expected_action,
    count(*) AS total_steps,
    count(*) FILTER (WHERE required) AS required_steps,
    count(*) FILTER (WHERE discovered) AS discovered_steps
   FROM public.wo_execution_manifest
  GROUP BY work_order_id, expected_action;


--
-- Name: metis_capabilities; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.metis_capabilities (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    capability_type text NOT NULL,
    name text NOT NULL,
    version integer DEFAULT 1,
    status text DEFAULT 'active'::text,
    implementation jsonb DEFAULT '{}'::jsonb,
    dependencies text[] DEFAULT '{}'::text[],
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT metis_capabilities_capability_type_check CHECK ((capability_type = ANY (ARRAY['tool'::text, 'reasoning'::text, 'domain'::text, 'integration'::text]))),
    CONSTRAINT metis_capabilities_status_check CHECK ((status = ANY (ARRAY['active'::text, 'deprecated'::text, 'experimental'::text])))
);


--
-- Name: TABLE metis_capabilities; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.metis_capabilities IS 'Self-awareness registry. Tracks what Metis can do, enabling capability introspection and evolution tracking.';


--
-- Name: model_capabilities; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.model_capabilities (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    model_id text NOT NULL,
    provider text NOT NULL,
    display_name text,
    arena_elo integer,
    gpqa_diamond double precision,
    swe_bench_verified double precision,
    helm_safety double precision,
    mmlu_pro double precision,
    humanitys_last_exam double precision,
    supports_tools boolean DEFAULT false,
    supports_vision boolean DEFAULT false,
    supports_code_execution boolean DEFAULT false,
    max_context_tokens integer,
    max_output_tokens integer,
    rank_code integer,
    rank_reasoning integer,
    rank_creative integer,
    rank_safety integer,
    rank_speed integer,
    is_available boolean DEFAULT true,
    deprecated_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    source_urls text[],
    math_aime numeric(5,2),
    math_gsm8k numeric(5,2),
    ifeval numeric(5,2),
    multilingual_mgsm numeric(5,2),
    long_context_ruler numeric(5,2),
    tau_bench_retail numeric(5,2),
    tau_bench_airline numeric(5,2),
    vision_mmmu numeric(5,2),
    medqa numeric(5,2),
    legalbench numeric(5,2),
    finqa numeric(5,2),
    rank_math integer,
    rank_multilingual integer,
    rank_agentic integer,
    rank_vision integer,
    rank_long_context integer,
    CONSTRAINT valid_provider CHECK ((provider = ANY (ARRAY['anthropic'::text, 'openai'::text, 'google'::text, 'meta'::text, 'mistral'::text, 'xai'::text, 'deepseek'::text])))
);


--
-- Name: model_pricing; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.model_pricing (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    model_id text NOT NULL,
    input_price_per_m numeric(10,4) NOT NULL,
    output_price_per_m numeric(10,4) NOT NULL,
    cached_input_price_per_m numeric(10,4),
    batch_input_price_per_m numeric(10,4),
    batch_output_price_per_m numeric(10,4),
    effective_date date DEFAULT CURRENT_DATE NOT NULL,
    source_url text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: monitor_triage_queue; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.monitor_triage_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    wo_id uuid NOT NULL,
    triage_type text NOT NULL,
    severity text NOT NULL,
    diagnostic_context jsonb DEFAULT '{}'::jsonb NOT NULL,
    escalate_to text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    resolved_at timestamp with time zone,
    resolved_by text,
    related_lessons jsonb DEFAULT '[]'::jsonb,
    resolution_notes text,
    CONSTRAINT monitor_triage_severity_check CHECK ((severity = ANY (ARRAY['critical'::text, 'high'::text, 'medium'::text, 'low'::text, 'info'::text]))),
    CONSTRAINT monitor_triage_type_check CHECK ((triage_type = ANY (ARRAY['stuck'::text, 'orphan'::text, 'mismatch'::text, 'spiral'::text, 'correlation'::text, 'dependency_blocked'::text, 'retry_exhausted'::text, 'health_check_stale'::text])))
);


--
-- Name: TABLE monitor_triage_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.monitor_triage_queue IS 'WO-0381: Structured triage queue for sentinel detections requiring action or escalation';


--
-- Name: COLUMN monitor_triage_queue.related_lessons; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.monitor_triage_queue.related_lessons IS 'Array of lesson objects matched during triage. Each object contains {id, pattern, rule, severity, category}';


--
-- Name: COLUMN monitor_triage_queue.resolution_notes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.monitor_triage_queue.resolution_notes IS 'Notes about how the triage item was resolved (e.g., RCA complete, parent WO created)';


--
-- Name: object_action_rates; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.object_action_rates AS
 WITH raw_rates AS (
         SELECT m.object_id AS target_identifier,
            m.tool_name,
            m.action,
            count(*) AS n,
            count(*) FILTER (WHERE m.success) AS k,
            ((count(*) FILTER (WHERE m.success))::numeric / (GREATEST(count(*), (1)::bigint))::numeric) AS p_hat
           FROM public.wo_mutations m
          WHERE ((m.action IS NOT NULL) AND (m.action <> ''::text))
          GROUP BY m.object_id, m.tool_name, m.action
         HAVING (count(*) >= 2)
        )
 SELECT target_identifier,
    tool_name,
    action,
    n AS total_attempts,
    k AS successes,
    round(p_hat, 4) AS success_rate,
    round(
        CASE
            WHEN (n > 0) THEN (((p_hat + (1.9208 / ((2 * n))::numeric)) - (1.96 * sqrt((((p_hat * ((1)::numeric - p_hat)) + (0.9604 / (n)::numeric)) / (n)::numeric)))) / ((1)::numeric + (3.8416 / (n)::numeric)))
            ELSE (0)::numeric
        END, 4) AS wilson_lower,
    round(
        CASE
            WHEN (n > 0) THEN (((p_hat + (1.9208 / ((2 * n))::numeric)) + (1.96 * sqrt((((p_hat * ((1)::numeric - p_hat)) + (0.9604 / (n)::numeric)) / (n)::numeric)))) / ((1)::numeric + (3.8416 / (n)::numeric)))
            ELSE (1)::numeric
        END, 4) AS wilson_upper,
    round(
        CASE
            WHEN (n > 0) THEN ((((2)::numeric * 1.96) * sqrt((((p_hat * ((1)::numeric - p_hat)) + (0.9604 / (n)::numeric)) / (n)::numeric))) / ((1)::numeric + (3.8416 / (n)::numeric)))
            ELSE (1)::numeric
        END, 4) AS ci_width,
    'specific'::text AS rate_tier
   FROM raw_rates
  WITH NO DATA;


--
-- Name: object_links; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.object_links (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    source_id uuid NOT NULL,
    target_id uuid NOT NULL,
    link_type text NOT NULL,
    properties jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT object_links_link_type_check CHECK ((link_type = ANY (ARRAY['fk'::text, 'triggers'::text, 'calls'::text, 'depends_on'::text, 'mutates'::text, 'references'::text, 'typed_by'::text, 'validates'::text, 'guards'::text])))
);


--
-- Name: object_registry; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.object_registry (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    object_type text NOT NULL,
    object_name text NOT NULL,
    parent_id uuid,
    properties jsonb DEFAULT '{}'::jsonb,
    valid_actions text[] DEFAULT '{}'::text[],
    system_manifest_id uuid,
    auto_populated boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT object_registry_object_type_check CHECK ((object_type = ANY (ARRAY['table'::text, 'column'::text, 'function'::text, 'trigger'::text, 'edge_function'::text, 'view'::text, 'index'::text, 'policy'::text, 'enum'::text, 'materialized_view'::text, 'value_type'::text])))
);


--
-- Name: ontology_interfaces; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ontology_interfaces (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    interface_name text NOT NULL,
    required_properties jsonb DEFAULT '{}'::jsonb NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: open_source_tools; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.open_source_tools (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    category text NOT NULL,
    github_url text,
    docs_url text,
    npm_package text,
    github_stars integer,
    description text NOT NULL,
    best_for text,
    relevance_to_metis text,
    relevance_score integer,
    key_features jsonb DEFAULT '[]'::jsonb,
    discovered_at timestamp with time zone DEFAULT now(),
    last_evaluated timestamp with time zone DEFAULT now(),
    notes text,
    CONSTRAINT open_source_tools_category_check CHECK ((category = ANY (ARRAY['orchestration_framework'::text, 'agent_component'::text, 'mcp_infrastructure'::text, 'workflow_automation'::text, 'observability'::text, 'specialized'::text]))),
    CONSTRAINT open_source_tools_relevance_score_check CHECK (((relevance_score >= 1) AND (relevance_score <= 5)))
);


--
-- Name: TABLE open_source_tools; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.open_source_tools IS 'Registry of open source AI agent frameworks and tools tracked as precedent for Metis/Ilmarinen development';


--
-- Name: pending_approvals; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.pending_approvals AS
 SELECT aq.id AS approval_id,
    aq.request_summary,
    aq.request_type,
    aq.requested_by,
    aq.requested_at,
    dg.name AS gate_name,
    dg.default_assignee,
    wo.slug AS work_order_slug,
    wo.priority,
    wo.objective
   FROM ((public.approval_queue aq
     LEFT JOIN public.decision_gates dg ON ((aq.gate_id = dg.id)))
     LEFT JOIN public.work_orders wo ON ((aq.work_order_id = wo.id)))
  WHERE (aq.status = 'pending'::text)
  ORDER BY aq.requested_at DESC;


--
-- Name: pending_migrations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.pending_migrations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid,
    sequence integer NOT NULL,
    slug text NOT NULL,
    name text NOT NULL,
    description text,
    sql_up text NOT NULL,
    sql_down text,
    status text DEFAULT 'pending'::text,
    executed_at timestamp with time zone,
    executed_by text,
    execution_log text,
    error_message text,
    estimated_effort text,
    dependencies text[],
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT pending_migrations_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'in_progress'::text, 'completed'::text, 'failed'::text, 'skipped'::text])))
);


--
-- Name: pipeline_runs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.pipeline_runs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    spec_wo_id uuid,
    current_phase text DEFAULT 'spec'::text NOT NULL,
    phase_history jsonb DEFAULT '[]'::jsonb,
    config jsonb DEFAULT '{}'::jsonb,
    status text DEFAULT 'active'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    target text,
    description text,
    depends_on_pipeline_ids uuid[] DEFAULT '{}'::uuid[],
    slug text DEFAULT "left"(md5((gen_random_uuid())::text), 8),
    display_name text,
    project_id uuid,
    CONSTRAINT pipeline_runs_slug_not_null CHECK ((slug IS NOT NULL)),
    CONSTRAINT pipeline_runs_status_check CHECK ((status = ANY (ARRAY['active'::text, 'completed'::text, 'failed'::text, 'cancelled'::text])))
);


--
-- Name: platform_health_snapshots; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.platform_health_snapshots (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    snapshot_at timestamp with time zone DEFAULT now() NOT NULL,
    wo_total integer DEFAULT 0 NOT NULL,
    wo_done integer DEFAULT 0 NOT NULL,
    wo_cancelled integer DEFAULT 0 NOT NULL,
    wo_cancel_rate_pct numeric(5,2) DEFAULT 0 NOT NULL,
    wo_in_flight integer DEFAULT 0 NOT NULL,
    qa_findings_total integer DEFAULT 0 NOT NULL,
    qa_pass_count integer DEFAULT 0 NOT NULL,
    qa_fail_count integer DEFAULT 0 NOT NULL,
    qa_pass_rate_pct numeric(5,2) DEFAULT 0 NOT NULL,
    verification_total integer DEFAULT 0 NOT NULL,
    verification_passed integer DEFAULT 0 NOT NULL,
    verification_pass_rate_pct numeric(5,2) DEFAULT 0 NOT NULL,
    enforcer_runs_total integer DEFAULT 0 NOT NULL,
    enforcer_findings_total integer DEFAULT 0 NOT NULL,
    enforcer_coverage_pct numeric(5,2) DEFAULT 0 NOT NULL,
    lessons_total integer DEFAULT 0 NOT NULL,
    lessons_applied integer DEFAULT 0 NOT NULL,
    lesson_application_rate_pct numeric(5,2) DEFAULT 0 NOT NULL,
    auto_approval_attempted integer DEFAULT 0 NOT NULL,
    auto_approval_succeeded integer DEFAULT 0 NOT NULL,
    auto_approval_success_rate_pct numeric(5,2) DEFAULT 0 NOT NULL,
    edge_functions_total integer DEFAULT 0 NOT NULL,
    edge_functions_jwt_enabled integer DEFAULT 0 NOT NULL,
    jwt_coverage_pct numeric(5,2) DEFAULT 0 NOT NULL,
    total_tokens_consumed bigint DEFAULT 0 NOT NULL,
    total_cost_usd numeric(10,4) DEFAULT 0 NOT NULL,
    dead_tables_count integer DEFAULT 0 NOT NULL,
    triggered_by text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE platform_health_snapshots; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.platform_health_snapshots IS 'Platform health metrics snapshots. Collected by snapshot-collector edge function using service_role key to bypass RLS on work_orders, qa_findings, and enforcer_findings tables. Triggered daily at 00:00 UTC via pg_cron and on WO done transitions.';


--
-- Name: preferences; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.preferences (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    scope public.preference_scope NOT NULL,
    key text NOT NULL,
    value jsonb NOT NULL,
    priority integer DEFAULT 0,
    org public.org_type,
    source_conversation_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: problematic_files; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.problematic_files AS
 SELECT object_id,
    object_type,
    count(*) AS total_mutations,
    count(*) FILTER (WHERE (success = false)) AS failure_count,
    round((((count(*) FILTER (WHERE (success = false)))::numeric / (NULLIF(count(*), 0))::numeric) * (100)::numeric), 2) AS failure_rate,
    count(DISTINCT error_class) FILTER (WHERE (error_class IS NOT NULL)) AS distinct_error_classes,
    max(created_at) FILTER (WHERE (success = false)) AS last_failure_at
   FROM public.wo_mutations
  WHERE ((created_at >= (now() - '7 days'::interval)) AND (object_type = ANY (ARRAY['file'::text, 'migration'::text, 'table'::text])))
  GROUP BY object_id, object_type
 HAVING (count(*) FILTER (WHERE (success = false)) > 0)
  ORDER BY (count(*) FILTER (WHERE (success = false))) DESC, (round((((count(*) FILTER (WHERE (success = false)))::numeric / (NULLIF(count(*), 0))::numeric) * (100)::numeric), 2)) DESC;


--
-- Name: project_briefs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.project_briefs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    code character varying(50) NOT NULL,
    name character varying(255) NOT NULL,
    status character varying(50) DEFAULT 'active'::character varying,
    summary text,
    scope jsonb,
    architecture text,
    phases jsonb,
    decisions jsonb,
    risks jsonb,
    current_phase integer DEFAULT 1,
    completion_pct integer DEFAULT 0,
    repo_url character varying(500),
    docs_url character varying(500),
    api_url character varying(500),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by character varying(100),
    search_vector tsvector GENERATED ALWAYS AS (((setweight(to_tsvector('english'::regconfig, (COALESCE(name, ''::character varying))::text), 'A'::"char") || setweight(to_tsvector('english'::regconfig, (COALESCE(code, ''::character varying))::text), 'A'::"char")) || setweight(to_tsvector('english'::regconfig, COALESCE(summary, ''::text)), 'B'::"char"))) STORED,
    intake_complete boolean DEFAULT false,
    work_dir character varying,
    CONSTRAINT project_briefs_status_check CHECK (((status)::text = ANY ((ARRAY['planning'::character varying, 'active'::character varying, 'paused'::character varying, 'completed'::character varying, 'archived'::character varying])::text[])))
);


--
-- Name: project_context; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.project_context (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_name text NOT NULL,
    architecture jsonb DEFAULT '{}'::jsonb,
    credentials jsonb DEFAULT '{}'::jsonb,
    decisions jsonb DEFAULT '[]'::jsonb,
    open_items jsonb DEFAULT '{}'::jsonb,
    current_focus text,
    last_session_id text,
    last_session_summary text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: project_documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.project_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid NOT NULL,
    doc_type text NOT NULL,
    title text NOT NULL,
    content text NOT NULL,
    version integer DEFAULT 1 NOT NULL,
    status text DEFAULT 'draft'::text,
    created_by text,
    updated_by text,
    approved_by text,
    approved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now(),
    metadata jsonb DEFAULT '{}'::jsonb,
    CONSTRAINT project_documents_doc_type_check CHECK ((doc_type = ANY (ARRAY['prd'::text, 'app_flow'::text, 'tech_stack'::text, 'frontend_guidelines'::text, 'backend_structure'::text, 'implementation_plan'::text, 'security_model'::text, 'testing_strategy'::text, 'architecture'::text, 'state_machine'::text, 'design_doc'::text]))),
    CONSTRAINT project_documents_status_check CHECK ((status = ANY (ARRAY['draft'::text, 'generated'::text, 'review'::text, 'approved'::text, 'superseded'::text])))
);


--
-- Name: COLUMN project_documents.doc_type; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.project_documents.doc_type IS 'Document type. For design_doc: requires title, content (markdown), status (draft/reviewed/approved)';


--
-- Name: COLUMN project_documents.content; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.project_documents.content IS 'Document content in markdown format. Required for all document types.';


--
-- Name: COLUMN project_documents.status; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.project_documents.status IS 'Document status. For design_doc type: draft, reviewed, or approved. Other types may use different values.';


--
-- Name: COLUMN project_documents.metadata; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.project_documents.metadata IS 'Metadata for document categorization: {doc_category: "auto-generated"|"authored"|"archived", archival_reason: text, archived_at: timestamptz}';


--
-- Name: project_documents_staleness; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.project_documents_staleness AS
 SELECT id,
    project_id,
    doc_type,
    title,
    status,
    created_by,
    updated_by,
    created_at,
    updated_at,
    metadata,
    (EXTRACT(epoch FROM (now() - COALESCE(updated_at, created_at))) / (86400)::numeric) AS staleness_days,
        CASE
            WHEN (COALESCE(updated_at, created_at) > (now() - '7 days'::interval)) THEN 'fresh'::text
            WHEN (COALESCE(updated_at, created_at) > (now() - '30 days'::interval)) THEN 'stale'::text
            ELSE 'very_stale'::text
        END AS staleness_category,
    COALESCE((metadata ->> 'doc_category'::text),
        CASE
            WHEN ((created_by = 'system'::text) OR (updated_by ~~ '%regenerate%'::text)) THEN 'auto-generated'::text
            WHEN ((status = 'archived'::text) OR ((metadata ->> 'doc_category'::text) = 'archived'::text)) THEN 'archived'::text
            ELSE 'authored'::text
        END) AS doc_category
   FROM public.project_documents
  ORDER BY (EXTRACT(epoch FROM (now() - COALESCE(updated_at, created_at))) / (86400)::numeric) DESC;


--
-- Name: VIEW project_documents_staleness; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.project_documents_staleness IS 'Dashboard view showing document staleness metrics with categories (fresh/stale/very_stale) and doc types (auto-generated/authored/archived)';


--
-- Name: projects; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.projects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    code text NOT NULL,
    name text NOT NULL,
    status text DEFAULT 'active'::text,
    summary text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: qa_findings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.qa_findings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid,
    finding_type text NOT NULL,
    category text NOT NULL,
    description text NOT NULL,
    evidence jsonb DEFAULT '{}'::jsonb,
    agent_id uuid,
    reviewed_by uuid,
    resolved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    checklist_item_id text,
    error_code text,
    CONSTRAINT qa_findings_category_check CHECK ((category = ANY (ARRAY['state_consistency'::text, 'acceptance_criteria'::text, 'acceptance_criterion'::text, 'anomaly'::text, 'security'::text, 'completeness'::text, 'execution_log'::text, 'execution_trail'::text, 'completion_summary'::text, 'qa_checklist'::text, 'qa_checklist_item'::text]))),
    CONSTRAINT qa_findings_finding_type_check CHECK ((finding_type = ANY (ARRAY['pass'::text, 'fail'::text, 'warning'::text, 'info'::text, 'na'::text])))
);


--
-- Name: COLUMN qa_findings.checklist_item_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.qa_findings.checklist_item_id IS 'References qa_checklist item ID from work_orders.qa_checklist for findings related to specific checklist items';


--
-- Name: COLUMN qa_findings.error_code; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.qa_findings.error_code IS 'WO-0006: Reference to error_definition for pattern correlation';


--
-- Name: rate_limit_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.rate_limit_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id uuid,
    endpoint text,
    quota_type text,
    allowed boolean NOT NULL,
    current_count integer,
    limit_value integer,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: regression_suite_cron_status; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.regression_suite_cron_status AS
 SELECT jobid,
    schedule,
    command,
    nodename,
    nodeport,
    database,
    username,
    active,
    jobname
   FROM cron.job
  WHERE (jobname = 'nightly-regression-suite'::text);


--
-- Name: VIEW regression_suite_cron_status; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.regression_suite_cron_status IS 'Monitor status of nightly regression suite cron job';


--
-- Name: regression_suite_definitions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.regression_suite_definitions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    suite_name text NOT NULL,
    description text,
    canonical_wo_slug text NOT NULL,
    canonical_wo_id uuid,
    baseline_scorecard_id uuid,
    baseline_score numeric(5,2),
    active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    alert_threshold_pct numeric DEFAULT 10.0
);


--
-- Name: TABLE regression_suite_definitions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.regression_suite_definitions IS 'Canonical work order patterns for regression testing';


--
-- Name: COLUMN regression_suite_definitions.alert_threshold_pct; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.regression_suite_definitions.alert_threshold_pct IS 'Alert when score drops by this percentage from baseline';


--
-- Name: regression_suite_runs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.regression_suite_runs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    suite_definition_id uuid,
    test_wo_id uuid,
    test_scorecard_id uuid,
    test_score numeric(5,2),
    baseline_score numeric(5,2),
    score_delta numeric(5,2),
    score_delta_pct numeric(5,2),
    status text,
    alert_triggered boolean DEFAULT false,
    run_timestamp timestamp with time zone DEFAULT now(),
    execution_details jsonb,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT regression_suite_runs_status_check CHECK ((status = ANY (ARRAY['pass'::text, 'fail'::text, 'error'::text, 'pending'::text])))
);


--
-- Name: TABLE regression_suite_runs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.regression_suite_runs IS 'Track nightly regression test execution results and baseline comparisons';


--
-- Name: request_schemas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.request_schemas (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    endpoint text NOT NULL,
    method text DEFAULT 'POST'::text NOT NULL,
    schema jsonb NOT NULL,
    requires_auth boolean DEFAULT true,
    rate_limit_per_minute integer DEFAULT 60,
    enabled boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: routing_rules; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.routing_rules (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    intent text,
    domain text,
    risk_tier text,
    complexity_min double precision,
    complexity_max double precision,
    target_model text NOT NULL,
    temperature double precision DEFAULT 0.7,
    max_tokens integer,
    priority integer DEFAULT 100 NOT NULL,
    enabled boolean DEFAULT true,
    name text,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT routing_rules_domain_check CHECK (((domain IS NULL) OR (domain = ANY (ARRAY['general'::text, 'legal'::text, 'medical'::text, 'financial'::text, 'technical'::text, 'math'::text, 'science'::text, 'creative'::text, 'code'::text, 'multilingual'::text, 'vision'::text, 'agentic'::text, 'long_context'::text, 'safety_critical'::text])))),
    CONSTRAINT routing_rules_intent_check CHECK (((intent IS NULL) OR (intent = ANY (ARRAY['simple_qa'::text, 'code'::text, 'reasoning'::text, 'research'::text, 'creative'::text, 'tool_use'::text, 'math'::text, 'analysis'::text, 'translation'::text, 'summarization'::text, 'extraction'::text, 'classification'::text, 'agentic'::text, 'vision'::text])))),
    CONSTRAINT valid_domain CHECK (((domain IS NULL) OR (domain = ANY (ARRAY['general'::text, 'legal'::text, 'medical'::text, 'financial'::text, 'technical'::text, 'math'::text, 'science'::text, 'creative'::text, 'code'::text, 'multilingual'::text, 'vision'::text, 'agentic'::text, 'long_context'::text, 'safety_critical'::text])))),
    CONSTRAINT valid_intent CHECK (((intent IS NULL) OR (intent = ANY (ARRAY['simple_qa'::text, 'code'::text, 'reasoning'::text, 'research'::text, 'creative'::text, 'tool_use'::text, 'math'::text, 'analysis'::text, 'translation'::text, 'summarization'::text, 'extraction'::text, 'classification'::text, 'agentic'::text, 'vision'::text])))),
    CONSTRAINT valid_risk CHECK (((risk_tier IS NULL) OR (risk_tier = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text, 'critical'::text]))))
);


--
-- Name: run_scorecards; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.run_scorecards (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    policy_adherence_score integer NOT NULL,
    cost_efficiency_score integer NOT NULL,
    time_efficiency_score integer NOT NULL,
    qa_pass_rate_score integer NOT NULL,
    evidence_completeness_score integer NOT NULL,
    overall_score integer NOT NULL,
    metrics jsonb DEFAULT '{}'::jsonb NOT NULL,
    scoring_details jsonb,
    scored_by text DEFAULT 'system'::text NOT NULL,
    scored_at timestamp with time zone DEFAULT now() NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT run_scorecards_cost_efficiency_score_check CHECK (((cost_efficiency_score >= 0) AND (cost_efficiency_score <= 100))),
    CONSTRAINT run_scorecards_evidence_completeness_score_check CHECK (((evidence_completeness_score >= 0) AND (evidence_completeness_score <= 100))),
    CONSTRAINT run_scorecards_overall_score_check CHECK (((overall_score >= 0) AND (overall_score <= 100))),
    CONSTRAINT run_scorecards_policy_adherence_score_check CHECK (((policy_adherence_score >= 0) AND (policy_adherence_score <= 100))),
    CONSTRAINT run_scorecards_qa_pass_rate_score_check CHECK (((qa_pass_rate_score >= 0) AND (qa_pass_rate_score <= 100))),
    CONSTRAINT run_scorecards_time_efficiency_score_check CHECK (((time_efficiency_score >= 0) AND (time_efficiency_score <= 100)))
);


--
-- Name: TABLE run_scorecards; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.run_scorecards IS 'Per-WO execution quality scorecards with 5 dimensions (0-100) and weighted overall score';


--
-- Name: COLUMN run_scorecards.policy_adherence_score; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.run_scorecards.policy_adherence_score IS 'Score for following harness rules, using RPCs, proper logging (0-100)';


--
-- Name: COLUMN run_scorecards.cost_efficiency_score; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.run_scorecards.cost_efficiency_score IS 'Score based on iterations, mutations, and token usage (0-100)';


--
-- Name: COLUMN run_scorecards.time_efficiency_score; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.run_scorecards.time_efficiency_score IS 'Score based on time from start to completion vs complexity (0-100)';


--
-- Name: COLUMN run_scorecards.qa_pass_rate_score; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.run_scorecards.qa_pass_rate_score IS 'Score based on QA checklist pass rate and findings resolution (0-100)';


--
-- Name: COLUMN run_scorecards.evidence_completeness_score; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.run_scorecards.evidence_completeness_score IS 'Score based on execution log quality and verification evidence (0-100)';


--
-- Name: COLUMN run_scorecards.overall_score; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.run_scorecards.overall_score IS 'Weighted average of all dimension scores (0-100)';


--
-- Name: sandbox_executions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.sandbox_executions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid,
    command text NOT NULL,
    args text[] DEFAULT '{}'::text[],
    exit_code integer,
    stdout text,
    stderr text,
    timed_out boolean DEFAULT false,
    duration_ms integer,
    file_count integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE sandbox_executions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.sandbox_executions IS 'Logs all shell command executions in the Fly.io sandbox for audit and debugging';


--
-- Name: scaffold_contracts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.scaffold_contracts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    pipeline_run_id uuid NOT NULL,
    object_id uuid NOT NULL,
    contract_type text NOT NULL,
    input_schema jsonb,
    output_schema jsonb,
    preconditions jsonb,
    postconditions jsonb,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT scaffold_contracts_contract_type_check CHECK ((contract_type = ANY (ARRAY['input'::text, 'output'::text, 'invariant'::text])))
);


--
-- Name: schema_changes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.schema_changes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    change_type text NOT NULL,
    object_name text NOT NULL,
    object_type text,
    change_sql text,
    work_order_id uuid,
    created_by text DEFAULT 'unknown'::text,
    reason text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT schema_changes_change_type_check CHECK ((change_type = ANY (ARRAY['create_table'::text, 'alter_table'::text, 'drop_table'::text, 'create_function'::text, 'alter_function'::text, 'drop_function'::text, 'create_index'::text, 'drop_index'::text, 'create_trigger'::text, 'drop_trigger'::text, 'other'::text])))
);


--
-- Name: TABLE schema_changes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.schema_changes IS 'DDL audit log. Prevents schema drift by tracking all structural changes.';


--
-- Name: secrets; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.secrets (
    key text NOT NULL,
    value text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: spans; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.spans (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    trace_id text NOT NULL,
    parent_span_id uuid,
    span_id text NOT NULL,
    span_type text NOT NULL,
    name text NOT NULL,
    agent_id uuid,
    agent_name text,
    model text,
    model_parameters jsonb,
    input_tokens integer,
    output_tokens integer,
    cost_usd numeric(10,6),
    input jsonb,
    output jsonb,
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    ended_at timestamp with time zone,
    latency_ms integer GENERATED ALWAYS AS (
CASE
    WHEN (ended_at IS NOT NULL) THEN (EXTRACT(epoch FROM (ended_at - started_at)) * (1000)::numeric)
    ELSE NULL::numeric
END) STORED,
    status text DEFAULT 'running'::text,
    error_message text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT spans_span_type_check CHECK ((span_type = ANY (ARRAY['llm-generation'::text, 'tool-call'::text, 'db-query'::text, 'http-request'::text, 'embedding'::text, 'retrieval'::text, 'agent-step'::text, 'custom'::text]))),
    CONSTRAINT spans_status_check CHECK ((status = ANY (ARRAY['running'::text, 'completed'::text, 'error'::text, 'timeout'::text])))
);


--
-- Name: stale_wo_events; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.stale_wo_events AS
 SELECT id,
    work_order_id,
    event_type,
    status,
    created_at,
    age(now(), created_at) AS age
   FROM public.wo_events
  WHERE ((status = 'pending'::text) AND (created_at < (now() - '00:05:00'::interval)));


--
-- Name: state_mutations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.state_mutations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    mutation_type text NOT NULL,
    target_table text NOT NULL,
    target_id uuid,
    payload jsonb NOT NULL,
    previous_state jsonb,
    work_order_id uuid,
    agent_id uuid,
    session_id text,
    created_at timestamp with time zone DEFAULT now(),
    rolled_back_at timestamp with time zone,
    rollback_mutation_id uuid,
    CONSTRAINT state_mutations_mutation_type_check CHECK ((mutation_type = ANY (ARRAY['INSERT'::text, 'UPDATE'::text, 'DELETE'::text, 'ROLLBACK'::text, 'SNAPSHOT'::text])))
);


--
-- Name: system_manifest; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.system_manifest (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    component_type text NOT NULL,
    name text NOT NULL,
    description text,
    purpose text,
    dependencies text[] DEFAULT '{}'::text[],
    dependents text[] DEFAULT '{}'::text[],
    config jsonb DEFAULT '{}'::jsonb,
    created_by_wo text,
    last_modified_wo text,
    version integer DEFAULT 1,
    status text DEFAULT 'active'::text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    search_vector tsvector GENERATED ALWAYS AS (((setweight(to_tsvector('english'::regconfig, COALESCE(name, ''::text)), 'A'::"char") || setweight(to_tsvector('english'::regconfig, COALESCE(description, ''::text)), 'B'::"char")) || setweight(to_tsvector('english'::regconfig, COALESCE(purpose, ''::text)), 'B'::"char"))) STORED,
    CONSTRAINT system_manifest_component_type_check CHECK ((component_type = ANY (ARRAY['edge_function'::text, 'table'::text, 'mcp_connector'::text, 'api_integration'::text, 'cron_job'::text, 'trigger'::text, 'rpc_function'::text, 'view'::text, 'policy'::text, 'documentation'::text]))),
    CONSTRAINT system_manifest_status_check CHECK ((status = ANY (ARRAY['active'::text, 'deprecated'::text, 'planned'::text, 'removed'::text])))
);


--
-- Name: TABLE system_manifest; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.system_manifest IS 'Canonical registry of all system components. Source of truth for duplicate detection.';


--
-- Name: system_settings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.system_settings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    setting_key text NOT NULL,
    setting_value jsonb NOT NULL,
    description text,
    last_modified_by text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: TABLE system_settings; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.system_settings IS 'Global system configuration settings';


--
-- Name: COLUMN system_settings.setting_key; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.system_settings.setting_key IS 'Unique key for the setting';


--
-- Name: COLUMN system_settings.setting_value; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.system_settings.setting_value IS 'JSONB value - supports strings, numbers, booleans, objects, arrays';


--
-- Name: system_status; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.system_status (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    component text NOT NULL,
    status text DEFAULT 'unknown'::text NOT NULL,
    last_heartbeat timestamp with time zone,
    metadata jsonb DEFAULT '{}'::jsonb,
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: team_context; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.team_context (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    root_wo_id uuid NOT NULL,
    source_wo_id uuid,
    author_agent text NOT NULL,
    context_type text NOT NULL,
    content text NOT NULL,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT team_context_context_type_check CHECK ((context_type = ANY (ARRAY['plan'::text, 'finding'::text, 'decision'::text, 'file_list'::text, 'schema_change'::text])))
);


--
-- Name: TABLE team_context; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.team_context IS 'Shared scratchpad for multi-agent WO trees. Agents write structured findings that child WOs automatically inherit.';


--
-- Name: thread_messages; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.thread_messages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    thread_id uuid NOT NULL,
    role text NOT NULL,
    content text NOT NULL,
    agent_name text,
    model_used text,
    tool_name text,
    tool_input jsonb,
    tool_output jsonb,
    tool_latency_ms integer,
    input_tokens integer,
    output_tokens integer,
    cost_usd numeric(10,6),
    embedding public.vector(1536),
    created_at timestamp with time zone DEFAULT now(),
    trace_id text,
    span_id text,
    raw_request jsonb,
    raw_response jsonb,
    CONSTRAINT thread_messages_role_check CHECK ((role = ANY (ARRAY['user'::text, 'assistant'::text, 'system'::text, 'tool'::text])))
);


--
-- Name: tool_reliability; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.tool_reliability AS
 WITH last_7d AS (
         SELECT wo_mutations.tool_name,
            count(*) AS total_calls,
            count(*) FILTER (WHERE (wo_mutations.success = true)) AS success_count,
            count(*) FILTER (WHERE (wo_mutations.success = false)) AS failure_count,
            round((((count(*) FILTER (WHERE (wo_mutations.success = false)))::numeric / (NULLIF(count(*), 0))::numeric) * (100)::numeric), 2) AS failure_rate,
            mode() WITHIN GROUP (ORDER BY wo_mutations.error_class) FILTER (WHERE (wo_mutations.error_class IS NOT NULL)) AS top_error_class
           FROM public.wo_mutations
          WHERE (wo_mutations.created_at >= (now() - '7 days'::interval))
          GROUP BY wo_mutations.tool_name
        ), last_24h AS (
         SELECT wo_mutations.tool_name,
            count(*) AS calls_24h,
            round((((count(*) FILTER (WHERE (wo_mutations.success = false)))::numeric / (NULLIF(count(*), 0))::numeric) * (100)::numeric), 2) AS failure_rate_24h
           FROM public.wo_mutations
          WHERE (wo_mutations.created_at >= (now() - '24:00:00'::interval))
          GROUP BY wo_mutations.tool_name
        )
 SELECT l7.tool_name,
    l7.total_calls,
    l7.success_count,
    l7.failure_count,
    l7.failure_rate,
    l7.top_error_class,
    COALESCE(l24.calls_24h, (0)::bigint) AS calls_24h,
    COALESCE(l24.failure_rate_24h, (0)::numeric) AS failure_rate_24h
   FROM (last_7d l7
     LEFT JOIN last_24h l24 ON ((l7.tool_name = l24.tool_name)))
  ORDER BY l7.failure_rate DESC NULLS LAST, l7.total_calls DESC;


--
-- Name: traces; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.traces (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    trace_id text NOT NULL,
    name text,
    user_id text,
    session_id text,
    thread_id uuid,
    work_order_id uuid,
    input jsonb,
    output jsonb,
    metadata jsonb DEFAULT '{}'::jsonb,
    tags text[] DEFAULT '{}'::text[],
    started_at timestamp with time zone DEFAULT now() NOT NULL,
    ended_at timestamp with time zone,
    total_cost_usd numeric(10,6) DEFAULT 0,
    total_tokens integer DEFAULT 0,
    status text DEFAULT 'running'::text,
    error_message text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT traces_status_check CHECK ((status = ANY (ARRAY['running'::text, 'completed'::text, 'error'::text])))
);


--
-- Name: transcripts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.transcripts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    session_id uuid,
    user_id text NOT NULL,
    request_id text,
    intent text,
    domain text,
    risk_tier text,
    complexity_score double precision,
    tools_detected text[],
    committee_triggered boolean DEFAULT false,
    routed_model text NOT NULL,
    routing_reason text,
    routing_rule_id uuid,
    config_version integer,
    user_override_applied boolean DEFAULT false,
    estimated_cost_usd numeric(10,6),
    actual_cost_usd numeric(10,6),
    input_messages jsonb NOT NULL,
    output_message jsonb,
    input_tokens integer,
    output_tokens integer,
    latency_ms integer,
    status text DEFAULT 'pending'::text,
    error_message text,
    committee_details jsonb,
    user_satisfaction integer,
    user_feedback text,
    feedback_at timestamp with time zone,
    input_hash text GENERATED ALWAYS AS (encode(sha256(((input_messages)::text)::bytea), 'hex'::text)) STORED,
    metadata jsonb,
    CONSTRAINT transcripts_user_satisfaction_check CHECK (((user_satisfaction IS NULL) OR ((user_satisfaction >= 1) AND (user_satisfaction <= 5)))),
    CONSTRAINT valid_status CHECK ((status = ANY (ARRAY['pending'::text, 'completed'::text, 'failed'::text, 'timeout'::text])))
);


--
-- Name: unverified_mutations; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.unverified_mutations AS
 SELECT id,
    work_order_id,
    tool_name,
    object_type,
    object_id,
    action,
    success,
    error_class,
    error_detail,
    verification_query,
    verified,
    context,
    created_at,
    agent_name
   FROM public.wo_mutations
  WHERE ((verified = false) AND (verification_query IS NOT NULL));


--
-- Name: VIEW unverified_mutations; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.unverified_mutations IS 'Shows all mutations that have not been verified and have verification queries';


--
-- Name: user_preferences; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_preferences (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id text DEFAULT 'default'::text NOT NULL,
    key text NOT NULL,
    value jsonb NOT NULL,
    category text DEFAULT 'general'::text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: TABLE user_preferences; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.user_preferences IS 'Persistent user preferences injected into METIS system prompt';


--
-- Name: v_agent_costs; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.v_agent_costs AS
 SELECT s.agent_id,
    a.name AS agent_name,
    date(s.started_at) AS date,
    s.model,
    count(*) AS span_count,
    sum(s.input_tokens) AS total_input_tokens,
    sum(s.output_tokens) AS total_output_tokens,
    sum(s.cost_usd) AS total_cost_usd
   FROM (public.spans s
     LEFT JOIN public.agents a ON ((s.agent_id = a.id)))
  WHERE (s.span_type = 'llm-generation'::text)
  GROUP BY s.agent_id, a.name, (date(s.started_at)), s.model;


--
-- Name: v_audit_timeline; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.v_audit_timeline AS
 SELECT al.id,
    al.created_at,
    al.event_type,
    al.actor_type,
    al.actor_id,
    a.name AS agent_name,
    al.action,
    al.target_type,
    al.target_id,
    al.payload,
    wo.slug AS work_order_slug
   FROM ((public.audit_log al
     LEFT JOIN public.agents a ON (((al.actor_type = 'agent'::text) AND (al.actor_id = (a.id)::text))))
     LEFT JOIN public.work_orders wo ON ((al.work_order_id = wo.id)))
  ORDER BY al.created_at DESC;


--
-- Name: v_dependency_chain_status; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.v_dependency_chain_status AS
 WITH chain_health AS (
         SELECT wo.id AS wo_id,
            wo.slug,
            wo.name,
            wo.status,
            wo.depends_on,
            ( SELECT count(*) AS count
                   FROM (unnest(wo.depends_on) dep_id(dep_id)
                     JOIN public.work_orders dep ON ((dep.id = dep_id.dep_id)))
                  WHERE (dep.status = 'done'::public.work_order_status)) AS deps_done,
            ( SELECT count(*) AS count
                   FROM (unnest(wo.depends_on) dep_id(dep_id)
                     JOIN public.work_orders dep ON ((dep.id = dep_id.dep_id)))
                  WHERE (dep.status = 'failed'::public.work_order_status)) AS deps_failed,
            ( SELECT count(*) AS count
                   FROM (unnest(wo.depends_on) dep_id(dep_id)
                     JOIN public.work_orders dep ON ((dep.id = dep_id.dep_id)))
                  WHERE (dep.status = 'cancelled'::public.work_order_status)) AS deps_cancelled,
            ( SELECT count(*) AS count
                   FROM (unnest(wo.depends_on) dep_id(dep_id)
                     JOIN public.work_orders dep ON ((dep.id = dep_id.dep_id)))
                  WHERE (dep.status = ANY (ARRAY['in_progress'::public.work_order_status, 'pending_approval'::public.work_order_status, 'review'::public.work_order_status]))) AS deps_in_progress,
            array_length(wo.depends_on, 1) AS total_deps,
            (EXISTS ( SELECT 1
                   FROM public.detect_circular_dependencies(wo.id) detect_circular_dependencies(cycle_wos, cycle_slugs, severity))) AS has_circular_dep,
            ( SELECT count(*) AS count
                   FROM public.work_orders dependent
                  WHERE (wo.id = ANY (dependent.depends_on))) AS dependent_count
           FROM public.work_orders wo
          WHERE ((wo.depends_on IS NOT NULL) AND (array_length(wo.depends_on, 1) > 0))
        )
 SELECT wo_id,
    slug,
    name,
    status,
    total_deps,
    deps_done,
    deps_failed,
    deps_cancelled,
    deps_in_progress,
    dependent_count,
    has_circular_dep,
        CASE
            WHEN has_circular_dep THEN 'deadlock'::text
            WHEN (deps_cancelled > 0) THEN 'permanently_blocked'::text
            WHEN ((deps_failed > 0) AND (status = 'blocked'::public.work_order_status)) THEN 'failed_dependency'::text
            WHEN (deps_done = total_deps) THEN 'ready'::text
            WHEN (deps_in_progress > 0) THEN 'waiting'::text
            ELSE 'unknown'::text
        END AS chain_status,
        CASE
            WHEN (total_deps > 0) THEN round((((deps_done)::numeric / (total_deps)::numeric) * (100)::numeric), 0)
            ELSE (100)::numeric
        END AS completion_pct
   FROM chain_health
  ORDER BY
        CASE
            WHEN has_circular_dep THEN 1
            WHEN (deps_failed > 0) THEN 2
            WHEN (deps_cancelled > 0) THEN 3
            ELSE 4
        END,
        CASE
            WHEN (total_deps > 0) THEN round((((deps_done)::numeric / (total_deps)::numeric) * (100)::numeric), 0)
            ELSE (100)::numeric
        END DESC, slug;


--
-- Name: VIEW v_dependency_chain_status; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.v_dependency_chain_status IS 'WO-0333: Shows dependency chain health for all WOs with dependencies. Includes circular dependency detection, completion %, and chain status.';


--
-- Name: v_engineering_queue; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.v_engineering_queue AS
 SELECT slug,
    name,
    priority,
    complexity,
    objective,
    acceptance_criteria,
    max_iterations,
    created_at
   FROM public.work_orders
  WHERE ((status = 'ready'::public.work_order_status) AND ((assigned_to_legacy IS NULL) OR (assigned_to_legacy = 'engineering'::public.agent_type)) AND (NOT (EXISTS ( SELECT 1
           FROM (unnest(work_orders.depends_on) dep_id(dep_id)
             JOIN public.work_orders dep ON ((dep.id = dep_id.dep_id)))
          WHERE (dep.status <> 'done'::public.work_order_status)))))
  ORDER BY priority, created_at;


--
-- Name: VIEW v_engineering_queue; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.v_engineering_queue IS 'Engineering work orders ready for pickup, excluding those with unmet dependencies';


--
-- Name: v_langfuse_traces; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.v_langfuse_traces AS
 SELECT trace_id AS id,
    name,
    user_id,
    session_id,
    thread_id,
    input,
    output,
    metadata,
    tags,
    status,
    error_message,
    total_tokens,
    started_at AS "timestamp",
    ended_at,
    total_cost_usd AS "totalCost",
    EXTRACT(epoch FROM (ended_at - started_at)) AS latency
   FROM public.traces;


--
-- Name: v_pending_migrations; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.v_pending_migrations AS
 SELECT slug,
    name,
    description,
    sequence,
    sql_up,
    sql_down,
    dependencies,
    estimated_effort
   FROM public.pending_migrations
  WHERE (status = 'pending'::text)
  ORDER BY sequence;


--
-- Name: v_recent_completions; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.v_recent_completions AS
 SELECT wo.slug,
    wo.name,
    i.deployed_at,
    i.approach_taken,
    wo.completed_at
   FROM (public.work_orders wo
     LEFT JOIN public.implementations i ON ((i.work_order_id = wo.id)))
  WHERE ((wo.status = 'done'::public.work_order_status) AND (wo.completed_at > (now() - '7 days'::interval)))
  ORDER BY wo.completed_at DESC;


--
-- Name: v_work_orders_attention; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.v_work_orders_attention AS
 SELECT slug,
    name,
    status,
    priority,
    assigned_to_legacy AS assigned_to,
    updated_at
   FROM public.work_orders
  WHERE (status = ANY (ARRAY['review'::public.work_order_status, 'blocked'::public.work_order_status]))
  ORDER BY
        CASE status
            WHEN 'blocked'::public.work_order_status THEN 0
            ELSE 1
        END, priority, updated_at DESC;


--
-- Name: valid_facts; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.valid_facts AS
 SELECT id,
    category,
    subject_entity_id,
    subject_text,
    predicate,
    object_text,
    object_entity_id,
    confidence,
    valid_from,
    valid_until,
    source_conversation_id,
    source_message_id,
    created_at
   FROM public.facts
  WHERE ((valid_from <= now()) AND ((valid_until IS NULL) OR (valid_until > now())));


--
-- Name: value_types; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.value_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    type_name text NOT NULL,
    json_schema jsonb NOT NULL,
    version integer DEFAULT 1,
    description text,
    applicable_columns text[],
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: verification_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.verification_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    verified_by text NOT NULL,
    verification_type text NOT NULL,
    evidence jsonb NOT NULL,
    passed boolean NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: wo_cancel_rate_pct; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.wo_cancel_rate_pct AS
 SELECT date_trunc('week'::text, created_at) AS week_start,
    count(*) AS total_wos,
    count(*) FILTER (WHERE (status = 'cancelled'::public.work_order_status)) AS cancelled,
    round(((100.0 * (count(*) FILTER (WHERE (status = 'cancelled'::public.work_order_status)))::numeric) / (NULLIF(count(*), 0))::numeric), 1) AS cancel_pct,
    count(*) FILTER (WHERE ((status = 'cancelled'::public.work_order_status) AND (cancellation_reason IS NOT NULL))) AS reason_captured,
    count(*) FILTER (WHERE ((status = 'cancelled'::public.work_order_status) AND (complexity = ANY (ARRAY['large'::public.work_order_complexity, 'unknown'::public.work_order_complexity])))) AS complex_cancelled,
    count(*) FILTER (WHERE ((complexity = ANY (ARRAY['large'::public.work_order_complexity, 'unknown'::public.work_order_complexity])) AND (depends_on IS NOT NULL) AND (array_length(depends_on, 1) > 0))) AS complex_decomposed,
        CASE
            WHEN (round(((100.0 * (count(*) FILTER (WHERE (status = 'cancelled'::public.work_order_status)))::numeric) / (NULLIF(count(*), 0))::numeric), 1) < (15)::numeric) THEN '✓ TARGET MET (< 15%)'::text
            WHEN (round(((100.0 * (count(*) FILTER (WHERE (status = 'cancelled'::public.work_order_status)))::numeric) / (NULLIF(count(*), 0))::numeric), 1) < (20)::numeric) THEN '✓ BELOW 20%'::text
            ELSE '✗ ABOVE 20%'::text
        END AS status
   FROM public.work_orders
  WHERE (created_at >= (now() - '56 days'::interval))
  GROUP BY (date_trunc('week'::text, created_at))
  ORDER BY (date_trunc('week'::text, created_at)) DESC;


--
-- Name: VIEW wo_cancel_rate_pct; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.wo_cancel_rate_pct IS 'Weekly cancellation rate tracking to monitor gate effectiveness (WO-0069)';


--
-- Name: wo_cancellation_metrics; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.wo_cancellation_metrics AS
 WITH time_buckets AS (
         SELECT date_trunc('day'::text, work_orders.created_at) AS metric_date,
            count(*) FILTER (WHERE (work_orders.status = 'cancelled'::public.work_order_status)) AS cancelled_count,
            count(*) AS total_count,
            round(((100.0 * (count(*) FILTER (WHERE (work_orders.status = 'cancelled'::public.work_order_status)))::numeric) / (NULLIF(count(*), 0))::numeric), 2) AS cancellation_rate_pct
           FROM public.work_orders
          WHERE (work_orders.created_at >= (CURRENT_DATE - '60 days'::interval))
          GROUP BY (date_trunc('day'::text, work_orders.created_at))
        ), rolling_windows AS (
         SELECT time_buckets.metric_date,
            time_buckets.cancelled_count,
            time_buckets.total_count,
            time_buckets.cancellation_rate_pct,
            round(avg(time_buckets.cancellation_rate_pct) OVER (ORDER BY time_buckets.metric_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW), 2) AS rolling_7day_rate,
            round(avg(time_buckets.cancellation_rate_pct) OVER (ORDER BY time_buckets.metric_date ROWS BETWEEN 13 PRECEDING AND CURRENT ROW), 2) AS rolling_14day_rate,
            round(avg(time_buckets.cancellation_rate_pct) OVER (ORDER BY time_buckets.metric_date ROWS BETWEEN 27 PRECEDING AND CURRENT ROW), 2) AS rolling_28day_rate
           FROM time_buckets
        )
 SELECT metric_date,
    cancelled_count,
    total_count,
    cancellation_rate_pct AS daily_rate,
    rolling_7day_rate,
    rolling_14day_rate,
    rolling_28day_rate,
        CASE
            WHEN (rolling_14day_rate < (20)::numeric) THEN true
            ELSE false
        END AS meeting_2week_target,
        CASE
            WHEN (rolling_28day_rate < (15)::numeric) THEN true
            ELSE false
        END AS meeting_4week_target
   FROM rolling_windows
  ORDER BY metric_date DESC;


--
-- Name: VIEW wo_cancellation_metrics; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.wo_cancellation_metrics IS 'Tracks daily and rolling cancellation rates with target flags for WO-0069';


--
-- Name: wo_effect_registry; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wo_effect_registry (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    trigger_on_status public.work_order_status NOT NULL,
    effect_type text NOT NULL,
    handler text NOT NULL,
    config jsonb DEFAULT '{}'::jsonb,
    execution_order integer DEFAULT 0,
    enabled boolean DEFAULT true,
    description text
);


--
-- Name: wo_effects; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wo_effects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    effect_type text NOT NULL,
    payload jsonb DEFAULT '{}'::jsonb NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    error_detail text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    processed_at timestamp with time zone,
    retry_count integer DEFAULT 0 NOT NULL,
    max_retries integer DEFAULT 3 NOT NULL,
    CONSTRAINT wo_effects_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'completed'::text, 'failed'::text])))
);


--
-- Name: TABLE wo_effects; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.wo_effects IS 'Outbox pattern: state transition side-effects queued for async processing instead of inline triggers';


--
-- Name: wo_event_stream; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wo_event_stream (
    id bigint NOT NULL,
    stream_id uuid NOT NULL,
    version integer NOT NULL,
    event_type text NOT NULL,
    occurred_at timestamp with time zone DEFAULT now() NOT NULL,
    actor text NOT NULL,
    payload jsonb DEFAULT '{}'::jsonb NOT NULL,
    state_before jsonb NOT NULL,
    state_after jsonb NOT NULL,
    evidence jsonb DEFAULT '{}'::jsonb,
    hash text NOT NULL,
    previous_hash text
);


--
-- Name: wo_event_stream_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.wo_event_stream_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: wo_event_stream_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.wo_event_stream_id_seq OWNED BY public.wo_event_stream.id;


--
-- Name: wo_events_archive; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wo_events_archive (
    id uuid NOT NULL,
    work_order_id uuid,
    event_type text NOT NULL,
    previous_status text,
    new_status text,
    payload jsonb,
    actor text NOT NULL,
    depth integer,
    status text,
    retry_count integer,
    created_at timestamp with time zone,
    processed_at timestamp with time zone,
    error_detail text,
    archived_at timestamp with time zone DEFAULT now(),
    CONSTRAINT chk_archived_at_not_null CHECK ((archived_at IS NOT NULL)),
    CONSTRAINT chk_depth_non_negative CHECK ((depth >= 0)),
    CONSTRAINT chk_event_type_not_empty CHECK ((length(TRIM(BOTH FROM event_type)) > 0)),
    CONSTRAINT chk_retry_count_non_negative CHECK ((retry_count >= 0))
);


--
-- Name: wo_file_locks; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wo_file_locks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    file_path text NOT NULL,
    acquired_at timestamp with time zone DEFAULT now(),
    released_at timestamp with time zone
);


--
-- Name: wo_mutation_summary; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.wo_mutation_summary AS
 WITH error_counts AS (
         SELECT wo_mutations.work_order_id,
            COALESCE(wo_mutations.error_class, 'success'::text) AS error_key,
            count(*) AS error_count
           FROM public.wo_mutations
          GROUP BY wo_mutations.work_order_id, COALESCE(wo_mutations.error_class, 'success'::text)
        )
 SELECT work_order_id,
    (sum(error_count))::bigint AS total_mutations,
    (COALESCE(sum(error_count) FILTER (WHERE (error_key = 'success'::text)), (0)::numeric))::bigint AS successful_count,
    (COALESCE(sum(error_count) FILTER (WHERE (error_key <> 'success'::text)), (0)::numeric))::bigint AS failed_count,
    jsonb_object_agg(error_key, error_count) AS error_class_breakdown
   FROM error_counts
  GROUP BY work_order_id;


--
-- Name: wo_state_machine; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wo_state_machine (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    from_status public.work_order_status NOT NULL,
    event text NOT NULL,
    to_status public.work_order_status NOT NULL,
    guard_function text,
    effects jsonb DEFAULT '[]'::jsonb,
    enabled boolean DEFAULT true,
    description text
);


--
-- Name: wo_tree; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.wo_tree AS
 WITH RECURSIVE tree AS (
         SELECT work_orders.id,
            work_orders.slug,
            work_orders.name,
            work_orders.status,
            work_orders.priority,
            work_orders.parent_id,
            0 AS depth,
            ARRAY[work_orders.slug] AS path,
            work_orders.slug AS root_slug
           FROM public.work_orders
          WHERE (work_orders.parent_id IS NULL)
        UNION ALL
         SELECT wo.id,
            wo.slug,
            wo.name,
            wo.status,
            wo.priority,
            wo.parent_id,
            (tree_1.depth + 1),
            (tree_1.path || wo.slug),
            tree_1.root_slug
           FROM (public.work_orders wo
             JOIN tree tree_1 ON ((wo.parent_id = tree_1.id)))
        )
 SELECT id,
    slug,
    name,
    status,
    priority,
    parent_id,
    depth,
    path,
    root_slug
   FROM tree;


--
-- Name: VIEW wo_tree; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON VIEW public.wo_tree IS 'Recursive CTE view showing work order parent→children hierarchy. Depth 0 = root WOs, depth 1+ = children/grandchildren.';


--
-- Name: work_order_execution_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.work_order_execution_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    work_order_id uuid NOT NULL,
    phase text NOT NULL,
    agent_name text,
    detail jsonb DEFAULT '{}'::jsonb,
    iteration integer DEFAULT 1,
    created_at timestamp with time zone DEFAULT now(),
    prev_hash text,
    entry_hash text,
    CONSTRAINT work_order_execution_log_phase_check CHECK ((phase = ANY (ARRAY['draft_created'::text, 'approved'::text, 'claimed'::text, 'planning'::text, 'executing'::text, 'completing'::text, 'completed'::text, 'failed'::text, 'review'::text, 'rejected'::text, 'cancelled'::text, 'deployment'::text, 'rollback'::text, 'validation'::text, 'gate_evaluation'::text, 'qa_validation'::text, 'freshness_check'::text, 'refined'::text, 'deprecated'::text, 'consolidation'::text, 'schema_validation'::text, 'execution_start'::text, 'execution_complete'::text, 'tool_call'::text, 'coding'::text, 'deploying'::text, 'deployment_validation'::text, 'deployment_verification'::text, 'loop_breaker'::text, 'qa_review'::text, 'schema_injection'::text, 'stream'::text, 'testing'::text, 'verification_failed'::text, 'verification_warning'::text, 'remediation_loop'::text, 'frontend_validation'::text, 'reprioritize'::text, 'push_dispatch'::text, 'cascade_start'::text, 'auto_start'::text, 'health_check'::text, 'stuck_detection'::text, 'orphan_cleanup'::text, 'failed_retry'::text, 'escalation'::text, 'velocity_check'::text, 'checkpoint'::text, 'continuation'::text])))
);


--
-- Name: TABLE work_order_execution_log; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.work_order_execution_log IS 'Granular execution phase tracking for work orders. Populated by daemon/agents via webhook. Enables real-time visibility into WO progress.';


--
-- Name: COLUMN work_order_execution_log.prev_hash; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_order_execution_log.prev_hash IS 'SHA256 hash of the previous entry in the chain, creating tamper-evident provenance';


--
-- Name: COLUMN work_order_execution_log.entry_hash; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.work_order_execution_log.entry_hash IS 'SHA256 hash of this entry (work_order_id || phase || agent_name || detail || prev_hash || created_at)';


--
-- Name: workspace_events; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.workspace_events (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    agent_id uuid,
    event_type text NOT NULL,
    work_order_id uuid,
    target_agent_id uuid,
    payload jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT workspace_events_event_type_check CHECK ((event_type = ANY (ARRAY['claimed'::text, 'released'::text, 'completed'::text, 'blocked'::text, 'failed'::text, 'needs_review'::text, 'approved'::text, 'rejected'::text, 'message'::text, 'handoff'::text, 'escalation'::text])))
);


--
-- Name: workspace_locks; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.workspace_locks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    resource_type text NOT NULL,
    resource_id text NOT NULL,
    agent_id uuid NOT NULL,
    lock_type text NOT NULL,
    reason text,
    acquired_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone NOT NULL,
    CONSTRAINT workspace_locks_lock_type_check CHECK ((lock_type = ANY (ARRAY['exclusive'::text, 'shared'::text]))),
    CONSTRAINT workspace_locks_resource_type_check CHECK ((resource_type = ANY (ARRAY['work_order'::text, 'file'::text, 'table'::text, 'function'::text, 'deployment'::text])))
);


--
-- Name: kernel_spec id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.kernel_spec ALTER COLUMN id SET DEFAULT nextval('public.kernel_spec_id_seq'::regclass);


--
-- Name: wo_event_stream id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_event_stream ALTER COLUMN id SET DEFAULT nextval('public.wo_event_stream_id_seq'::regclass);


--
-- Name: active_sessions active_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.active_sessions
    ADD CONSTRAINT active_sessions_pkey PRIMARY KEY (id);


--
-- Name: active_sessions active_sessions_session_token_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.active_sessions
    ADD CONSTRAINT active_sessions_session_token_key UNIQUE (session_token);


--
-- Name: agent_daemon_config agent_daemon_config_agent_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_daemon_config
    ADD CONSTRAINT agent_daemon_config_agent_id_key UNIQUE (agent_id);


--
-- Name: agent_daemon_config agent_daemon_config_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_daemon_config
    ADD CONSTRAINT agent_daemon_config_pkey PRIMARY KEY (id);


--
-- Name: agent_escalation_tiers agent_escalation_tiers_agent_name_tier_order_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_escalation_tiers
    ADD CONSTRAINT agent_escalation_tiers_agent_name_tier_order_key UNIQUE (agent_name, tier_order);


--
-- Name: agent_escalation_tiers agent_escalation_tiers_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_escalation_tiers
    ADD CONSTRAINT agent_escalation_tiers_pkey PRIMARY KEY (id);


--
-- Name: agent_execution_profiles agent_execution_profiles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_execution_profiles
    ADD CONSTRAINT agent_execution_profiles_pkey PRIMARY KEY (agent_name);


--
-- Name: agent_knowledge_base agent_knowledge_base_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_knowledge_base
    ADD CONSTRAINT agent_knowledge_base_pkey PRIMARY KEY (id);


--
-- Name: agent_knowledge_base agent_knowledge_base_topic_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_knowledge_base
    ADD CONSTRAINT agent_knowledge_base_topic_key UNIQUE (topic);


--
-- Name: agent_memory agent_memory_agent_id_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_memory
    ADD CONSTRAINT agent_memory_agent_id_key_key UNIQUE (agent_id, key);


--
-- Name: agent_memory agent_memory_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_memory
    ADD CONSTRAINT agent_memory_pkey PRIMARY KEY (id);


--
-- Name: agent_quotas agent_quotas_agent_id_quota_type_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_quotas
    ADD CONSTRAINT agent_quotas_agent_id_quota_type_key UNIQUE (agent_id, quota_type);


--
-- Name: agent_quotas agent_quotas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_quotas
    ADD CONSTRAINT agent_quotas_pkey PRIMARY KEY (id);


--
-- Name: agents agents_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agents
    ADD CONSTRAINT agents_name_key UNIQUE (name);


--
-- Name: agents agents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agents
    ADD CONSTRAINT agents_pkey PRIMARY KEY (id);


--
-- Name: allowed_actions allowed_actions_action_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.allowed_actions
    ADD CONSTRAINT allowed_actions_action_name_key UNIQUE (action_name);


--
-- Name: allowed_actions allowed_actions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.allowed_actions
    ADD CONSTRAINT allowed_actions_pkey PRIMARY KEY (id);


--
-- Name: approval_queue approval_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.approval_queue
    ADD CONSTRAINT approval_queue_pkey PRIMARY KEY (id);


--
-- Name: audit_log audit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT audit_log_pkey PRIMARY KEY (id);


--
-- Name: auto_approval_log auto_approval_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.auto_approval_log
    ADD CONSTRAINT auto_approval_log_pkey PRIMARY KEY (id);


--
-- Name: backlog backlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.backlog
    ADD CONSTRAINT backlog_pkey PRIMARY KEY (id);


--
-- Name: bypass_log bypass_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bypass_log
    ADD CONSTRAINT bypass_log_pkey PRIMARY KEY (id);


--
-- Name: clarification_requests clarification_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.clarification_requests
    ADD CONSTRAINT clarification_requests_pkey PRIMARY KEY (id);


--
-- Name: consensus_votes consensus_votes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.consensus_votes
    ADD CONSTRAINT consensus_votes_pkey PRIMARY KEY (id);


--
-- Name: consensus_votes consensus_votes_work_order_id_agent_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.consensus_votes
    ADD CONSTRAINT consensus_votes_work_order_id_agent_id_key UNIQUE (work_order_id, agent_id);


--
-- Name: conversation_threads conversation_threads_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.conversation_threads
    ADD CONSTRAINT conversation_threads_pkey PRIMARY KEY (id);


--
-- Name: conversations conversations_external_id_unique; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.conversations
    ADD CONSTRAINT conversations_external_id_unique UNIQUE (external_id);


--
-- Name: conversations conversations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.conversations
    ADD CONSTRAINT conversations_pkey PRIMARY KEY (id);


--
-- Name: council_presets council_presets_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.council_presets
    ADD CONSTRAINT council_presets_name_key UNIQUE (name);


--
-- Name: council_presets council_presets_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.council_presets
    ADD CONSTRAINT council_presets_pkey PRIMARY KEY (id);


--
-- Name: daemon_heartbeats daemon_heartbeats_daemon_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.daemon_heartbeats
    ADD CONSTRAINT daemon_heartbeats_daemon_name_key UNIQUE (daemon_name);


--
-- Name: daemon_heartbeats daemon_heartbeats_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.daemon_heartbeats
    ADD CONSTRAINT daemon_heartbeats_pkey PRIMARY KEY (id);


--
-- Name: decision_gates decision_gates_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.decision_gates
    ADD CONSTRAINT decision_gates_name_key UNIQUE (name);


--
-- Name: decision_gates decision_gates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.decision_gates
    ADD CONSTRAINT decision_gates_pkey PRIMARY KEY (id);


--
-- Name: decisions decisions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.decisions
    ADD CONSTRAINT decisions_pkey PRIMARY KEY (id);


--
-- Name: directive_versions directive_versions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.directive_versions
    ADD CONSTRAINT directive_versions_pkey PRIMARY KEY (id);


--
-- Name: edge_function_tool_registry edge_function_tool_registry_function_slug_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.edge_function_tool_registry
    ADD CONSTRAINT edge_function_tool_registry_function_slug_key UNIQUE (function_slug);


--
-- Name: edge_function_tool_registry edge_function_tool_registry_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.edge_function_tool_registry
    ADD CONSTRAINT edge_function_tool_registry_pkey PRIMARY KEY (id);


--
-- Name: enforcer_canary enforcer_canary_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.enforcer_canary
    ADD CONSTRAINT enforcer_canary_pkey PRIMARY KEY (id);


--
-- Name: enforcer_findings enforcer_findings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.enforcer_findings
    ADD CONSTRAINT enforcer_findings_pkey PRIMARY KEY (id);


--
-- Name: enforcer_runs enforcer_runs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.enforcer_runs
    ADD CONSTRAINT enforcer_runs_pkey PRIMARY KEY (id);


--
-- Name: entities entities_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.entities
    ADD CONSTRAINT entities_pkey PRIMARY KEY (id);


--
-- Name: error_definitions error_definitions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.error_definitions
    ADD CONSTRAINT error_definitions_pkey PRIMARY KEY (code);


--
-- Name: error_events error_events_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.error_events
    ADD CONSTRAINT error_events_pkey PRIMARY KEY (id);


--
-- Name: evidence_bundles evidence_bundles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.evidence_bundles
    ADD CONSTRAINT evidence_bundles_pkey PRIMARY KEY (id);


--
-- Name: facts facts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facts
    ADD CONSTRAINT facts_pkey PRIMARY KEY (id);


--
-- Name: implementations implementations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.implementations
    ADD CONSTRAINT implementations_pkey PRIMARY KEY (id);


--
-- Name: intake_log intake_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.intake_log
    ADD CONSTRAINT intake_log_pkey PRIMARY KEY (id);


--
-- Name: interaction_definitions interaction_definitions_interaction_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.interaction_definitions
    ADD CONSTRAINT interaction_definitions_interaction_name_key UNIQUE (interaction_name);


--
-- Name: interaction_definitions interaction_definitions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.interaction_definitions
    ADD CONSTRAINT interaction_definitions_pkey PRIMARY KEY (id);


--
-- Name: interface_implementations interface_implementations_interface_id_object_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.interface_implementations
    ADD CONSTRAINT interface_implementations_interface_id_object_id_key UNIQUE (interface_id, object_id);


--
-- Name: interface_implementations interface_implementations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.interface_implementations
    ADD CONSTRAINT interface_implementations_pkey PRIMARY KEY (id);


--
-- Name: interrogation_sessions interrogation_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.interrogation_sessions
    ADD CONSTRAINT interrogation_sessions_pkey PRIMARY KEY (id);


--
-- Name: kernel_spec kernel_spec_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.kernel_spec
    ADD CONSTRAINT kernel_spec_pkey PRIMARY KEY (id);


--
-- Name: kernel_spec kernel_spec_version_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.kernel_spec
    ADD CONSTRAINT kernel_spec_version_key UNIQUE (version);


--
-- Name: langfuse_traces langfuse_traces_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.langfuse_traces
    ADD CONSTRAINT langfuse_traces_pkey PRIMARY KEY (id);


--
-- Name: langfuse_traces langfuse_traces_trace_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.langfuse_traces
    ADD CONSTRAINT langfuse_traces_trace_id_key UNIQUE (trace_id);


--
-- Name: lesson_acknowledgments lesson_acknowledgments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.lesson_acknowledgments
    ADD CONSTRAINT lesson_acknowledgments_pkey PRIMARY KEY (id);


--
-- Name: lesson_acknowledgments lesson_acknowledgments_work_order_id_lesson_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.lesson_acknowledgments
    ADD CONSTRAINT lesson_acknowledgments_work_order_id_lesson_id_key UNIQUE (work_order_id, lesson_id);


--
-- Name: lessons lessons_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.lessons
    ADD CONSTRAINT lessons_pkey PRIMARY KEY (id);


--
-- Name: llm_provider_config llm_provider_config_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.llm_provider_config
    ADD CONSTRAINT llm_provider_config_pkey PRIMARY KEY (id);


--
-- Name: llm_usage llm_usage_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.llm_usage
    ADD CONSTRAINT llm_usage_pkey PRIMARY KEY (id);


--
-- Name: metis_capabilities metis_capabilities_capability_type_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.metis_capabilities
    ADD CONSTRAINT metis_capabilities_capability_type_name_key UNIQUE (capability_type, name);


--
-- Name: metis_capabilities metis_capabilities_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.metis_capabilities
    ADD CONSTRAINT metis_capabilities_pkey PRIMARY KEY (id);


--
-- Name: model_capabilities model_capabilities_model_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.model_capabilities
    ADD CONSTRAINT model_capabilities_model_id_key UNIQUE (model_id);


--
-- Name: model_capabilities model_capabilities_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.model_capabilities
    ADD CONSTRAINT model_capabilities_pkey PRIMARY KEY (id);


--
-- Name: model_pricing model_pricing_model_id_effective_date_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.model_pricing
    ADD CONSTRAINT model_pricing_model_id_effective_date_key UNIQUE (model_id, effective_date);


--
-- Name: model_pricing model_pricing_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.model_pricing
    ADD CONSTRAINT model_pricing_pkey PRIMARY KEY (id);


--
-- Name: monitor_triage_queue monitor_triage_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.monitor_triage_queue
    ADD CONSTRAINT monitor_triage_queue_pkey PRIMARY KEY (id);


--
-- Name: object_links object_links_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.object_links
    ADD CONSTRAINT object_links_pkey PRIMARY KEY (id);


--
-- Name: object_links object_links_source_target_type_unique; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.object_links
    ADD CONSTRAINT object_links_source_target_type_unique UNIQUE (source_id, target_id, link_type);


--
-- Name: object_registry object_registry_object_type_object_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.object_registry
    ADD CONSTRAINT object_registry_object_type_object_name_key UNIQUE (object_type, object_name);


--
-- Name: object_registry object_registry_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.object_registry
    ADD CONSTRAINT object_registry_pkey PRIMARY KEY (id);


--
-- Name: ontology_interfaces ontology_interfaces_interface_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ontology_interfaces
    ADD CONSTRAINT ontology_interfaces_interface_name_key UNIQUE (interface_name);


--
-- Name: ontology_interfaces ontology_interfaces_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ontology_interfaces
    ADD CONSTRAINT ontology_interfaces_pkey PRIMARY KEY (id);


--
-- Name: open_source_tools open_source_tools_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.open_source_tools
    ADD CONSTRAINT open_source_tools_pkey PRIMARY KEY (id);


--
-- Name: pending_migrations pending_migrations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pending_migrations
    ADD CONSTRAINT pending_migrations_pkey PRIMARY KEY (id);


--
-- Name: pending_migrations pending_migrations_slug_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pending_migrations
    ADD CONSTRAINT pending_migrations_slug_key UNIQUE (slug);


--
-- Name: pipeline_runs pipeline_runs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pipeline_runs
    ADD CONSTRAINT pipeline_runs_pkey PRIMARY KEY (id);


--
-- Name: wo_events_archive pk_wo_events_archive; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_events_archive
    ADD CONSTRAINT pk_wo_events_archive PRIMARY KEY (id);


--
-- Name: platform_health_snapshots platform_health_snapshots_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.platform_health_snapshots
    ADD CONSTRAINT platform_health_snapshots_pkey PRIMARY KEY (id);


--
-- Name: preferences preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.preferences
    ADD CONSTRAINT preferences_pkey PRIMARY KEY (id);


--
-- Name: preferences preferences_scope_key_org_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.preferences
    ADD CONSTRAINT preferences_scope_key_org_key UNIQUE (scope, key, org);


--
-- Name: project_briefs project_briefs_code_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_briefs
    ADD CONSTRAINT project_briefs_code_key UNIQUE (code);


--
-- Name: project_briefs project_briefs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_briefs
    ADD CONSTRAINT project_briefs_pkey PRIMARY KEY (id);


--
-- Name: project_context project_context_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_context
    ADD CONSTRAINT project_context_pkey PRIMARY KEY (id);


--
-- Name: project_context project_context_project_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_context
    ADD CONSTRAINT project_context_project_name_key UNIQUE (project_name);


--
-- Name: project_documents project_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_documents
    ADD CONSTRAINT project_documents_pkey PRIMARY KEY (id);


--
-- Name: project_documents project_documents_project_id_doc_type_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_documents
    ADD CONSTRAINT project_documents_project_id_doc_type_key UNIQUE (project_id, doc_type);


--
-- Name: project_documents project_documents_project_id_doc_type_version_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_documents
    ADD CONSTRAINT project_documents_project_id_doc_type_version_key UNIQUE (project_id, doc_type, version);


--
-- Name: projects projects_code_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_code_key UNIQUE (code);


--
-- Name: projects projects_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_pkey PRIMARY KEY (id);


--
-- Name: qa_findings qa_findings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.qa_findings
    ADD CONSTRAINT qa_findings_pkey PRIMARY KEY (id);


--
-- Name: rate_limit_log rate_limit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rate_limit_log
    ADD CONSTRAINT rate_limit_log_pkey PRIMARY KEY (id);


--
-- Name: regression_suite_definitions regression_suite_definitions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.regression_suite_definitions
    ADD CONSTRAINT regression_suite_definitions_pkey PRIMARY KEY (id);


--
-- Name: regression_suite_runs regression_suite_runs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.regression_suite_runs
    ADD CONSTRAINT regression_suite_runs_pkey PRIMARY KEY (id);


--
-- Name: request_schemas request_schemas_endpoint_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.request_schemas
    ADD CONSTRAINT request_schemas_endpoint_key UNIQUE (endpoint);


--
-- Name: request_schemas request_schemas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.request_schemas
    ADD CONSTRAINT request_schemas_pkey PRIMARY KEY (id);


--
-- Name: routing_rules routing_rules_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.routing_rules
    ADD CONSTRAINT routing_rules_pkey PRIMARY KEY (id);


--
-- Name: run_scorecards run_scorecards_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.run_scorecards
    ADD CONSTRAINT run_scorecards_pkey PRIMARY KEY (id);


--
-- Name: run_scorecards run_scorecards_work_order_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.run_scorecards
    ADD CONSTRAINT run_scorecards_work_order_id_key UNIQUE (work_order_id);


--
-- Name: sandbox_executions sandbox_executions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.sandbox_executions
    ADD CONSTRAINT sandbox_executions_pkey PRIMARY KEY (id);


--
-- Name: scaffold_contracts scaffold_contracts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.scaffold_contracts
    ADD CONSTRAINT scaffold_contracts_pkey PRIMARY KEY (id);


--
-- Name: schema_changes schema_changes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.schema_changes
    ADD CONSTRAINT schema_changes_pkey PRIMARY KEY (id);


--
-- Name: secrets secrets_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.secrets
    ADD CONSTRAINT secrets_pkey PRIMARY KEY (key);


--
-- Name: spans spans_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.spans
    ADD CONSTRAINT spans_pkey PRIMARY KEY (id);


--
-- Name: spans spans_trace_id_span_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.spans
    ADD CONSTRAINT spans_trace_id_span_id_key UNIQUE (trace_id, span_id);


--
-- Name: state_mutations state_mutations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.state_mutations
    ADD CONSTRAINT state_mutations_pkey PRIMARY KEY (id);


--
-- Name: system_directives system_directives_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.system_directives
    ADD CONSTRAINT system_directives_pkey PRIMARY KEY (id);


--
-- Name: system_manifest system_manifest_component_type_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.system_manifest
    ADD CONSTRAINT system_manifest_component_type_name_key UNIQUE (component_type, name);


--
-- Name: system_manifest system_manifest_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.system_manifest
    ADD CONSTRAINT system_manifest_pkey PRIMARY KEY (id);


--
-- Name: system_settings system_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.system_settings
    ADD CONSTRAINT system_settings_pkey PRIMARY KEY (id);


--
-- Name: system_settings system_settings_setting_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.system_settings
    ADD CONSTRAINT system_settings_setting_key_key UNIQUE (setting_key);


--
-- Name: system_status system_status_component_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.system_status
    ADD CONSTRAINT system_status_component_key UNIQUE (component);


--
-- Name: system_status system_status_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.system_status
    ADD CONSTRAINT system_status_pkey PRIMARY KEY (id);


--
-- Name: team_context team_context_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.team_context
    ADD CONSTRAINT team_context_pkey PRIMARY KEY (id);


--
-- Name: thread_messages thread_messages_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.thread_messages
    ADD CONSTRAINT thread_messages_pkey PRIMARY KEY (id);


--
-- Name: traces traces_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.traces
    ADD CONSTRAINT traces_pkey PRIMARY KEY (id);


--
-- Name: traces traces_trace_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.traces
    ADD CONSTRAINT traces_trace_id_key UNIQUE (trace_id);


--
-- Name: transcripts transcripts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.transcripts
    ADD CONSTRAINT transcripts_pkey PRIMARY KEY (id);


--
-- Name: transcripts transcripts_request_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.transcripts
    ADD CONSTRAINT transcripts_request_id_key UNIQUE (request_id);


--
-- Name: evidence_bundles unique_bundle_per_wo; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.evidence_bundles
    ADD CONSTRAINT unique_bundle_per_wo UNIQUE (work_order_id);


--
-- Name: wo_execution_manifest unique_manifest_step; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_execution_manifest
    ADD CONSTRAINT unique_manifest_step UNIQUE (work_order_id, ac_number, step_order);


--
-- Name: user_preferences user_preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_preferences
    ADD CONSTRAINT user_preferences_pkey PRIMARY KEY (id);


--
-- Name: user_preferences user_preferences_user_id_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_preferences
    ADD CONSTRAINT user_preferences_user_id_key_key UNIQUE (user_id, key);


--
-- Name: value_types value_types_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.value_types
    ADD CONSTRAINT value_types_pkey PRIMARY KEY (id);


--
-- Name: value_types value_types_type_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.value_types
    ADD CONSTRAINT value_types_type_name_key UNIQUE (type_name);


--
-- Name: verification_log verification_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.verification_log
    ADD CONSTRAINT verification_log_pkey PRIMARY KEY (id);


--
-- Name: wo_batches wo_batches_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_batches
    ADD CONSTRAINT wo_batches_pkey PRIMARY KEY (id);


--
-- Name: wo_effect_registry wo_effect_registry_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_effect_registry
    ADD CONSTRAINT wo_effect_registry_pkey PRIMARY KEY (id);


--
-- Name: wo_effect_registry wo_effect_registry_trigger_on_status_effect_type_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_effect_registry
    ADD CONSTRAINT wo_effect_registry_trigger_on_status_effect_type_key UNIQUE (trigger_on_status, effect_type);


--
-- Name: wo_effects wo_effects_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_effects
    ADD CONSTRAINT wo_effects_pkey PRIMARY KEY (id);


--
-- Name: wo_event_stream wo_event_stream_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_event_stream
    ADD CONSTRAINT wo_event_stream_pkey PRIMARY KEY (id);


--
-- Name: wo_event_stream wo_event_stream_stream_id_version_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_event_stream
    ADD CONSTRAINT wo_event_stream_stream_id_version_key UNIQUE (stream_id, version);


--
-- Name: wo_events wo_events_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_events
    ADD CONSTRAINT wo_events_pkey PRIMARY KEY (id);


--
-- Name: wo_execution_manifest wo_execution_manifest_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_execution_manifest
    ADD CONSTRAINT wo_execution_manifest_pkey PRIMARY KEY (id);


--
-- Name: wo_file_locks wo_file_locks_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_file_locks
    ADD CONSTRAINT wo_file_locks_pkey PRIMARY KEY (id);


--
-- Name: wo_file_locks wo_file_locks_work_order_id_file_path_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_file_locks
    ADD CONSTRAINT wo_file_locks_work_order_id_file_path_key UNIQUE (work_order_id, file_path);


--
-- Name: wo_mutations wo_mutations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_mutations
    ADD CONSTRAINT wo_mutations_pkey PRIMARY KEY (id);


--
-- Name: wo_state_machine wo_state_machine_from_status_event_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_state_machine
    ADD CONSTRAINT wo_state_machine_from_status_event_key UNIQUE (from_status, event);


--
-- Name: wo_state_machine wo_state_machine_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_state_machine
    ADD CONSTRAINT wo_state_machine_pkey PRIMARY KEY (id);


--
-- Name: work_order_execution_log work_order_execution_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.work_order_execution_log
    ADD CONSTRAINT work_order_execution_log_pkey PRIMARY KEY (id);


--
-- Name: work_orders work_orders_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.work_orders
    ADD CONSTRAINT work_orders_pkey PRIMARY KEY (id);


--
-- Name: work_orders work_orders_slug_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.work_orders
    ADD CONSTRAINT work_orders_slug_key UNIQUE (slug);


--
-- Name: workspace_events workspace_events_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.workspace_events
    ADD CONSTRAINT workspace_events_pkey PRIMARY KEY (id);


--
-- Name: workspace_locks workspace_locks_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.workspace_locks
    ADD CONSTRAINT workspace_locks_pkey PRIMARY KEY (id);


--
-- Name: workspace_locks workspace_locks_resource_type_resource_id_agent_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.workspace_locks
    ADD CONSTRAINT workspace_locks_resource_type_resource_id_agent_id_key UNIQUE (resource_type, resource_id, agent_id);


--
-- Name: action_type_rates_lookup; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX action_type_rates_lookup ON public.action_type_rates USING btree (tool_name, action);


--
-- Name: conversations_embedding_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX conversations_embedding_idx ON public.conversations USING ivfflat (embedding public.vector_cosine_ops) WITH (lists='100');


--
-- Name: idx_action_success_rates_pk; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_action_success_rates_pk ON public.action_success_rates USING btree (tool_name, object_type, action);


--
-- Name: idx_active_sessions_expires; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_active_sessions_expires ON public.active_sessions USING btree (expires_at);


--
-- Name: idx_active_sessions_token; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_active_sessions_token ON public.active_sessions USING btree (session_token);


--
-- Name: idx_agent_daemon_config_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_agent_daemon_config_active ON public.agent_daemon_config USING btree (active) WHERE (active = true);


--
-- Name: idx_agent_daemon_config_agent_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_agent_daemon_config_agent_id ON public.agent_daemon_config USING btree (agent_id);


--
-- Name: idx_agent_memory_agent; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_agent_memory_agent ON public.agent_memory USING btree (agent_id);


--
-- Name: idx_akb_active_severity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_akb_active_severity ON public.agent_knowledge_base USING btree (active, severity);


--
-- Name: idx_akb_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_akb_category ON public.agent_knowledge_base USING btree (category);


--
-- Name: idx_approval_queue_pending; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_approval_queue_pending ON public.approval_queue USING btree (status) WHERE (status = 'pending'::text);


--
-- Name: idx_approval_queue_wo; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_approval_queue_wo ON public.approval_queue USING btree (work_order_id);


--
-- Name: idx_audit_log_actor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_actor ON public.audit_log USING btree (actor_type, actor_id);


--
-- Name: idx_audit_log_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_created ON public.audit_log USING btree (created_at DESC);


--
-- Name: idx_audit_log_target; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_target ON public.audit_log USING btree (target_type, target_id);


--
-- Name: idx_audit_log_wo; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_wo ON public.audit_log USING btree (work_order_id);


--
-- Name: idx_auto_approval_log_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_auto_approval_log_created_at ON public.auto_approval_log USING btree (created_at DESC);


--
-- Name: idx_auto_approval_log_decision; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_auto_approval_log_decision ON public.auto_approval_log USING btree (decision);


--
-- Name: idx_auto_approval_log_wo; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_auto_approval_log_wo ON public.auto_approval_log USING btree (work_order_id);


--
-- Name: idx_bypass_log_detected_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_bypass_log_detected_at ON public.bypass_log USING btree (detected_at DESC);


--
-- Name: idx_bypass_log_event_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_bypass_log_event_type ON public.bypass_log USING btree (event_type);


--
-- Name: idx_bypass_log_severity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_bypass_log_severity ON public.bypass_log USING btree (severity) WHERE (NOT resolved);


--
-- Name: idx_clarification_requests_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_clarification_requests_status ON public.clarification_requests USING btree (status) WHERE (status = 'pending'::text);


--
-- Name: idx_clarification_requests_work_order_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_clarification_requests_work_order_id ON public.clarification_requests USING btree (work_order_id);


--
-- Name: idx_conv_threads_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conv_threads_project ON public.conversation_threads USING btree (project_id);


--
-- Name: idx_conv_threads_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conv_threads_status ON public.conversation_threads USING btree (status);


--
-- Name: idx_conv_threads_updated; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conv_threads_updated ON public.conversation_threads USING btree (updated_at DESC);


--
-- Name: idx_conv_threads_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conv_threads_user ON public.conversation_threads USING btree (user_id);


--
-- Name: idx_conversation_threads_metadata; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conversation_threads_metadata ON public.conversation_threads USING gin (metadata);


--
-- Name: idx_conversations_external_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conversations_external_id ON public.conversations USING btree (external_id) WHERE (external_id IS NOT NULL);


--
-- Name: idx_conversations_intent_tags; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conversations_intent_tags ON public.conversations USING gin (intent_tags);


--
-- Name: idx_conversations_org; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conversations_org ON public.conversations USING btree (org) WHERE (org IS NOT NULL);


--
-- Name: idx_conversations_retrieval; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conversations_retrieval ON public.conversations USING btree (retrieval_count DESC, last_retrieved_at DESC);


--
-- Name: idx_conversations_search; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conversations_search ON public.conversations USING gin (to_tsvector('english'::regconfig, ((COALESCE(title, ''::text) || ' '::text) || COALESCE(summary, ''::text))));


--
-- Name: idx_conversations_source; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conversations_source ON public.conversations USING btree (source);


--
-- Name: idx_conversations_started_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_conversations_started_at ON public.conversations USING btree (started_at DESC);


--
-- Name: idx_daemon_heartbeats_last; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_daemon_heartbeats_last ON public.daemon_heartbeats USING btree (last_heartbeat DESC);


--
-- Name: idx_daemon_heartbeats_name; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_daemon_heartbeats_name ON public.daemon_heartbeats USING btree (daemon_name);


--
-- Name: idx_decisions_made_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_decisions_made_at ON public.decisions USING btree (made_at DESC);


--
-- Name: idx_decisions_org; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_decisions_org ON public.decisions USING btree (org) WHERE (org IS NOT NULL);


--
-- Name: idx_decisions_search; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_decisions_search ON public.decisions USING gin (to_tsvector('english'::regconfig, ((((subject || ' '::text) || choice) || ' '::text) || COALESCE(rationale, ''::text))));


--
-- Name: idx_decisions_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_decisions_status ON public.decisions USING btree (status);


--
-- Name: idx_decisions_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_decisions_type ON public.decisions USING btree (type);


--
-- Name: idx_directive_versions_directive; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_directive_versions_directive ON public.directive_versions USING btree (directive_id, version_number DESC);


--
-- Name: idx_directives_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_directives_active ON public.system_directives USING btree (active) WHERE (active = true);


--
-- Name: idx_directives_priority; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_directives_priority ON public.system_directives USING btree (priority);


--
-- Name: idx_directives_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_directives_project ON public.system_directives USING btree (project_id);


--
-- Name: idx_directives_scope; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_directives_scope ON public.system_directives USING btree (scope);


--
-- Name: idx_directives_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_directives_type ON public.system_directives USING btree (directive_type);


--
-- Name: idx_edge_function_tool_registry_defer; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_edge_function_tool_registry_defer ON public.edge_function_tool_registry USING btree (defer_loading);


--
-- Name: idx_edge_function_tool_registry_frequency; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_edge_function_tool_registry_frequency ON public.edge_function_tool_registry USING btree (usage_frequency);


--
-- Name: idx_enforcer_canary_timestamp; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_enforcer_canary_timestamp ON public.enforcer_canary USING btree (test_timestamp DESC);


--
-- Name: idx_enforcer_findings_run_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_enforcer_findings_run_id ON public.enforcer_findings USING btree (enforcer_run_id);


--
-- Name: idx_enforcer_findings_severity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_enforcer_findings_severity ON public.enforcer_findings USING btree (severity);


--
-- Name: idx_enforcer_findings_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_enforcer_findings_status ON public.enforcer_findings USING btree (status);


--
-- Name: idx_enforcer_findings_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_enforcer_findings_type ON public.enforcer_findings USING btree (finding_type);


--
-- Name: idx_enforcer_findings_wo; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_enforcer_findings_wo ON public.enforcer_findings USING btree (work_order_id);


--
-- Name: idx_enforcer_findings_wo_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_enforcer_findings_wo_id ON public.enforcer_findings USING btree (work_order_id);


--
-- Name: idx_enforcer_runs_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_enforcer_runs_created_at ON public.enforcer_runs USING btree (created_at DESC);


--
-- Name: idx_enforcer_runs_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_enforcer_runs_status ON public.enforcer_runs USING btree (status);


--
-- Name: idx_enforcer_runs_timestamp; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_enforcer_runs_timestamp ON public.enforcer_runs USING btree (run_timestamp DESC);


--
-- Name: idx_enforcer_runs_trigger_wo_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_enforcer_runs_trigger_wo_id ON public.enforcer_runs USING btree (trigger_wo_id);


--
-- Name: idx_entities_aliases; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_entities_aliases ON public.entities USING gin (aliases);


--
-- Name: idx_entities_name; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_entities_name ON public.entities USING btree (name);


--
-- Name: idx_entities_name_search; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_entities_name_search ON public.entities USING gin (to_tsvector('english'::regconfig, name));


--
-- Name: idx_entities_org; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_entities_org ON public.entities USING btree (org) WHERE (org IS NOT NULL);


--
-- Name: idx_entities_properties; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_entities_properties ON public.entities USING gin (properties);


--
-- Name: idx_entities_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_entities_type ON public.entities USING btree (type);


--
-- Name: idx_error_events_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_events_created_at ON public.error_events USING btree (created_at DESC);


--
-- Name: idx_error_events_error_code; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_events_error_code ON public.error_events USING btree (error_code) WHERE (error_code IS NOT NULL);


--
-- Name: idx_error_events_severity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_events_severity ON public.error_events USING btree (severity);


--
-- Name: idx_error_events_source_function; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_events_source_function ON public.error_events USING btree (source_function);


--
-- Name: idx_error_events_spike_detection; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_events_spike_detection ON public.error_events USING btree (error_code, created_at DESC) WHERE (error_code IS NOT NULL);


--
-- Name: idx_error_events_work_order_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_events_work_order_id ON public.error_events USING btree (work_order_id) WHERE (work_order_id IS NOT NULL);


--
-- Name: idx_evidence_bundles_execution_summary_gin; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_evidence_bundles_execution_summary_gin ON public.evidence_bundles USING gin (execution_summary);


--
-- Name: idx_evidence_bundles_generated_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_evidence_bundles_generated_at ON public.evidence_bundles USING btree (generated_at DESC);


--
-- Name: idx_evidence_bundles_qa_results_gin; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_evidence_bundles_qa_results_gin ON public.evidence_bundles USING gin (qa_results);


--
-- Name: idx_evidence_bundles_work_order_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_evidence_bundles_work_order_id ON public.evidence_bundles USING btree (work_order_id);


--
-- Name: idx_execution_log_chain_order; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_execution_log_chain_order ON public.work_order_execution_log USING btree (work_order_id, created_at);


--
-- Name: idx_execution_log_entry_hash; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_execution_log_entry_hash ON public.work_order_execution_log USING btree (entry_hash);


--
-- Name: idx_facts_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facts_category ON public.facts USING btree (category);


--
-- Name: idx_facts_object_entity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facts_object_entity ON public.facts USING btree (object_entity_id) WHERE (object_entity_id IS NOT NULL);


--
-- Name: idx_facts_predicate; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facts_predicate ON public.facts USING btree (predicate);


--
-- Name: idx_facts_subject_entity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facts_subject_entity ON public.facts USING btree (subject_entity_id) WHERE (subject_entity_id IS NOT NULL);


--
-- Name: idx_implementations_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_implementations_status ON public.implementations USING btree (status);


--
-- Name: idx_implementations_work_order; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_implementations_work_order ON public.implementations USING btree (work_order_id);


--
-- Name: idx_intake_log_classification; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_intake_log_classification ON public.intake_log USING btree (classification, created_at DESC);


--
-- Name: idx_intake_log_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_intake_log_created_at ON public.intake_log USING btree (created_at DESC);


--
-- Name: idx_intake_log_source; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_intake_log_source ON public.intake_log USING btree (source, created_at DESC);


--
-- Name: idx_interrogation_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_interrogation_project ON public.interrogation_sessions USING btree (project_id);


--
-- Name: idx_interrogation_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_interrogation_status ON public.interrogation_sessions USING btree (status);


--
-- Name: idx_langfuse_traces_session_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_langfuse_traces_session_id ON public.langfuse_traces USING btree (session_id);


--
-- Name: idx_langfuse_traces_thread_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_langfuse_traces_thread_id ON public.langfuse_traces USING btree (thread_id);


--
-- Name: idx_lesson_acks_decision; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_lesson_acks_decision ON public.lesson_acknowledgments USING btree (decision);


--
-- Name: idx_lesson_acks_lesson_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_lesson_acks_lesson_id ON public.lesson_acknowledgments USING btree (lesson_id);


--
-- Name: idx_lesson_acks_wo_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_lesson_acks_wo_id ON public.lesson_acknowledgments USING btree (work_order_id);


--
-- Name: idx_lessons_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_lessons_category ON public.lessons USING btree (category);


--
-- Name: idx_lessons_severity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_lessons_severity ON public.lessons USING btree (severity);


--
-- Name: idx_lessons_unpromoted; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_lessons_unpromoted ON public.lessons USING btree (applied_to_directives) WHERE (applied_to_directives = false);


--
-- Name: idx_lessons_unreviewed; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_lessons_unreviewed ON public.lessons USING btree (reviewed) WHERE (reviewed = false);


--
-- Name: idx_llm_provider_config_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_llm_provider_config_active ON public.llm_provider_config USING btree (is_active);


--
-- Name: idx_llm_provider_config_single_default; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_llm_provider_config_single_default ON public.llm_provider_config USING btree (is_default) WHERE (is_default = true);


--
-- Name: idx_llm_usage_agent; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_llm_usage_agent ON public.llm_usage USING btree (agent_id);


--
-- Name: idx_llm_usage_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_llm_usage_created_at ON public.llm_usage USING btree (created_at);


--
-- Name: idx_llm_usage_model; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_llm_usage_model ON public.llm_usage USING btree (model_id);


--
-- Name: idx_llm_usage_work_order; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_llm_usage_work_order ON public.llm_usage USING btree (work_order_id);


--
-- Name: idx_manifest_search; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_manifest_search ON public.system_manifest USING gin (search_vector);


--
-- Name: idx_manifest_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_manifest_status ON public.system_manifest USING btree (status);


--
-- Name: idx_manifest_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_manifest_type ON public.system_manifest USING btree (component_type);


--
-- Name: idx_metis_cap_type_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_metis_cap_type_status ON public.metis_capabilities USING btree (capability_type, status);


--
-- Name: idx_model_capabilities_available; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_model_capabilities_available ON public.model_capabilities USING btree (is_available) WHERE (is_available = true);


--
-- Name: idx_model_capabilities_provider; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_model_capabilities_provider ON public.model_capabilities USING btree (provider);


--
-- Name: idx_model_pricing_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_model_pricing_date ON public.model_pricing USING btree (effective_date DESC);


--
-- Name: idx_model_pricing_model; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_model_pricing_model ON public.model_pricing USING btree (model_id);


--
-- Name: idx_monitor_triage_severity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_monitor_triage_severity ON public.monitor_triage_queue USING btree (severity, created_at DESC);


--
-- Name: idx_monitor_triage_unresolved; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_monitor_triage_unresolved ON public.monitor_triage_queue USING btree (resolved_at) WHERE (resolved_at IS NULL);


--
-- Name: idx_monitor_triage_wo; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_monitor_triage_wo ON public.monitor_triage_queue USING btree (wo_id);


--
-- Name: idx_object_links_source; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_object_links_source ON public.object_links USING btree (source_id);


--
-- Name: idx_object_links_target; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_object_links_target ON public.object_links USING btree (target_id);


--
-- Name: idx_object_links_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_object_links_type ON public.object_links USING btree (link_type);


--
-- Name: idx_object_registry_name; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_object_registry_name ON public.object_registry USING btree (object_name);


--
-- Name: idx_object_registry_parent; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_object_registry_parent ON public.object_registry USING btree (parent_id) WHERE (parent_id IS NOT NULL);


--
-- Name: idx_object_registry_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_object_registry_type ON public.object_registry USING btree (object_type);


--
-- Name: idx_oss_tools_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_oss_tools_category ON public.open_source_tools USING btree (category);


--
-- Name: idx_oss_tools_relevance; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_oss_tools_relevance ON public.open_source_tools USING btree (relevance_score DESC);


--
-- Name: idx_pending_migrations_sequence; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_pending_migrations_sequence ON public.pending_migrations USING btree (sequence);


--
-- Name: idx_pending_migrations_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_pending_migrations_status ON public.pending_migrations USING btree (status);


--
-- Name: idx_pending_migrations_wo; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_pending_migrations_wo ON public.pending_migrations USING btree (work_order_id);


--
-- Name: idx_pipeline_runs_spec_wo; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_pipeline_runs_spec_wo ON public.pipeline_runs USING btree (spec_wo_id);


--
-- Name: idx_pipeline_runs_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_pipeline_runs_status ON public.pipeline_runs USING btree (status);


--
-- Name: idx_platform_health_snapshots_snapshot_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_platform_health_snapshots_snapshot_at ON public.platform_health_snapshots USING btree (snapshot_at DESC);


--
-- Name: idx_preferences_key; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_preferences_key ON public.preferences USING btree (key);


--
-- Name: idx_preferences_scope; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_preferences_scope ON public.preferences USING btree (scope);


--
-- Name: idx_preferences_scope_key; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_preferences_scope_key ON public.preferences USING btree (scope, key);


--
-- Name: idx_project_briefs_code; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_project_briefs_code ON public.project_briefs USING btree (code);


--
-- Name: idx_project_briefs_search; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_project_briefs_search ON public.project_briefs USING gin (search_vector);


--
-- Name: idx_project_briefs_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_project_briefs_status ON public.project_briefs USING btree (status);


--
-- Name: idx_project_context_name; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_project_context_name ON public.project_context USING btree (project_name);


--
-- Name: idx_project_context_project_name; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_project_context_project_name ON public.project_context USING btree (project_name);


--
-- Name: idx_project_context_updated; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_project_context_updated ON public.project_context USING btree (updated_at DESC);


--
-- Name: idx_project_docs_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_project_docs_active ON public.project_documents USING btree (project_id, doc_type) WHERE (status <> 'superseded'::text);


--
-- Name: idx_project_docs_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_project_docs_project ON public.project_documents USING btree (project_id);


--
-- Name: idx_project_docs_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_project_docs_type ON public.project_documents USING btree (doc_type);


--
-- Name: idx_qa_findings_checklist_item; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_qa_findings_checklist_item ON public.qa_findings USING btree (checklist_item_id) WHERE (checklist_item_id IS NOT NULL);


--
-- Name: idx_qa_findings_error_code; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_qa_findings_error_code ON public.qa_findings USING btree (error_code) WHERE (error_code IS NOT NULL);


--
-- Name: idx_rate_limit_log_agent; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_rate_limit_log_agent ON public.rate_limit_log USING btree (agent_id, created_at DESC);


--
-- Name: idx_rate_limit_log_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_rate_limit_log_created ON public.rate_limit_log USING btree (created_at DESC);


--
-- Name: idx_regression_suite_runs_alert; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_regression_suite_runs_alert ON public.regression_suite_runs USING btree (alert_triggered) WHERE (alert_triggered = true);


--
-- Name: idx_regression_suite_runs_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_regression_suite_runs_status ON public.regression_suite_runs USING btree (status);


--
-- Name: idx_regression_suite_runs_timestamp; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_regression_suite_runs_timestamp ON public.regression_suite_runs USING btree (run_timestamp DESC);


--
-- Name: idx_routing_rules_priority; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_routing_rules_priority ON public.routing_rules USING btree (priority) WHERE (enabled = true);


--
-- Name: idx_run_scorecards_overall_score; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_run_scorecards_overall_score ON public.run_scorecards USING btree (overall_score DESC);


--
-- Name: idx_run_scorecards_scored_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_run_scorecards_scored_at ON public.run_scorecards USING btree (scored_at DESC);


--
-- Name: idx_run_scorecards_work_order_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_run_scorecards_work_order_id ON public.run_scorecards USING btree (work_order_id);


--
-- Name: idx_sandbox_executions_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_sandbox_executions_created_at ON public.sandbox_executions USING btree (created_at);


--
-- Name: idx_sandbox_executions_work_order_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_sandbox_executions_work_order_id ON public.sandbox_executions USING btree (work_order_id);


--
-- Name: idx_scaffold_contracts_object; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_scaffold_contracts_object ON public.scaffold_contracts USING btree (object_id);


--
-- Name: idx_scaffold_contracts_run; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_scaffold_contracts_run ON public.scaffold_contracts USING btree (pipeline_run_id);


--
-- Name: idx_schema_changes_object; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_schema_changes_object ON public.schema_changes USING btree (object_name, created_at DESC);


--
-- Name: idx_spans_agent; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_spans_agent ON public.spans USING btree (agent_id);


--
-- Name: idx_spans_model; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_spans_model ON public.spans USING btree (model) WHERE (model IS NOT NULL);


--
-- Name: idx_spans_started_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_spans_started_at ON public.spans USING btree (started_at);


--
-- Name: idx_spans_trace; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_spans_trace ON public.spans USING btree (trace_id);


--
-- Name: idx_spans_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_spans_type ON public.spans USING btree (span_type);


--
-- Name: idx_state_mutations_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_state_mutations_created ON public.state_mutations USING btree (created_at DESC);


--
-- Name: idx_state_mutations_target; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_state_mutations_target ON public.state_mutations USING btree (target_table, target_id);


--
-- Name: idx_state_mutations_wo; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_state_mutations_wo ON public.state_mutations USING btree (work_order_id);


--
-- Name: idx_team_context_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_team_context_created ON public.team_context USING btree (created_at DESC);


--
-- Name: idx_team_context_root_wo; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_team_context_root_wo ON public.team_context USING btree (root_wo_id);


--
-- Name: idx_team_context_source_wo; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_team_context_source_wo ON public.team_context USING btree (source_wo_id);


--
-- Name: idx_team_context_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_team_context_type ON public.team_context USING btree (context_type);


--
-- Name: idx_thread_msgs_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_thread_msgs_created ON public.thread_messages USING btree (created_at);


--
-- Name: idx_thread_msgs_embedding; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_thread_msgs_embedding ON public.thread_messages USING ivfflat (embedding public.vector_cosine_ops) WITH (lists='100');


--
-- Name: idx_thread_msgs_role; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_thread_msgs_role ON public.thread_messages USING btree (role);


--
-- Name: idx_thread_msgs_thread; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_thread_msgs_thread ON public.thread_messages USING btree (thread_id);


--
-- Name: idx_traces_session; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_traces_session ON public.traces USING btree (session_id);


--
-- Name: idx_traces_started_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_traces_started_at ON public.traces USING btree (started_at);


--
-- Name: idx_traces_thread; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_traces_thread ON public.traces USING btree (thread_id);


--
-- Name: idx_traces_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_traces_user ON public.traces USING btree (user_id);


--
-- Name: idx_traces_wo; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_traces_wo ON public.traces USING btree (work_order_id);


--
-- Name: idx_transcripts_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_transcripts_created ON public.transcripts USING btree (created_at DESC);


--
-- Name: idx_transcripts_hash; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_transcripts_hash ON public.transcripts USING btree (input_hash);


--
-- Name: idx_transcripts_model; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_transcripts_model ON public.transcripts USING btree (routed_model);


--
-- Name: idx_transcripts_satisfaction; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_transcripts_satisfaction ON public.transcripts USING btree (user_satisfaction) WHERE (user_satisfaction IS NOT NULL);


--
-- Name: idx_transcripts_session; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_transcripts_session ON public.transcripts USING btree (session_id) WHERE (session_id IS NOT NULL);


--
-- Name: idx_transcripts_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_transcripts_status ON public.transcripts USING btree (status);


--
-- Name: idx_transcripts_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_transcripts_user ON public.transcripts USING btree (user_id);


--
-- Name: idx_triage_queue_severity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_triage_queue_severity ON public.monitor_triage_queue USING btree (severity, created_at DESC);


--
-- Name: idx_triage_queue_unresolved; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_triage_queue_unresolved ON public.monitor_triage_queue USING btree (resolved_at) WHERE (resolved_at IS NULL);


--
-- Name: idx_triage_queue_wo_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_triage_queue_wo_id ON public.monitor_triage_queue USING btree (wo_id);


--
-- Name: idx_user_preferences_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_preferences_category ON public.user_preferences USING btree (category);


--
-- Name: idx_user_preferences_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_preferences_user_id ON public.user_preferences USING btree (user_id);


--
-- Name: idx_value_types_applicable_columns; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_value_types_applicable_columns ON public.value_types USING gin (applicable_columns);


--
-- Name: idx_value_types_type_name; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_value_types_type_name ON public.value_types USING btree (type_name);


--
-- Name: idx_verification_log_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_verification_log_created_at ON public.verification_log USING btree (created_at);


--
-- Name: idx_verification_log_work_order; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_verification_log_work_order ON public.verification_log USING btree (work_order_id);


--
-- Name: idx_wo_batches_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_batches_created_at ON public.wo_batches USING btree (created_at);


--
-- Name: idx_wo_batches_execution_mode; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_batches_execution_mode ON public.wo_batches USING btree (execution_mode);


--
-- Name: idx_wo_batches_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_batches_project ON public.wo_batches USING btree (project_brief_id);


--
-- Name: idx_wo_batches_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_batches_status ON public.wo_batches USING btree (status);


--
-- Name: idx_wo_effects_pending; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_effects_pending ON public.wo_effects USING btree (status, created_at) WHERE (status = 'pending'::text);


--
-- Name: idx_wo_effects_wo_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_effects_wo_id ON public.wo_effects USING btree (work_order_id);


--
-- Name: idx_wo_event_stream_occurred; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_event_stream_occurred ON public.wo_event_stream USING btree (occurred_at);


--
-- Name: idx_wo_event_stream_replay; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_event_stream_replay ON public.wo_event_stream USING btree (stream_id, version);


--
-- Name: idx_wo_events_archive_archived_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_events_archive_archived_at ON public.wo_events_archive USING btree (archived_at);


--
-- Name: idx_wo_events_archive_event_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_events_archive_event_type ON public.wo_events_archive USING btree (event_type);


--
-- Name: idx_wo_events_archive_work_order_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_events_archive_work_order_id ON public.wo_events_archive USING btree (work_order_id);


--
-- Name: idx_wo_events_status_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_events_status_created ON public.wo_events USING btree (status, created_at) WHERE (status = 'pending'::text);


--
-- Name: idx_wo_events_wo_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_events_wo_created ON public.wo_events USING btree (work_order_id, created_at);


--
-- Name: idx_wo_exec_log_phase; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_exec_log_phase ON public.work_order_execution_log USING btree (phase, created_at DESC);


--
-- Name: idx_wo_exec_log_work_order; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_exec_log_work_order ON public.work_order_execution_log USING btree (work_order_id, created_at DESC);


--
-- Name: idx_wo_execution_manifest_work_order_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_execution_manifest_work_order_id ON public.wo_execution_manifest USING btree (work_order_id);


--
-- Name: idx_wo_execution_rank; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_execution_rank ON public.work_orders USING btree (execution_rank, priority, created_at) WHERE (status = ANY (ARRAY['draft'::public.work_order_status, 'ready'::public.work_order_status, 'in_progress'::public.work_order_status]));


--
-- Name: idx_wo_file_locks_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_file_locks_active ON public.wo_file_locks USING btree (file_path) WHERE (released_at IS NULL);


--
-- Name: idx_wo_mutations_error_class; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_mutations_error_class ON public.wo_mutations USING btree (error_class) WHERE (error_class IS NOT NULL);


--
-- Name: idx_wo_mutations_wo_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wo_mutations_wo_created ON public.wo_mutations USING btree (work_order_id, created_at);


--
-- Name: idx_work_orders_assigned; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_assigned ON public.work_orders USING btree (assigned_to_legacy);


--
-- Name: idx_work_orders_batch_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_batch_id ON public.work_orders USING btree (batch_id);


--
-- Name: idx_work_orders_design_doc_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_design_doc_id ON public.work_orders USING btree (design_doc_id);


--
-- Name: idx_work_orders_enforcer_verified; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_enforcer_verified ON public.work_orders USING btree (enforcer_verified);


--
-- Name: idx_work_orders_parent_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_parent_id ON public.work_orders USING btree (parent_id) WHERE (parent_id IS NOT NULL);


--
-- Name: idx_work_orders_pipeline_phase; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_pipeline_phase ON public.work_orders USING btree (pipeline_phase) WHERE (pipeline_phase IS NOT NULL);


--
-- Name: idx_work_orders_pipeline_run; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_pipeline_run ON public.work_orders USING btree (pipeline_run_id) WHERE (pipeline_run_id IS NOT NULL);


--
-- Name: idx_work_orders_priority; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_priority ON public.work_orders USING btree (priority, created_at);


--
-- Name: idx_work_orders_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_project ON public.work_orders USING btree (project_brief_id);


--
-- Name: idx_work_orders_qa_checklist; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_qa_checklist ON public.work_orders USING gin (qa_checklist);


--
-- Name: idx_work_orders_slug; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_slug ON public.work_orders USING btree (slug);


--
-- Name: idx_work_orders_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_work_orders_status ON public.work_orders USING btree (status);


--
-- Name: idx_workspace_events_agent; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_workspace_events_agent ON public.workspace_events USING btree (agent_id);


--
-- Name: idx_workspace_events_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_workspace_events_created ON public.workspace_events USING btree (created_at DESC);


--
-- Name: idx_workspace_events_work_order; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_workspace_events_work_order ON public.workspace_events USING btree (work_order_id);


--
-- Name: idx_workspace_locks_expires; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_workspace_locks_expires ON public.workspace_locks USING btree (expires_at);


--
-- Name: idx_workspace_locks_resource; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_workspace_locks_resource ON public.workspace_locks USING btree (resource_type, resource_id);


--
-- Name: object_action_rates_action; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX object_action_rates_action ON public.object_action_rates USING btree (action);


--
-- Name: object_action_rates_lookup; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX object_action_rates_lookup ON public.object_action_rates USING btree (target_identifier, tool_name, action);


--
-- Name: kernel_spec kernel_spec_no_delete; Type: RULE; Schema: public; Owner: -
--

CREATE RULE kernel_spec_no_delete AS
    ON DELETE TO public.kernel_spec DO INSTEAD NOTHING;


--
-- Name: kernel_spec kernel_spec_no_update; Type: RULE; Schema: public; Owner: -
--

CREATE RULE kernel_spec_no_update AS
    ON UPDATE TO public.kernel_spec DO INSTEAD NOTHING;


--
-- Name: wo_event_stream wo_event_stream_no_delete; Type: RULE; Schema: public; Owner: -
--

CREATE RULE wo_event_stream_no_delete AS
    ON DELETE TO public.wo_event_stream DO INSTEAD NOTHING;


--
-- Name: wo_event_stream wo_event_stream_no_update; Type: RULE; Schema: public; Owner: -
--

CREATE RULE wo_event_stream_no_update AS
    ON UPDATE TO public.wo_event_stream DO INSTEAD NOTHING;


--
-- Name: agent_daemon_config agent_daemon_config_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER agent_daemon_config_updated_at BEFORE UPDATE ON public.agent_daemon_config FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: regression_suite_runs create_regression_alert; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER create_regression_alert AFTER INSERT ON public.regression_suite_runs FOR EACH ROW EXECUTE FUNCTION public.trg_create_regression_alert();


--
-- Name: decisions enforce_state_write_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER enforce_state_write_trigger BEFORE INSERT OR DELETE OR UPDATE ON public.decisions FOR EACH ROW EXECUTE FUNCTION public.enforce_state_write();


--
-- Name: schema_changes enforce_state_write_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER enforce_state_write_trigger BEFORE INSERT OR DELETE OR UPDATE ON public.schema_changes FOR EACH ROW EXECUTE FUNCTION public.enforce_state_write();


--
-- Name: system_manifest enforce_state_write_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER enforce_state_write_trigger BEFORE INSERT OR DELETE OR UPDATE ON public.system_manifest FOR EACH ROW EXECUTE FUNCTION public.enforce_state_write();


--
-- Name: work_orders enforce_wo_state_changes_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER enforce_wo_state_changes_trigger BEFORE UPDATE ON public.work_orders FOR EACH ROW EXECUTE FUNCTION public.enforce_wo_state_changes();


--
-- Name: implementations implementations_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER implementations_updated_at BEFORE UPDATE ON public.implementations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: wo_mutations prevent_mutation_tampering; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER prevent_mutation_tampering BEFORE DELETE OR UPDATE ON public.wo_mutations FOR EACH ROW EXECUTE FUNCTION public.prevent_mutation_tampering();


--
-- Name: project_briefs project_briefs_generate_docs; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER project_briefs_generate_docs AFTER INSERT ON public.project_briefs FOR EACH ROW EXECUTE FUNCTION public.generate_project_documents();


--
-- Name: error_definitions set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.error_definitions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: work_orders set_wo_source_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER set_wo_source_trigger BEFORE INSERT ON public.work_orders FOR EACH ROW EXECUTE FUNCTION public.set_work_order_source();


--
-- Name: implementations sync_implementations_to_notion; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_implementations_to_notion AFTER INSERT OR UPDATE ON public.implementations FOR EACH ROW EXECUTE FUNCTION public.notify_notion_sync();


--
-- Name: work_orders trg_aa_pre_auto_close_approval; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_aa_pre_auto_close_approval BEFORE UPDATE ON public.work_orders FOR EACH ROW WHEN ((new.status = 'review'::public.work_order_status)) EXECUTE FUNCTION public.pre_auto_close_insert_approval();


--
-- Name: schema_changes trg_after_schema_change_generate_docs; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_after_schema_change_generate_docs AFTER INSERT ON public.schema_changes FOR EACH ROW EXECUTE FUNCTION public.trg_auto_generate_backend_docs();


--
-- Name: TRIGGER trg_after_schema_change_generate_docs ON schema_changes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TRIGGER trg_after_schema_change_generate_docs ON public.schema_changes IS 'Automatically regenerates backend docs on DDL migrations';


--
-- Name: audit_log trg_audit_log_immutable; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_audit_log_immutable BEFORE DELETE OR UPDATE ON public.audit_log FOR EACH ROW EXECUTE FUNCTION public.audit_log_immutable();


--
-- Name: spans trg_auto_lesson_on_error_span; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_auto_lesson_on_error_span AFTER INSERT OR UPDATE OF status ON public.spans FOR EACH ROW WHEN ((new.status = 'error'::text)) EXECUTE FUNCTION public.create_lesson_from_error_span();


--
-- Name: lessons trg_auto_promote_critical_lesson; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_auto_promote_critical_lesson AFTER INSERT ON public.lessons FOR EACH ROW WHEN ((new.severity = 'critical'::text)) EXECUTE FUNCTION public.auto_promote_critical_lesson();


--
-- Name: lessons trg_auto_sync_lesson_to_kb; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_auto_sync_lesson_to_kb AFTER INSERT OR UPDATE OF promoted_at ON public.lessons FOR EACH ROW EXECUTE FUNCTION public.trg_sync_lesson_to_kb();


--
-- Name: work_order_execution_log trg_calculate_execution_log_hash; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_calculate_execution_log_hash BEFORE INSERT ON public.work_order_execution_log FOR EACH ROW EXECUTE FUNCTION public.calculate_execution_log_hash();


--
-- Name: project_documents trg_check_intake_complete; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_check_intake_complete AFTER INSERT OR UPDATE OF status ON public.project_documents FOR EACH ROW EXECUTE FUNCTION public.check_and_set_intake_complete();


--
-- Name: agent_execution_profiles trg_config_guard_agent_execution_profiles; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_config_guard_agent_execution_profiles BEFORE UPDATE ON public.agent_execution_profiles FOR EACH ROW EXECUTE FUNCTION public.config_mutation_guard_check();


--
-- Name: agents trg_config_guard_agents; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_config_guard_agents BEFORE UPDATE ON public.agents FOR EACH ROW EXECUTE FUNCTION public.config_mutation_guard_check();


--
-- Name: llm_provider_config trg_config_guard_llm_provider_config; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_config_guard_llm_provider_config BEFORE UPDATE ON public.llm_provider_config FOR EACH ROW EXECUTE FUNCTION public.config_mutation_guard_check();


--
-- Name: system_settings trg_config_guard_system_settings; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_config_guard_system_settings BEFORE UPDATE ON public.system_settings FOR EACH ROW EXECUTE FUNCTION public.config_mutation_guard_check();


--
-- Name: project_briefs trg_new_project_interrogation; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_new_project_interrogation AFTER INSERT ON public.project_briefs FOR EACH ROW EXECUTE FUNCTION public.trigger_project_interrogation();


--
-- Name: lessons trg_prevent_duplicate_lesson; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_prevent_duplicate_lesson BEFORE INSERT ON public.lessons FOR EACH ROW EXECUTE FUNCTION public.prevent_duplicate_lesson();


--
-- Name: wo_effects trg_process_effect_on_insert; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_process_effect_on_insert AFTER INSERT ON public.wo_effects FOR EACH ROW WHEN ((new.status = 'pending'::text)) EXECUTE FUNCTION public.process_effect_on_insert();


--
-- Name: qa_findings trg_recheck_auto_close_on_findings_resolved; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_recheck_auto_close_on_findings_resolved AFTER UPDATE ON public.qa_findings FOR EACH ROW EXECUTE FUNCTION public.recheck_auto_close_on_findings_resolved();


--
-- Name: work_orders trg_release_locks_on_wo_done; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_release_locks_on_wo_done AFTER UPDATE ON public.work_orders FOR EACH ROW EXECUTE FUNCTION public.release_locks_on_wo_done();


--
-- Name: schema_changes trg_schema_change_auto_docs; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_schema_change_auto_docs AFTER INSERT ON public.schema_changes FOR EACH ROW EXECUTE FUNCTION public.trg_auto_regenerate_backend_docs();


--
-- Name: TRIGGER trg_schema_change_auto_docs ON schema_changes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TRIGGER trg_schema_change_auto_docs ON public.schema_changes IS 'Auto-regenerates backend structure docs when schema changes are recorded';


--
-- Name: traces trg_traces_append_only; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_traces_append_only BEFORE DELETE OR UPDATE ON public.traces FOR EACH ROW EXECUTE FUNCTION public.enforce_append_only();


--
-- Name: thread_messages trg_update_thread_stats; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_update_thread_stats AFTER INSERT ON public.thread_messages FOR EACH ROW EXECUTE FUNCTION public.update_thread_stats();


--
-- Name: lessons trg_update_wo_lesson_count; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_update_wo_lesson_count AFTER INSERT ON public.lessons FOR EACH ROW EXECUTE FUNCTION public.update_wo_lesson_count();


--
-- Name: wo_batches trg_wo_batches_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_wo_batches_updated_at BEFORE UPDATE ON public.wo_batches FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: state_mutations trigger_auto_update_project_docs_on_manifest; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_auto_update_project_docs_on_manifest AFTER INSERT ON public.state_mutations FOR EACH ROW WHEN ((new.target_table = 'system_manifest'::text)) EXECUTE FUNCTION public.auto_update_project_docs_on_manifest();


--
-- Name: TRIGGER trigger_auto_update_project_docs_on_manifest ON state_mutations; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TRIGGER trigger_auto_update_project_docs_on_manifest ON public.state_mutations IS 'WO-0009/AC1: Automatically updates project_documents.updated_at when system_manifest mutations occur, ensuring doc currency check stays accurate without manual intervention';


--
-- Name: conversations trigger_conversations_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_conversations_updated_at BEFORE UPDATE ON public.conversations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: decisions trigger_decisions_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_decisions_updated_at BEFORE UPDATE ON public.decisions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: entities trigger_entities_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_entities_updated_at BEFORE UPDATE ON public.entities FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: preferences trigger_preferences_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_preferences_updated_at BEFORE UPDATE ON public.preferences FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: project_context trigger_project_context_updated; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_project_context_updated BEFORE UPDATE ON public.project_context FOR EACH ROW EXECUTE FUNCTION public.update_project_context_timestamp();


--
-- Name: project_context trigger_project_context_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_project_context_updated_at BEFORE UPDATE ON public.project_context FOR EACH ROW EXECUTE FUNCTION public.update_project_context_updated_at();


--
-- Name: system_manifest trigger_sync_docs_on_manifest_change; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_sync_docs_on_manifest_change AFTER INSERT OR DELETE OR UPDATE ON public.system_manifest FOR EACH STATEMENT EXECUTE FUNCTION public.auto_update_project_documents_on_manifest_change();


--
-- Name: evidence_bundles update_evidence_bundles_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_evidence_bundles_updated_at BEFORE UPDATE ON public.evidence_bundles FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: model_capabilities update_model_capabilities_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_model_capabilities_updated_at BEFORE UPDATE ON public.model_capabilities FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: project_briefs update_project_briefs_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_project_briefs_updated_at BEFORE UPDATE ON public.project_briefs FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: regression_suite_definitions update_regression_suite_definitions_timestamp; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_regression_suite_definitions_timestamp BEFORE UPDATE ON public.regression_suite_definitions FOR EACH ROW EXECUTE FUNCTION public.trg_update_regression_suite_definitions_timestamp();


--
-- Name: routing_rules update_routing_rules_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_routing_rules_updated_at BEFORE UPDATE ON public.routing_rules FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: work_orders work_orders_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER work_orders_updated_at BEFORE UPDATE ON public.work_orders FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: agent_daemon_config agent_daemon_config_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_daemon_config
    ADD CONSTRAINT agent_daemon_config_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id) ON DELETE CASCADE;


--
-- Name: agent_execution_profiles agent_execution_profiles_agent_name_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_execution_profiles
    ADD CONSTRAINT agent_execution_profiles_agent_name_fkey FOREIGN KEY (agent_name) REFERENCES public.agents(name) ON UPDATE CASCADE;


--
-- Name: agent_quotas agent_quotas_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agent_quotas
    ADD CONSTRAINT agent_quotas_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id);


--
-- Name: agents agents_escalation_target_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.agents
    ADD CONSTRAINT agents_escalation_target_fkey FOREIGN KEY (escalation_target) REFERENCES public.agents(id);


--
-- Name: approval_queue approval_queue_gate_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.approval_queue
    ADD CONSTRAINT approval_queue_gate_id_fkey FOREIGN KEY (gate_id) REFERENCES public.decision_gates(id);


--
-- Name: approval_queue approval_queue_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.approval_queue
    ADD CONSTRAINT approval_queue_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: audit_log audit_log_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT audit_log_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: auto_approval_log auto_approval_log_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.auto_approval_log
    ADD CONSTRAINT auto_approval_log_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: clarification_requests clarification_requests_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.clarification_requests
    ADD CONSTRAINT clarification_requests_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: consensus_votes consensus_votes_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.consensus_votes
    ADD CONSTRAINT consensus_votes_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id);


--
-- Name: consensus_votes consensus_votes_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.consensus_votes
    ADD CONSTRAINT consensus_votes_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: conversation_threads conversation_threads_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.conversation_threads
    ADD CONSTRAINT conversation_threads_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.project_briefs(id);


--
-- Name: decisions decisions_source_conversation_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.decisions
    ADD CONSTRAINT decisions_source_conversation_id_fkey FOREIGN KEY (source_conversation_id) REFERENCES public.conversations(id) ON DELETE SET NULL;


--
-- Name: decisions decisions_source_message_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.decisions
    ADD CONSTRAINT decisions_source_message_id_fkey FOREIGN KEY (source_message_id) REFERENCES public.thread_messages(id) ON DELETE SET NULL;


--
-- Name: decisions decisions_superseded_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.decisions
    ADD CONSTRAINT decisions_superseded_by_fkey FOREIGN KEY (superseded_by) REFERENCES public.decisions(id) ON DELETE SET NULL;


--
-- Name: decisions decisions_supersedes_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.decisions
    ADD CONSTRAINT decisions_supersedes_fkey FOREIGN KEY (supersedes) REFERENCES public.decisions(id) ON DELETE SET NULL;


--
-- Name: directive_versions directive_versions_directive_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.directive_versions
    ADD CONSTRAINT directive_versions_directive_id_fkey FOREIGN KEY (directive_id) REFERENCES public.system_directives(id);


--
-- Name: directive_versions directive_versions_lesson_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.directive_versions
    ADD CONSTRAINT directive_versions_lesson_id_fkey FOREIGN KEY (lesson_id) REFERENCES public.lessons(id);


--
-- Name: enforcer_findings enforcer_findings_enforcer_run_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.enforcer_findings
    ADD CONSTRAINT enforcer_findings_enforcer_run_id_fkey FOREIGN KEY (enforcer_run_id) REFERENCES public.enforcer_runs(id) ON DELETE CASCADE;


--
-- Name: enforcer_runs enforcer_runs_trigger_wo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.enforcer_runs
    ADD CONSTRAINT enforcer_runs_trigger_wo_id_fkey FOREIGN KEY (trigger_wo_id) REFERENCES public.work_orders(id) ON DELETE SET NULL;


--
-- Name: entities entities_source_conversation_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.entities
    ADD CONSTRAINT entities_source_conversation_id_fkey FOREIGN KEY (source_conversation_id) REFERENCES public.conversations(id) ON DELETE SET NULL;


--
-- Name: error_events error_events_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.error_events
    ADD CONSTRAINT error_events_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id);


--
-- Name: error_events error_events_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.error_events
    ADD CONSTRAINT error_events_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: evidence_bundles evidence_bundles_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.evidence_bundles
    ADD CONSTRAINT evidence_bundles_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: facts facts_object_entity_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facts
    ADD CONSTRAINT facts_object_entity_id_fkey FOREIGN KEY (object_entity_id) REFERENCES public.entities(id) ON DELETE SET NULL;


--
-- Name: facts facts_source_conversation_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facts
    ADD CONSTRAINT facts_source_conversation_id_fkey FOREIGN KEY (source_conversation_id) REFERENCES public.conversations(id) ON DELETE SET NULL;


--
-- Name: facts facts_source_message_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facts
    ADD CONSTRAINT facts_source_message_id_fkey FOREIGN KEY (source_message_id) REFERENCES public.thread_messages(id) ON DELETE SET NULL;


--
-- Name: facts facts_subject_entity_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facts
    ADD CONSTRAINT facts_subject_entity_id_fkey FOREIGN KEY (subject_entity_id) REFERENCES public.entities(id) ON DELETE CASCADE;


--
-- Name: implementations implementations_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.implementations
    ADD CONSTRAINT implementations_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: intake_log intake_log_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.intake_log
    ADD CONSTRAINT intake_log_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: interface_implementations interface_implementations_interface_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.interface_implementations
    ADD CONSTRAINT interface_implementations_interface_id_fkey FOREIGN KEY (interface_id) REFERENCES public.ontology_interfaces(id) ON DELETE CASCADE;


--
-- Name: interface_implementations interface_implementations_object_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.interface_implementations
    ADD CONSTRAINT interface_implementations_object_id_fkey FOREIGN KEY (object_id) REFERENCES public.object_registry(id) ON DELETE CASCADE;


--
-- Name: interrogation_sessions interrogation_sessions_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.interrogation_sessions
    ADD CONSTRAINT interrogation_sessions_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.project_briefs(id);


--
-- Name: interrogation_sessions interrogation_sessions_thread_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.interrogation_sessions
    ADD CONSTRAINT interrogation_sessions_thread_id_fkey FOREIGN KEY (thread_id) REFERENCES public.conversation_threads(id);


--
-- Name: interrogation_sessions interrogation_sessions_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.interrogation_sessions
    ADD CONSTRAINT interrogation_sessions_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: langfuse_traces langfuse_traces_thread_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.langfuse_traces
    ADD CONSTRAINT langfuse_traces_thread_id_fkey FOREIGN KEY (thread_id) REFERENCES public.conversation_threads(id);


--
-- Name: lesson_acknowledgments lesson_acknowledgments_lesson_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.lesson_acknowledgments
    ADD CONSTRAINT lesson_acknowledgments_lesson_id_fkey FOREIGN KEY (lesson_id) REFERENCES public.lessons(id) ON DELETE CASCADE;


--
-- Name: lesson_acknowledgments lesson_acknowledgments_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.lesson_acknowledgments
    ADD CONSTRAINT lesson_acknowledgments_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: lessons lessons_directive_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.lessons
    ADD CONSTRAINT lessons_directive_id_fkey FOREIGN KEY (directive_id) REFERENCES public.system_directives(id);


--
-- Name: lessons lessons_thread_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.lessons
    ADD CONSTRAINT lessons_thread_id_fkey FOREIGN KEY (thread_id) REFERENCES public.conversation_threads(id);


--
-- Name: lessons lessons_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.lessons
    ADD CONSTRAINT lessons_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: llm_usage llm_usage_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.llm_usage
    ADD CONSTRAINT llm_usage_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id);


--
-- Name: llm_usage llm_usage_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.llm_usage
    ADD CONSTRAINT llm_usage_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: model_pricing model_pricing_model_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.model_pricing
    ADD CONSTRAINT model_pricing_model_id_fkey FOREIGN KEY (model_id) REFERENCES public.model_capabilities(model_id) ON DELETE CASCADE;


--
-- Name: monitor_triage_queue monitor_triage_queue_wo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.monitor_triage_queue
    ADD CONSTRAINT monitor_triage_queue_wo_id_fkey FOREIGN KEY (wo_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: object_links object_links_source_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.object_links
    ADD CONSTRAINT object_links_source_id_fkey FOREIGN KEY (source_id) REFERENCES public.object_registry(id) ON DELETE CASCADE;


--
-- Name: object_links object_links_target_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.object_links
    ADD CONSTRAINT object_links_target_id_fkey FOREIGN KEY (target_id) REFERENCES public.object_registry(id) ON DELETE CASCADE;


--
-- Name: object_registry object_registry_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.object_registry
    ADD CONSTRAINT object_registry_parent_id_fkey FOREIGN KEY (parent_id) REFERENCES public.object_registry(id);


--
-- Name: pending_migrations pending_migrations_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pending_migrations
    ADD CONSTRAINT pending_migrations_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: pipeline_runs pipeline_runs_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pipeline_runs
    ADD CONSTRAINT pipeline_runs_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id);


--
-- Name: pipeline_runs pipeline_runs_spec_wo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pipeline_runs
    ADD CONSTRAINT pipeline_runs_spec_wo_id_fkey FOREIGN KEY (spec_wo_id) REFERENCES public.work_orders(id);


--
-- Name: preferences preferences_source_conversation_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.preferences
    ADD CONSTRAINT preferences_source_conversation_id_fkey FOREIGN KEY (source_conversation_id) REFERENCES public.conversations(id) ON DELETE SET NULL;


--
-- Name: project_documents project_documents_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_documents
    ADD CONSTRAINT project_documents_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.project_briefs(id) ON DELETE CASCADE;


--
-- Name: qa_findings qa_findings_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.qa_findings
    ADD CONSTRAINT qa_findings_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id);


--
-- Name: qa_findings qa_findings_error_code_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.qa_findings
    ADD CONSTRAINT qa_findings_error_code_fkey FOREIGN KEY (error_code) REFERENCES public.error_definitions(code);


--
-- Name: qa_findings qa_findings_reviewed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.qa_findings
    ADD CONSTRAINT qa_findings_reviewed_by_fkey FOREIGN KEY (reviewed_by) REFERENCES public.agents(id);


--
-- Name: qa_findings qa_findings_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.qa_findings
    ADD CONSTRAINT qa_findings_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: rate_limit_log rate_limit_log_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rate_limit_log
    ADD CONSTRAINT rate_limit_log_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id);


--
-- Name: regression_suite_definitions regression_suite_definitions_baseline_scorecard_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.regression_suite_definitions
    ADD CONSTRAINT regression_suite_definitions_baseline_scorecard_id_fkey FOREIGN KEY (baseline_scorecard_id) REFERENCES public.run_scorecards(id);


--
-- Name: regression_suite_definitions regression_suite_definitions_canonical_wo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.regression_suite_definitions
    ADD CONSTRAINT regression_suite_definitions_canonical_wo_id_fkey FOREIGN KEY (canonical_wo_id) REFERENCES public.work_orders(id);


--
-- Name: regression_suite_runs regression_suite_runs_suite_definition_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.regression_suite_runs
    ADD CONSTRAINT regression_suite_runs_suite_definition_id_fkey FOREIGN KEY (suite_definition_id) REFERENCES public.regression_suite_definitions(id) ON DELETE CASCADE;


--
-- Name: regression_suite_runs regression_suite_runs_test_scorecard_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.regression_suite_runs
    ADD CONSTRAINT regression_suite_runs_test_scorecard_id_fkey FOREIGN KEY (test_scorecard_id) REFERENCES public.run_scorecards(id);


--
-- Name: regression_suite_runs regression_suite_runs_test_wo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.regression_suite_runs
    ADD CONSTRAINT regression_suite_runs_test_wo_id_fkey FOREIGN KEY (test_wo_id) REFERENCES public.work_orders(id);


--
-- Name: run_scorecards run_scorecards_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.run_scorecards
    ADD CONSTRAINT run_scorecards_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: sandbox_executions sandbox_executions_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.sandbox_executions
    ADD CONSTRAINT sandbox_executions_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: scaffold_contracts scaffold_contracts_object_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.scaffold_contracts
    ADD CONSTRAINT scaffold_contracts_object_id_fkey FOREIGN KEY (object_id) REFERENCES public.object_registry(id);


--
-- Name: scaffold_contracts scaffold_contracts_pipeline_run_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.scaffold_contracts
    ADD CONSTRAINT scaffold_contracts_pipeline_run_id_fkey FOREIGN KEY (pipeline_run_id) REFERENCES public.pipeline_runs(id);


--
-- Name: schema_changes schema_changes_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.schema_changes
    ADD CONSTRAINT schema_changes_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: spans spans_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.spans
    ADD CONSTRAINT spans_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id);


--
-- Name: spans spans_parent_span_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.spans
    ADD CONSTRAINT spans_parent_span_id_fkey FOREIGN KEY (parent_span_id) REFERENCES public.spans(id);


--
-- Name: spans spans_trace_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.spans
    ADD CONSTRAINT spans_trace_id_fkey FOREIGN KEY (trace_id) REFERENCES public.traces(trace_id);


--
-- Name: state_mutations state_mutations_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.state_mutations
    ADD CONSTRAINT state_mutations_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id);


--
-- Name: state_mutations state_mutations_rollback_mutation_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.state_mutations
    ADD CONSTRAINT state_mutations_rollback_mutation_id_fkey FOREIGN KEY (rollback_mutation_id) REFERENCES public.state_mutations(id);


--
-- Name: state_mutations state_mutations_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.state_mutations
    ADD CONSTRAINT state_mutations_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: system_directives system_directives_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.system_directives
    ADD CONSTRAINT system_directives_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.project_briefs(id);


--
-- Name: system_directives system_directives_thread_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.system_directives
    ADD CONSTRAINT system_directives_thread_id_fkey FOREIGN KEY (thread_id) REFERENCES public.conversation_threads(id);


--
-- Name: team_context team_context_root_wo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.team_context
    ADD CONSTRAINT team_context_root_wo_id_fkey FOREIGN KEY (root_wo_id) REFERENCES public.work_orders(id);


--
-- Name: team_context team_context_source_wo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.team_context
    ADD CONSTRAINT team_context_source_wo_id_fkey FOREIGN KEY (source_wo_id) REFERENCES public.work_orders(id);


--
-- Name: thread_messages thread_messages_thread_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.thread_messages
    ADD CONSTRAINT thread_messages_thread_id_fkey FOREIGN KEY (thread_id) REFERENCES public.conversation_threads(id) ON DELETE CASCADE;


--
-- Name: traces traces_thread_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.traces
    ADD CONSTRAINT traces_thread_id_fkey FOREIGN KEY (thread_id) REFERENCES public.conversation_threads(id);


--
-- Name: traces traces_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.traces
    ADD CONSTRAINT traces_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: verification_log verification_log_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.verification_log
    ADD CONSTRAINT verification_log_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: wo_batches wo_batches_project_brief_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_batches
    ADD CONSTRAINT wo_batches_project_brief_id_fkey FOREIGN KEY (project_brief_id) REFERENCES public.project_briefs(id) ON DELETE SET NULL;


--
-- Name: wo_effects wo_effects_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_effects
    ADD CONSTRAINT wo_effects_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: wo_events wo_events_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_events
    ADD CONSTRAINT wo_events_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: wo_execution_manifest wo_execution_manifest_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_execution_manifest
    ADD CONSTRAINT wo_execution_manifest_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: wo_file_locks wo_file_locks_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_file_locks
    ADD CONSTRAINT wo_file_locks_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: wo_mutations wo_mutations_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wo_mutations
    ADD CONSTRAINT wo_mutations_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id);


--
-- Name: work_order_execution_log work_order_execution_log_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.work_order_execution_log
    ADD CONSTRAINT work_order_execution_log_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: work_orders work_orders_assigned_to_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.work_orders
    ADD CONSTRAINT work_orders_assigned_to_fkey FOREIGN KEY (assigned_to) REFERENCES public.agents(id);


--
-- Name: work_orders work_orders_backlog_source_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.work_orders
    ADD CONSTRAINT work_orders_backlog_source_id_fkey FOREIGN KEY (backlog_source_id) REFERENCES public.backlog(id);


--
-- Name: work_orders work_orders_enforcer_run_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.work_orders
    ADD CONSTRAINT work_orders_enforcer_run_id_fkey FOREIGN KEY (enforcer_run_id) REFERENCES public.enforcer_runs(id);


--
-- Name: work_orders work_orders_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.work_orders
    ADD CONSTRAINT work_orders_parent_id_fkey FOREIGN KEY (parent_id) REFERENCES public.work_orders(id);


--
-- Name: work_orders work_orders_pipeline_run_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.work_orders
    ADD CONSTRAINT work_orders_pipeline_run_id_fkey FOREIGN KEY (pipeline_run_id) REFERENCES public.pipeline_runs(id);


--
-- Name: work_orders work_orders_project_brief_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.work_orders
    ADD CONSTRAINT work_orders_project_brief_id_fkey FOREIGN KEY (project_brief_id) REFERENCES public.project_briefs(id);


--
-- Name: workspace_events workspace_events_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.workspace_events
    ADD CONSTRAINT workspace_events_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id) ON DELETE SET NULL;


--
-- Name: workspace_events workspace_events_target_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.workspace_events
    ADD CONSTRAINT workspace_events_target_agent_id_fkey FOREIGN KEY (target_agent_id) REFERENCES public.agents(id) ON DELETE SET NULL;


--
-- Name: workspace_events workspace_events_work_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.workspace_events
    ADD CONSTRAINT workspace_events_work_order_id_fkey FOREIGN KEY (work_order_id) REFERENCES public.work_orders(id) ON DELETE CASCADE;


--
-- Name: workspace_locks workspace_locks_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.workspace_locks
    ADD CONSTRAINT workspace_locks_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agents(id) ON DELETE CASCADE;


--
-- Name: project_context Allow all operations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow all operations" ON public.project_context USING (true) WITH CHECK (true);


--
-- Name: agent_escalation_tiers Allow read access to agent_escalation_tiers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow read access to agent_escalation_tiers" ON public.agent_escalation_tiers FOR SELECT USING (true);


--
-- Name: wo_mutations Allow service role insert wo_mutations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow service role insert wo_mutations" ON public.wo_mutations FOR INSERT TO authenticated WITH CHECK (true);


--
-- Name: clarification_requests Authenticated users can read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can read" ON public.clarification_requests FOR SELECT TO authenticated USING (true);


--
-- Name: wo_mutations Block all delete wo_mutations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Block all delete wo_mutations" ON public.wo_mutations FOR DELETE TO authenticated USING (false);


--
-- Name: wo_mutations Block all update wo_mutations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Block all update wo_mutations" ON public.wo_mutations FOR UPDATE TO authenticated USING (false) WITH CHECK (false);


--
-- Name: clarification_requests Service role full access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access" ON public.clarification_requests TO service_role USING (true) WITH CHECK (true);


--
-- Name: project_context Service role full access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access" ON public.project_context USING ((auth.role() = 'service_role'::text)) WITH CHECK ((auth.role() = 'service_role'::text));


--
-- Name: system_directives Service role full access to directives; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to directives" ON public.system_directives USING (true);


--
-- Name: thread_messages Service role full access to messages; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to messages" ON public.thread_messages USING (true);


--
-- Name: conversation_threads Service role full access to threads; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role full access to threads" ON public.conversation_threads USING (true);


--
-- Name: secrets Service role only; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role only" ON public.secrets USING ((auth.role() = 'service_role'::text)) WITH CHECK ((auth.role() = 'service_role'::text));


--
-- Name: active_sessions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.active_sessions ENABLE ROW LEVEL SECURITY;

--
-- Name: agent_daemon_config; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.agent_daemon_config ENABLE ROW LEVEL SECURITY;

--
-- Name: agent_daemon_config agent_daemon_config_service_role; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY agent_daemon_config_service_role ON public.agent_daemon_config USING (((auth.jwt() ->> 'role'::text) = 'service_role'::text));


--
-- Name: agent_escalation_tiers; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.agent_escalation_tiers ENABLE ROW LEVEL SECURITY;

--
-- Name: agent_execution_profiles; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.agent_execution_profiles ENABLE ROW LEVEL SECURITY;

--
-- Name: work_order_execution_log agent_insert_own_execution_log; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY agent_insert_own_execution_log ON public.work_order_execution_log FOR INSERT TO authenticated WITH CHECK ((EXISTS ( SELECT 1
   FROM public.work_orders wo
  WHERE ((wo.id = work_order_execution_log.work_order_id) AND ((wo.assigned_to)::text = ((current_setting('request.jwt.claims'::text, true))::json ->> 'agent_id'::text))))));


--
-- Name: agent_quotas; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.agent_quotas ENABLE ROW LEVEL SECURITY;

--
-- Name: work_orders agent_update_own_work_orders; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY agent_update_own_work_orders ON public.work_orders FOR UPDATE TO authenticated USING (((assigned_to)::text = ((current_setting('request.jwt.claims'::text, true))::json ->> 'agent_id'::text))) WITH CHECK (((assigned_to)::text = ((current_setting('request.jwt.claims'::text, true))::json ->> 'agent_id'::text)));


--
-- Name: agents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.agents ENABLE ROW LEVEL SECURITY;

--
-- Name: agents agents_read_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY agents_read_all ON public.agents FOR SELECT USING (true);


--
-- Name: agent_execution_profiles agents_read_all_profiles; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY agents_read_all_profiles ON public.agent_execution_profiles FOR SELECT USING (true);


--
-- Name: allowed_actions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.allowed_actions ENABLE ROW LEVEL SECURITY;

--
-- Name: work_order_execution_log anon_insert_execution_log; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY anon_insert_execution_log ON public.work_order_execution_log FOR INSERT TO anon WITH CHECK (true);


--
-- Name: allowed_actions anon_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY anon_read ON public.allowed_actions FOR SELECT TO anon USING (true);


--
-- Name: audit_log anon_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY anon_read ON public.audit_log FOR SELECT TO anon USING (true);


--
-- Name: consensus_votes anon_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY anon_read ON public.consensus_votes FOR SELECT USING (true);


--
-- Name: qa_findings anon_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY anon_read ON public.qa_findings FOR SELECT USING (true);


--
-- Name: request_schemas anon_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY anon_read ON public.request_schemas FOR SELECT TO anon USING (true);


--
-- Name: work_order_execution_log anon_read_execution_log; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY anon_read_execution_log ON public.work_order_execution_log FOR SELECT TO anon USING (true);


--
-- Name: system_manifest anon_read_manifest; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY anon_read_manifest ON public.system_manifest FOR SELECT TO anon USING (true);


--
-- Name: state_mutations anon_read_mutations; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY anon_read_mutations ON public.state_mutations FOR SELECT TO anon USING (true);


--
-- Name: work_orders anon_read_work_orders; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY anon_read_work_orders ON public.work_orders FOR SELECT TO anon USING (true);


--
-- Name: approval_queue; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.approval_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: approval_queue approval_queue_service_role_full; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY approval_queue_service_role_full ON public.approval_queue USING (true) WITH CHECK (true);


--
-- Name: audit_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;

--
-- Name: auto_approval_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.auto_approval_log ENABLE ROW LEVEL SECURITY;

--
-- Name: auto_approval_log auto_approval_log_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY auto_approval_log_read ON public.auto_approval_log FOR SELECT TO anon USING (true);


--
-- Name: bypass_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.bypass_log ENABLE ROW LEVEL SECURITY;

--
-- Name: bypass_log bypass_log_service_role_full; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY bypass_log_service_role_full ON public.bypass_log USING (true) WITH CHECK (true);


--
-- Name: clarification_requests; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.clarification_requests ENABLE ROW LEVEL SECURITY;

--
-- Name: consensus_votes; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.consensus_votes ENABLE ROW LEVEL SECURITY;

--
-- Name: consensus_votes consensus_votes_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY consensus_votes_read ON public.consensus_votes FOR SELECT TO anon USING (true);


--
-- Name: consensus_votes consensus_votes_service; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY consensus_votes_service ON public.consensus_votes TO service_role USING (true);


--
-- Name: conversation_threads; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.conversation_threads ENABLE ROW LEVEL SECURITY;

--
-- Name: council_presets; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.council_presets ENABLE ROW LEVEL SECURITY;

--
-- Name: council_presets council_presets_anon_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY council_presets_anon_read ON public.council_presets FOR SELECT TO anon USING (true);


--
-- Name: daemon_heartbeats; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.daemon_heartbeats ENABLE ROW LEVEL SECURITY;

--
-- Name: daemon_heartbeats daemon_heartbeats_service_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY daemon_heartbeats_service_all ON public.daemon_heartbeats USING (true) WITH CHECK (true);


--
-- Name: decisions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.decisions ENABLE ROW LEVEL SECURITY;

--
-- Name: enforcer_canary; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.enforcer_canary ENABLE ROW LEVEL SECURITY;

--
-- Name: enforcer_canary enforcer_canary_deny_standard_write; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_canary_deny_standard_write ON public.enforcer_canary USING ((NOT ((((current_setting('request.jwt.claims'::text, true))::json ->> 'role'::text) = ANY (ARRAY['authenticated'::text, 'anon'::text])) AND (((current_setting('request.jwt.claims'::text, true))::json ->> 'sub'::text) <> 'enforcer-service'::text))));


--
-- Name: enforcer_canary enforcer_canary_enforcer_write; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_canary_enforcer_write ON public.enforcer_canary USING (((((current_setting('request.jwt.claims'::text, true))::json ->> 'role'::text) = 'enforcer'::text) OR (((current_setting('request.jwt.claims'::text, true))::json ->> 'sub'::text) = 'enforcer-service'::text))) WITH CHECK (((((current_setting('request.jwt.claims'::text, true))::json ->> 'role'::text) = 'enforcer'::text) OR (((current_setting('request.jwt.claims'::text, true))::json ->> 'sub'::text) = 'enforcer-service'::text)));


--
-- Name: enforcer_canary enforcer_canary_read_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_canary_read_all ON public.enforcer_canary FOR SELECT USING (true);


--
-- Name: enforcer_findings; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.enforcer_findings ENABLE ROW LEVEL SECURITY;

--
-- Name: enforcer_findings enforcer_findings_block_others; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_findings_block_others ON public.enforcer_findings USING (false) WITH CHECK (false);


--
-- Name: enforcer_findings enforcer_findings_deny_standard_write; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_findings_deny_standard_write ON public.enforcer_findings USING ((NOT ((((current_setting('request.jwt.claims'::text, true))::json ->> 'role'::text) = ANY (ARRAY['authenticated'::text, 'anon'::text])) AND (((current_setting('request.jwt.claims'::text, true))::json ->> 'sub'::text) <> 'enforcer-service'::text))));


--
-- Name: enforcer_findings enforcer_findings_enforcer_write; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_findings_enforcer_write ON public.enforcer_findings USING (((((current_setting('request.jwt.claims'::text, true))::json ->> 'role'::text) = 'enforcer'::text) OR (((current_setting('request.jwt.claims'::text, true))::json ->> 'sub'::text) = 'enforcer-service'::text))) WITH CHECK (((((current_setting('request.jwt.claims'::text, true))::json ->> 'role'::text) = 'enforcer'::text) OR (((current_setting('request.jwt.claims'::text, true))::json ->> 'sub'::text) = 'enforcer-service'::text)));


--
-- Name: enforcer_findings enforcer_findings_read_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_findings_read_all ON public.enforcer_findings FOR SELECT USING (true);


--
-- Name: enforcer_findings enforcer_findings_read_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_findings_read_policy ON public.enforcer_findings FOR SELECT USING (true);


--
-- Name: enforcer_findings enforcer_findings_write_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_findings_write_policy ON public.enforcer_findings TO enforcer_role USING (true) WITH CHECK (true);


--
-- Name: enforcer_runs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.enforcer_runs ENABLE ROW LEVEL SECURITY;

--
-- Name: enforcer_runs enforcer_runs_block_others; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_runs_block_others ON public.enforcer_runs USING (false) WITH CHECK (false);


--
-- Name: enforcer_runs enforcer_runs_deny_standard_write; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_runs_deny_standard_write ON public.enforcer_runs USING ((NOT ((((current_setting('request.jwt.claims'::text, true))::json ->> 'role'::text) = ANY (ARRAY['authenticated'::text, 'anon'::text])) AND (((current_setting('request.jwt.claims'::text, true))::json ->> 'sub'::text) <> 'enforcer-service'::text))));


--
-- Name: enforcer_runs enforcer_runs_enforcer_write; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_runs_enforcer_write ON public.enforcer_runs USING (((((current_setting('request.jwt.claims'::text, true))::json ->> 'role'::text) = 'enforcer'::text) OR (((current_setting('request.jwt.claims'::text, true))::json ->> 'sub'::text) = 'enforcer-service'::text))) WITH CHECK (((((current_setting('request.jwt.claims'::text, true))::json ->> 'role'::text) = 'enforcer'::text) OR (((current_setting('request.jwt.claims'::text, true))::json ->> 'sub'::text) = 'enforcer-service'::text)));


--
-- Name: enforcer_runs enforcer_runs_read_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_runs_read_all ON public.enforcer_runs FOR SELECT USING (true);


--
-- Name: enforcer_runs enforcer_runs_read_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_runs_read_policy ON public.enforcer_runs FOR SELECT USING (true);


--
-- Name: enforcer_runs enforcer_runs_write_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY enforcer_runs_write_policy ON public.enforcer_runs TO enforcer_role USING (true) WITH CHECK (true);


--
-- Name: error_definitions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.error_definitions ENABLE ROW LEVEL SECURITY;

--
-- Name: error_definitions error_definitions_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY error_definitions_read ON public.error_definitions FOR SELECT USING (true);


--
-- Name: error_definitions error_definitions_write; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY error_definitions_write ON public.error_definitions USING ((auth.role() = 'service_role'::text));


--
-- Name: intake_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.intake_log ENABLE ROW LEVEL SECURITY;

--
-- Name: intake_log intake_log_anon_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY intake_log_anon_read ON public.intake_log FOR SELECT TO anon USING (true);


--
-- Name: intake_log intake_log_service_write; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY intake_log_service_write ON public.intake_log TO service_role USING (true);


--
-- Name: interaction_definitions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.interaction_definitions ENABLE ROW LEVEL SECURITY;

--
-- Name: interaction_definitions interaction_definitions_insert_service_role; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY interaction_definitions_insert_service_role ON public.interaction_definitions FOR INSERT WITH CHECK (((current_setting('request.jwt.claim.role'::text, true) = 'service_role'::text) OR (current_setting('request.jwt.claim.role'::text, true) = 'authenticated'::text)));


--
-- Name: interaction_definitions interaction_definitions_select_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY interaction_definitions_select_all ON public.interaction_definitions FOR SELECT USING (true);


--
-- Name: interaction_definitions interaction_definitions_update_service_role; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY interaction_definitions_update_service_role ON public.interaction_definitions FOR UPDATE USING (((current_setting('request.jwt.claim.role'::text, true) = 'service_role'::text) OR (current_setting('request.jwt.claim.role'::text, true) = 'authenticated'::text)));


--
-- Name: llm_provider_config; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.llm_provider_config ENABLE ROW LEVEL SECURITY;

--
-- Name: llm_provider_config llm_provider_config_authenticated_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY llm_provider_config_authenticated_read ON public.llm_provider_config FOR SELECT TO authenticated USING (true);


--
-- Name: llm_provider_config llm_provider_config_service_role_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY llm_provider_config_service_role_all ON public.llm_provider_config TO service_role USING (true) WITH CHECK (true);


--
-- Name: llm_usage; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.llm_usage ENABLE ROW LEVEL SECURITY;

--
-- Name: llm_usage llm_usage_authenticated_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY llm_usage_authenticated_read ON public.llm_usage FOR SELECT TO authenticated USING (true);


--
-- Name: llm_usage llm_usage_service_role_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY llm_usage_service_role_all ON public.llm_usage TO service_role USING (true) WITH CHECK (true);


--
-- Name: object_registry; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.object_registry ENABLE ROW LEVEL SECURITY;

--
-- Name: agent_execution_profiles only_ilmarinen_writes; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY only_ilmarinen_writes ON public.agent_execution_profiles USING ((((current_setting('request.jwt.claims'::text, true))::jsonb ->> 'agent_name'::text) = 'ilmarinen'::text));


--
-- Name: pipeline_runs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.pipeline_runs ENABLE ROW LEVEL SECURITY;

--
-- Name: pipeline_runs pipeline_runs_delete_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY pipeline_runs_delete_policy ON public.pipeline_runs FOR DELETE USING (true);


--
-- Name: pipeline_runs pipeline_runs_insert_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY pipeline_runs_insert_policy ON public.pipeline_runs FOR INSERT WITH CHECK (true);


--
-- Name: pipeline_runs pipeline_runs_update_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY pipeline_runs_update_policy ON public.pipeline_runs FOR UPDATE USING (true);


--
-- Name: project_context; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.project_context ENABLE ROW LEVEL SECURITY;

--
-- Name: qa_findings; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.qa_findings ENABLE ROW LEVEL SECURITY;

--
-- Name: qa_findings qa_findings_read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY qa_findings_read ON public.qa_findings FOR SELECT TO anon USING (true);


--
-- Name: qa_findings qa_findings_service; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY qa_findings_service ON public.qa_findings TO service_role USING (true);


--
-- Name: rate_limit_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.rate_limit_log ENABLE ROW LEVEL SECURITY;

--
-- Name: request_schemas; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.request_schemas ENABLE ROW LEVEL SECURITY;

--
-- Name: sandbox_executions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.sandbox_executions ENABLE ROW LEVEL SECURITY;

--
-- Name: sandbox_executions sandbox_executions_service_role_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY sandbox_executions_service_role_all ON public.sandbox_executions TO service_role USING (true) WITH CHECK (true);


--
-- Name: schema_changes; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.schema_changes ENABLE ROW LEVEL SECURITY;

--
-- Name: secrets; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.secrets ENABLE ROW LEVEL SECURITY;

--
-- Name: team_context service_role_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_all ON public.team_context USING (true) WITH CHECK (true);


--
-- Name: agent_quotas service_role_full; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full ON public.agent_quotas TO service_role USING (true) WITH CHECK (true);


--
-- Name: allowed_actions service_role_full; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full ON public.allowed_actions TO service_role USING (true) WITH CHECK (true);


--
-- Name: audit_log service_role_full; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full ON public.audit_log TO service_role USING (true) WITH CHECK (true);


--
-- Name: rate_limit_log service_role_full; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full ON public.rate_limit_log TO service_role USING (true) WITH CHECK (true);


--
-- Name: request_schemas service_role_full; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full ON public.request_schemas TO service_role USING (true) WITH CHECK (true);


--
-- Name: consensus_votes service_role_full_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full_access ON public.consensus_votes USING (true) WITH CHECK (true);


--
-- Name: decisions service_role_full_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full_access ON public.decisions TO service_role USING (true) WITH CHECK (true);


--
-- Name: qa_findings service_role_full_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full_access ON public.qa_findings USING (true) WITH CHECK (true);


--
-- Name: schema_changes service_role_full_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full_access ON public.schema_changes TO service_role USING (true) WITH CHECK (true);


--
-- Name: state_mutations service_role_full_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full_access ON public.state_mutations TO service_role USING (true) WITH CHECK (true);


--
-- Name: system_manifest service_role_full_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full_access ON public.system_manifest TO service_role USING (true) WITH CHECK (true);


--
-- Name: wo_execution_manifest service_role_full_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full_access ON public.wo_execution_manifest USING (false) WITH CHECK ((auth.role() = 'service_role'::text));


--
-- Name: work_order_execution_log service_role_full_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full_access ON public.work_order_execution_log TO service_role USING (true) WITH CHECK (true);


--
-- Name: work_orders service_role_full_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_full_access ON public.work_orders TO service_role USING (true) WITH CHECK (true);


--
-- Name: active_sessions service_role_only_active_sessions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY service_role_only_active_sessions ON public.active_sessions USING ((current_setting('app.current_agent_name'::text, true) = ANY (ARRAY['ilmarinen'::text, 'builder'::text, 'security'::text]))) WITH CHECK ((current_setting('app.current_agent_name'::text, true) = ANY (ARRAY['ilmarinen'::text, 'builder'::text, 'security'::text])));


--
-- Name: state_mutations; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.state_mutations ENABLE ROW LEVEL SECURITY;

--
-- Name: system_directives; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.system_directives ENABLE ROW LEVEL SECURITY;

--
-- Name: system_manifest; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.system_manifest ENABLE ROW LEVEL SECURITY;

--
-- Name: system_settings; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.system_settings ENABLE ROW LEVEL SECURITY;

--
-- Name: system_settings system_settings_modify_service_role; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY system_settings_modify_service_role ON public.system_settings USING ((auth.role() = 'service_role'::text));


--
-- Name: system_settings system_settings_read_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY system_settings_read_all ON public.system_settings FOR SELECT USING (true);


--
-- Name: team_context; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.team_context ENABLE ROW LEVEL SECURITY;

--
-- Name: thread_messages; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.thread_messages ENABLE ROW LEVEL SECURITY;

--
-- Name: verification_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.verification_log ENABLE ROW LEVEL SECURITY;

--
-- Name: verification_log verification_log_read_policy; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY verification_log_read_policy ON public.verification_log FOR SELECT USING ((CURRENT_USER IS NOT NULL));


--
-- Name: wo_events; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.wo_events ENABLE ROW LEVEL SECURITY;

--
-- Name: wo_events_archive; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.wo_events_archive ENABLE ROW LEVEL SECURITY;

--
-- Name: wo_events_archive wo_events_archive_all_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY wo_events_archive_all_access ON public.wo_events_archive USING (true) WITH CHECK (true);


--
-- Name: wo_events wo_events_system_access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY wo_events_system_access ON public.wo_events USING (true) WITH CHECK (true);


--
-- Name: wo_execution_manifest; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.wo_execution_manifest ENABLE ROW LEVEL SECURITY;

--
-- Name: wo_mutations; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.wo_mutations ENABLE ROW LEVEL SECURITY;

--
-- Name: wo_mutations wo_mutations_block_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY wo_mutations_block_delete ON public.wo_mutations FOR DELETE TO service_role USING (false);


--
-- Name: wo_mutations wo_mutations_block_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY wo_mutations_block_update ON public.wo_mutations FOR UPDATE TO service_role USING (false) WITH CHECK (false);


--
-- Name: wo_mutations wo_mutations_service_role_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY wo_mutations_service_role_insert ON public.wo_mutations FOR INSERT TO service_role WITH CHECK (true);


--
-- Name: work_order_execution_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.work_order_execution_log ENABLE ROW LEVEL SECURITY;

--
-- Name: work_orders; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.work_orders ENABLE ROW LEVEL SECURITY;

--
-- Name: workspace_events; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.workspace_events ENABLE ROW LEVEL SECURITY;

--
-- Name: workspace_events workspace_events_insert_own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY workspace_events_insert_own ON public.workspace_events FOR INSERT WITH CHECK (((agent_id)::text = COALESCE(current_setting('app.current_agent_id'::text, true), ''::text)));


--
-- Name: workspace_events workspace_events_read_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY workspace_events_read_all ON public.workspace_events FOR SELECT USING (true);


--
-- Name: workspace_locks; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.workspace_locks ENABLE ROW LEVEL SECURITY;

--
-- Name: workspace_locks workspace_locks_delete_own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY workspace_locks_delete_own ON public.workspace_locks FOR DELETE USING (((agent_id)::text = COALESCE(current_setting('app.current_agent_id'::text, true), ''::text)));


--
-- Name: workspace_locks workspace_locks_insert_own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY workspace_locks_insert_own ON public.workspace_locks FOR INSERT WITH CHECK (((agent_id)::text = COALESCE(current_setting('app.current_agent_id'::text, true), ''::text)));


--
-- Name: workspace_locks workspace_locks_read_all; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY workspace_locks_read_all ON public.workspace_locks FOR SELECT USING (true);


--
-- PostgreSQL database dump complete
--

-- \unrestrict 345qCG4fryG5UtnPOhAqTGFvQbxvasies3LxPOYMAKHqiyHKZCIZHz8alagbiez

